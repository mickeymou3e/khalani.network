{"version":3,"file":"static/chunks/9641.32876a6450be9177.js","mappings":"wvCAAO,MAAMA,EAAU,kB,oCCSvB,MAAMC,EAAS,IAAI,EAAAC,OAAOF,GACnB,MAAMG,EACTC,cACIH,EAAOI,oBAAqBF,GAC5BG,KAAKC,QAAUD,KAAKE,oBAExBA,oBACI,MAAMD,EAAU,GACVE,EAAUH,KAAKG,QAAQC,KAAKJ,MAC5BK,EAAYL,KAAKK,UAAUD,KAAKJ,MAChCM,EAAWN,KAAKM,SAASF,KAAKJ,MAC9BO,EAAOP,KAAKO,KAAKH,KAAKJ,MACtBQ,EAAOR,KAAKQ,KAAKJ,KAAKJ,MACtBS,EAAMT,KAAKS,IAAIL,KAAKJ,MACpBU,EAASV,KAAKU,OAAON,KAAKJ,MAC1BW,EAAOX,KAAKW,KAAKP,KAAKJ,MAuG5B,OArGAC,EAAQW,YAAc,CAClBJ,KAAMA,EACNG,KAAMA,EACNE,WAAYhB,EAAUiB,UAAUd,KAAKa,WAAWT,KAAKJ,MAAO,MAC5De,UAAWlB,EAAUiB,UAAUN,EAAM,MACrCQ,YAAanB,EAAUiB,UAAUJ,EAAQ,MACzCO,iBAAkBpB,EAAUiB,UAAUJ,EAAQ,MAC9CQ,cAAerB,EAAUiB,UAAUJ,EAAQ,MAC3CS,KAAMhB,EAGNiB,SAAUvB,EAAUiB,UAAUT,GAC9BgB,qBAAsBxB,EAAUiB,UAAUT,GAC1CiB,aAAczB,EAAUiB,UAAUT,GAClCkB,SAAUlB,EACVmB,GAAI3B,EAAUiB,UAAUX,EAAS,MACjCsB,MAAOpB,EACPqB,MAAOhB,EACPH,KAAMA,EACNoB,EAAG9B,EAAUiB,UAAUd,KAAK4B,SAC5BC,EAAGhC,EAAUiB,UAAUd,KAAK4B,SAC5BE,EAAGjC,EAAUiB,UAAUJ,GACvBqB,QAASlC,EAAUiB,UAAUX,EAAS,MACtC6B,IAAKnC,EAAUiB,UAAUP,IAE7BN,EAAQgC,mBAAqB,CACzBd,KAAMtB,EAAUiB,UAAUX,GAC1BuB,MAAO7B,EAAUiB,UAAUJ,GAC3Ba,SAAU1B,EAAUiB,UAAUT,GAC9Be,SAAUvB,EAAUiB,UAAUT,GAC9BgB,qBAAsBxB,EAAUiB,UAAUT,GAC1CiB,aAAczB,EAAUiB,UAAUT,GAClCmB,GAAI3B,EAAUiB,UAAUX,GACxBsB,MAAO5B,EAAUiB,UAAUT,GAC3BE,KAAMV,EAAUiB,WAnCAgB,GAAe9B,KAAKO,KAAKuB,GAAG,KAoC5CnB,KAAMd,EAAUiB,UAAUJ,GAC1BG,WAAYhB,EAAUiB,UAAUd,KAAKa,WAAWT,KAAKJ,MAAO,OAEhEC,EAAQiC,WAAa,CACjBjB,iBAAkBP,EAClBM,YAAaN,EACbyB,gBAAiB3B,EACjBL,QAASA,EACTiC,OAAQvC,EAAUwC,QAAQ7B,GAC1BD,KAAMA,EACN+B,SAAU5B,EACVK,UAAWP,GAEfP,EAAQsC,QAAU,CACdf,GAAI3B,EAAUiB,UAAUd,KAAKG,QAAS,MACtCgB,KAAMtB,EAAUiB,UAAUd,KAAKG,QAAS,MACxCqC,gBAAiB3C,EAAUiB,UAAUX,EAAS,MAC9Cc,iBAAkBP,EAElB+B,KAAM5C,EAAUiB,UAAUL,GAC1BiC,QAASrC,EACTsC,UAAW9C,EAAUiB,UAAUP,GAC/BQ,UAAWP,EACX2B,gBAAiB3B,EACjBoC,KAAM/C,EAAUwC,QAAQrC,KAAKkC,WAAW9B,KAAKJ,OAC7CgB,YAAaN,EACbQ,cAAerB,EAAUiB,UAAUJ,EAAQ,MAC3CmC,kBAAmBxC,EACnByC,kBAAmBjD,EAAUiB,UAAUT,GACvC0C,OAAQlD,EAAUiB,UAAUJ,GAC5BC,KAAMA,GAEVV,EAAQ+C,MAAQ,CACZxC,KAAMA,EACNyC,WAAYzC,EACZE,OAAQA,EACRwC,UAAWxC,EACXgB,MAAO7B,EAAUiB,UAAUL,GAC3B0C,WAAYnD,KAAKmD,WAAW/C,KAAKJ,MACjCuB,SAAUlB,EACVqC,QAASrC,EACT+C,MAAOjD,EACPkD,UAAW9C,EACX+C,aAAczD,EAAUiB,UAAUjB,EAAUwC,QAAQ7B,IACpD+C,cAAe1D,EAAUiB,UAAUT,IAEvCJ,EAAQuD,uBAAwB,IAAAC,aAAYxD,EAAQ+C,OACpD/C,EAAQuD,sBAAsBF,aAAezD,EAAUiB,UAAUjB,EAAUwC,QAAQrC,KAAK0D,oBAAoBtD,KAAKJ,QACjHC,EAAQ0D,OAAS,CACbC,UAAW/D,EAAUiB,UAAUR,OAAUuD,GACzCC,QAASjE,EAAUiB,UAAUR,OAAUuD,GACvC9C,UAAWlB,EAAUiB,UAAUN,OAAMqD,GACrC1D,QAASN,EAAUiB,UAAUX,OAAS0D,GACtCzB,OAAQvC,EAAUiB,UAAUd,KAAKoC,OAAOhC,KAAKJ,WAAO6D,IAExD5D,EAAQ8D,UAAY,CAChB/C,YAAanB,EAAUiB,UAAUJ,GACjCK,UAAWlB,EAAUiB,UAAUN,GAC/BS,iBAAkBP,EAClBsD,QAASnE,EAAUiB,UAAUd,KAAKiE,QAAQ7D,KAAKJ,OAC/CG,QAASA,EACTI,KAAMV,EAAUqE,aAAa3D,EAAM,MACnC6B,OAAQvC,EAAUwC,QAAQ7B,GAC1B2B,gBAAiB3B,EACjB8B,SAAU5B,GAEPT,EAEXY,WAAWA,GACP,OAAO,IAAAsD,eAActD,GAAc,IAIvCH,OAAOA,GACH,MAAe,OAAXA,EACO,EAEJ,UAAeA,GAAQ0D,WAElCzD,KAAKD,GACD,MAAe,OAAXA,GAA6B,MAAVA,EACZ,EAEJ,UAAeA,GAAQ0D,WAGlC/D,UAAUoB,GACN,OAAO,UAAeA,GAG1BwC,QAAQxC,GACJ,GAAuB,mBAAZ,EACP,OAAOA,EAEX,GAAuB,kBAAZ,EAAsB,CAE7B,GAAc,UADdA,EAAQA,EAAM4C,eAEV,OAAO,EAEX,GAAc,UAAV5C,EACA,OAAO,EAGf,MAAM,IAAI6C,MAAM,qBAAuB7C,GAE3ChB,IAAIgB,EAAO8C,GACP,MAAuB,kBAAZ,IACFA,GAAoC,OAA1B9C,EAAM+C,UAAU,EAAG,KAC9B/C,EAAQ,KAAOA,IAEf,IAAAgD,aAAYhD,IACLA,EAAM4C,cAGd1E,EAAO+E,mBAAmB,eAAgB,QAASjD,GAE9DlB,KAAKkB,EAAO8C,GACR,MAAMI,EAAS3E,KAAKS,IAAIgB,EAAO8C,GAC/B,GAAKI,EAAOC,OAAS,IAAO,EACxB,MAAM,IAAIN,MAAM,8BAAgC7C,GAEpD,OAAOkD,EAIXxE,QAAQsB,GACJ,OAAO,IAAAoD,YAAWpD,GAEtBqD,YAAYrD,GACR,KAAK,IAAAgD,aAAYhD,EAAO,IACpB,OAAO,KAEX,MAAMtB,GAAU,IAAA0E,aAAW,IAAAE,cAAatD,EAAO,KAC/C,OAAQtB,IAAY,IAAe,KAAOA,EAE9CqC,gBAAgBf,GACZ,OAAO,IAAAuD,oBAAmBvD,GAG9BnB,SAASA,GACL,GAAgB,MAAZA,EACA,MAAO,SAEX,GAAiB,aAAbA,EACA,MAAO,MAEX,GAAiB,WAAbA,GAAsC,YAAbA,EACzB,OAAOA,EAEX,GAA0B,kBAAf,IAA2B,IAAAmE,aAAYnE,GAC9C,OAAO,IAAA2E,UAAS3E,GAEpB,MAAM,IAAIgE,MAAM,oBAGpB9D,KAAKiB,EAAO8C,GACR,MAAMI,EAAS3E,KAAKS,IAAIgB,EAAO8C,GAC/B,OAA8B,MAA1B,IAAAW,eAAcP,GACPhF,EAAO+E,mBAAmB,eAAgB,QAASjD,GAEvDkD,EAGXxB,WAAW1B,GACP,GAAa,MAATA,EACA,OAAO,KAEX,MAAMK,EAAI,UAAeL,GACzB,IACI,OAAOK,EAAEsC,WAEb,MAAOe,IACP,OAAO,KAEXvD,QAAQH,GACJ,KAAK,IAAAgD,aAAYhD,GACb,MAAM,IAAI6C,MAAM,mBAEpB,OAAO,IAAAc,YAAW3D,EAAO,IAE7B4D,OAAO5D,EAAO6D,GACU,MAAhB7D,EAAM8D,QAAiC,MAAf9D,EAAM2B,QAC9B3B,EAAM2B,MAAQ3B,EAAM8D,QAGxB,MAAMpC,EAAmC,MAArB1B,EAAM+D,YAAuB/D,EAAM+D,YAAc/D,EAAM0B,WACrEwB,EAAS9E,EAAU4F,MAAMH,EAAQ7D,GAEvC,OADAkD,EAAOa,YAA8B,MAAdrC,EAAsB,KAAO,UAAeA,GAC5DwB,EAEX3B,MAAMvB,GACF,OAAOzB,KAAKqF,OAAO5D,EAAOzB,KAAKC,QAAQ+C,OAE3CQ,sBAAsB/B,GAClB,OAAOzB,KAAKqF,OAAO5D,EAAOzB,KAAKC,QAAQuD,uBAG3CvB,mBAAmBR,GACf,OAAO5B,EAAU4F,MAAMzF,KAAKC,QAAQgC,mBAAoBR,GAE5DiC,oBAAoB9C,GAEO,MAAnBA,EAAY8E,KAAuC,MAAxB9E,EAAYW,WACvCX,EAAYW,SAAWX,EAAY8E,KAInC9E,EAAYY,IAAM,UAAeZ,EAAYY,IAAImE,WACjD/E,EAAYY,GAAK,8CAGI,MAArBZ,EAAYgF,OAAqC,MAApBhF,EAAYL,OACzCK,EAAYL,KAAOK,EAAYgF,OAGb,MAAlBhF,EAAYY,IAAqC,MAAvBZ,EAAYmB,UACtCnB,EAAYmB,QAAU/B,KAAKwC,gBAAgB5B,IAErB,IAArBA,EAAYD,MAAmC,IAArBC,EAAYD,MAAyC,MAA1BC,EAAYC,aAClED,EAAYC,WAAa,IAE7B,MAAM8D,EAAS9E,EAAU4F,MAAMzF,KAAKC,QAAQW,YAAaA,GACzD,GAA2B,MAAvBA,EAAYiF,QAAiB,CAC7B,IAAIA,EAAUjF,EAAYiF,SACtB,IAAApB,aAAYoB,KACZA,EAAU,UAAeA,GAASzB,YAEtCO,EAAOkB,QAAUA,MAEhB,CACD,IAAIA,EAAUjF,EAAYkF,UAEX,MAAXD,GAA+B,MAAZlB,EAAO7C,IAC1B+D,EAAUjF,EAAYiF,UAEtB,IAAApB,aAAYoB,KACZA,EAAU,UAAeA,GAASzB,YAEb,kBAAd,GAAsC,MAAZO,EAAO7C,IACxC+D,GAAWlB,EAAO7C,EAAI,IAAM,EACxB+D,EAAU,IACVA,EAAU,GAEdA,EAAUE,SAASF,IAEE,kBAAd,IACPA,EAAU,GAEdlB,EAAOkB,QAAUA,EAMrB,OAHIlB,EAAO5D,WAAoD,MAAvC4D,EAAO5D,UAAUiF,QAAQ,KAAM,MACnDrB,EAAO5D,UAAY,MAEhB4D,EAEX/D,YAAYa,GACR,OAAO,IAAAwE,OAAiBxE,GAE5BS,WAAWT,GACP,OAAO5B,EAAU4F,MAAMzF,KAAKC,QAAQiC,WAAYT,GAEpDc,QAAQd,GACJ,MAAMkD,EAAS9E,EAAU4F,MAAMzF,KAAKC,QAAQsC,QAASd,GAErD,GAAmB,MAAfkD,EAAOlC,KACP,GAAIkC,EAAOlC,KAAKmC,QAAU,EAAG,CAEzB,MAAMnD,EAAQ,UAAekD,EAAOlC,MAAM2B,WAC5B,IAAV3C,GAAyB,IAAVA,GAEM,MAAjBkD,EAAO5B,QAAmB4B,EAAO5B,SAAWtB,GAC5C9B,EAAO+E,mBAAmB,kCAAmC,QAAS,CAAEjC,KAAMkC,EAAOlC,KAAMM,OAAQ4B,EAAO5B,SAE9G4B,EAAO5B,OAAStB,SACTkD,EAAOlC,MAGd9C,EAAO+E,mBAAmB,0BAA2B,aAAcC,EAAOlC,WAGlD,KAAvBkC,EAAOlC,KAAKmC,QAEjBjF,EAAO+E,mBAAmB,oBAAqB,aAAcC,EAAOlC,MAM5E,OAHqB,MAAjBkC,EAAO5B,SACP4B,EAAOuB,WAAY,GAEhBvB,EAEXvC,OAAOX,GACH,OAAI0E,MAAMC,QAAQ3E,GACPA,EAAM4E,KAAKvE,GAAM9B,KAAKoC,OAAON,KAEtB,MAATL,EACEzB,KAAKQ,KAAKiB,GAAO,GAErB,KAEXkC,OAAOlC,GACH,OAAO5B,EAAU4F,MAAMzF,KAAKC,QAAQ0D,OAAQlC,GAEhDsC,UAAUtC,GACN,OAAO5B,EAAU4F,MAAMzF,KAAKC,QAAQ8D,UAAWtC,GAEnD6E,aAAahB,EAAQiB,GACjB,MAAM5B,EAAS,GACf,IAAK,MAAM6B,KAAOlB,EACd,IACI,MAAM7D,EAAQ6D,EAAOkB,GAAKD,EAAOC,SACnB3C,IAAVpC,IACAkD,EAAO6B,GAAO/E,GAGtB,MAAO0D,GAGH,MAFAA,EAAMsB,SAAWD,EACjBrB,EAAMuB,WAAaH,EAAOC,GACpBrB,EAGd,OAAOR,EAGX2B,iBAAiBhB,EAAQqB,GACrB,OAAO,SAAWlF,GACd,OAAa,MAATA,EACOkF,EAEJrB,EAAO7D,IAItB6E,oBAAoBhB,EAAQsB,GACxB,OAAO,SAAWnF,GACd,OAAKA,EAGE6D,EAAO7D,GAFHmF,GAMnBN,eAAehB,GACX,OAAO,SAAWuB,GACd,IAAKV,MAAMC,QAAQS,GACf,MAAM,IAAIvC,MAAM,gBAEpB,MAAMK,EAAS,GAIf,OAHAkC,EAAMC,SAAQ,SAAUrF,GACpBkD,EAAOoC,KAAKzB,EAAO7D,OAEhBkD,IAIZ,SAASqC,EAAuBvF,GACnC,OAAQA,GAAgD,oBAA/BA,EAAyB,oBAE/C,SAASwF,EAAoBxF,GAChC,OAAQuF,EAAuBvF,IAAUA,EAAMwF,sBAGnD,IAAIC,GAAkB,EACf,SAASC,IACRD,IAGJA,GAAkB,EAClBE,QAAQC,IAAI,8BACZD,QAAQC,IAAI,8DACZD,QAAQC,IAAI,IACZD,QAAQC,IAAI,6EACZD,QAAQC,IAAI,sEACZD,QAAQC,IAAI,IACZD,QAAQC,IAAI,2EACZD,QAAQC,IAAI,0EACZD,QAAQC,IAAI,iFACZD,QAAQC,IAAI,IACZD,QAAQC,IAAI,sDACZD,QAAQC,IAAI,+BCvbhB,IAAIC,EAAwC,SAAUC,EAASC,EAAYC,EAAGC,GAE1E,OAAO,IAAKD,IAAMA,EAAIE,WAAU,SAAUC,EAASC,GAC/C,SAASC,EAAUrG,GAAS,IAAMsG,EAAKL,EAAUM,KAAKvG,IAAW,MAAOwG,GAAKJ,EAAOI,IACpF,SAASC,EAASzG,GAAS,IAAMsG,EAAKL,EAAiB,MAAEjG,IAAW,MAAOwG,GAAKJ,EAAOI,IACvF,SAASF,EAAKpD,GAJlB,IAAelD,EAIakD,EAAOwD,KAAOP,EAAQjD,EAAOlD,QAJ1CA,EAIyDkD,EAAOlD,MAJhDA,aAAiBgG,EAAIhG,EAAQ,IAAIgG,GAAE,SAAUG,GAAWA,EAAQnG,OAIT2G,KAAKN,EAAWI,GAClGH,GAAML,EAAYA,EAAUW,MAAMd,EAASC,GAAc,KAAKQ,YAiBtE,MAAM,EAAS,IAAI,EAAApI,OAAOF,GAI1B,SAAS4I,EAAWC,GAChB,OAAa,MAATA,EACO,QAEkB,MAAzB,IAAArD,eAAcqD,IACd,EAAO7D,mBAAmB,gBAAiB,QAAS6D,GAEjDA,EAAMlE,eAEjB,SAASmE,EAAgBpG,GAGrB,IADAA,EAASA,EAAOqG,QACTrG,EAAOwC,OAAS,GAAkC,MAA7BxC,EAAOA,EAAOwC,OAAS,IAC/CxC,EAAOsG,MAEX,OAAOtG,EAAOiE,KAAKkC,IACf,GAAIpC,MAAMC,QAAQmC,GAAQ,CAEtB,MAAMI,EAAS,GACfJ,EAAMzB,SAASyB,IACXI,EAAOL,EAAWC,KAAU,KAGhC,MAAMK,EAASC,OAAOC,KAAKH,GAE3B,OADAC,EAAOG,OACAH,EAAOI,KAAK,KAGnB,OAAOV,EAAWC,MAEvBS,KAAK,KAgBZ,SAASC,EAAYC,GACjB,GAA2B,kBAAhB,EAA0B,CAEjC,GADAA,EAAYA,EAAU7E,cACW,MAA7B,IAAAa,eAAcgE,GACd,MAAO,MAAQA,EAEnB,IAAgC,IAA5BA,EAAUC,QAAQ,KAClB,OAAOD,MAGV,IAAI/C,MAAMC,QAAQ8C,GACnB,MAAO,YAAcV,EAAgBU,GAEpC,GAAI,iBAAsBA,GAE3B,MADA,EAAOE,KAAK,mBACN,IAAI9E,MAAM,mBAEf,GAAI4E,GAAoC,kBAAhB,EACzB,MAAO,WAAaA,EAAU/I,SAAW,KAAO,IAAMqI,EAAgBU,EAAU9G,QAAU,IAE9F,MAAM,IAAIkC,MAAM,mBAAqB4E,GAIzC,SAASG,IACL,OAAO,IAAKC,MAAQD,UAExB,SAASE,EAAMC,GACX,OAAO,IAAI7B,SAASC,IAChB6B,WAAW7B,EAAS4B,MAiB5B,MAAME,EAAiB,CAAC,QAAS,UAAW,UAAW,QAChD,MAAMC,EACT7J,YAAY8J,EAAKC,EAAUC,IACvB,IAAAC,gBAAe/J,KAAM,MAAO4J,IAC5B,IAAAG,gBAAe/J,KAAM,WAAY6J,IACjC,IAAAE,gBAAe/J,KAAM,OAAQ8J,GAE7BE,YACA,OAAQhK,KAAKW,MACT,IAAK,KACD,OAAOX,KAAKQ,KAChB,IAAK,SACD,OAAOR,KAAK2D,OAEpB,OAAO3D,KAAK4J,IAEZjJ,WACA,OAAOX,KAAK4J,IAAIK,MAAM,KAAK,GAE3BzJ,WACA,MAAM0J,EAAQlK,KAAK4J,IAAIK,MAAM,KAC7B,MAAiB,OAAbC,EAAM,GACC,KAEJA,EAAM,GAEbvG,aACA,MAAMuG,EAAQlK,KAAK4J,IAAIK,MAAM,KAC7B,GAAiB,WAAbC,EAAM,GACN,OAAO,KAEX,MAAM/J,EAAU+J,EAAM,GAChB9H,EA3FG,MADU7B,EA4Fc2J,EAAM,IA1FhC,GAEJ3J,EAAK0J,MAAM,MAAM5D,KAAKkC,IACzB,GAAc,KAAVA,EACA,MAAO,GAEX,MAAM2B,EAAQ3B,EAAM0B,MAAM,KAAK5D,KAAKkC,GACb,SAAVA,EAAoB,KAAOA,IAExC,OAA0B,IAAjB2B,EAAMtF,OAAgBsF,EAAM,GAAKA,KAXlD,IAA2B3J,EA6FnB,MAAMoD,EAAS,GAOf,OANIvB,EAAOwC,OAAS,IAChBjB,EAAOvB,OAASA,GAEhBjC,GAAuB,MAAZA,IACXwD,EAAOxD,QAAUA,GAEdwD,EAEXwG,WACI,OAAQnK,KAAK4J,IAAIT,QAAQ,MAAQ,GAAKO,EAAeP,QAAQnJ,KAAK4J,MAAQ,GAKlF,MAAMQ,EAAY,CACd,EAAK,CAAEC,OAAQ,MAAOC,MAAO,EAAMC,KAAM,EAAMC,OAAQ,MACvD,EAAK,CAAEH,OAAQ,MAAOC,MAAO,GAAMC,KAAM,GAAMC,OAAQ,OACvD,EAAK,CAAEH,OAAQ,OAAQC,MAAO,GAAMC,KAAM,IAC1C,GAAM,CAAEF,OAAQ,MAAOI,IAAK,OAC5B,GAAM,CAAEJ,OAAQ,MAAOI,IAAK,OAC5B,IAAO,CAAEJ,OAAQ,OAAQI,IAAK,QAElC,SAASC,EAAWjJ,GAChB,OAAO,IAAA2D,YAAW,UAAe3D,GAAOkJ,cAAe,IAG3D,SAASC,EAAarK,GAClB,OAAO,EAAAsK,OAAA,QAAc,IAAAC,QAAO,CAACvK,GAAM,IAAAwE,eAAa,EAAAgG,EAAA,KAAO,EAAAA,EAAA,IAAOxK,IAAQ,EAAG,MAE7E,MAAMyK,EAAW,CACb,IAAIC,OAAO,mBAAqB,KAChC,IAAIA,OAAO,gBAAiB,KAC5B,IAAIA,OAAO,kBAAoB,KAC/B,IAAIA,OAAO,mCAAoC,MAEnD,SAASC,EAAavG,GAClB,IACI,OAAO,QAAawG,EAAYxG,IAEpC,MAAOQ,IACP,OAAO,KAEX,SAASgG,EAAYxG,GACjB,GAAe,OAAXA,EACA,OAAO,KAEX,MAAMyG,EAAS,WAAe,IAAArG,cAAaJ,EAAQ,EAAG,KAAKP,WACrDQ,EAAS,WAAe,IAAAG,cAAaJ,EAAQyG,EAAQA,EAAS,KAAKhH,WACzE,OAAO,IAAAW,cAAaJ,EAAQyG,EAAS,GAAIA,EAAS,GAAKxG,GAEpD,MAAMyG,EAETvL,YAAYwL,EAAUnL,EAASoL,EAAMC,IACjC,IAAAzB,gBAAe/J,KAAM,WAAYsL,IACjC,IAAAvB,gBAAe/J,KAAM,OAAQuL,IAC7B,IAAAxB,gBAAe/J,KAAM,UAAWsL,EAASG,UAAUtL,QAAQA,KAC3D,IAAA4J,gBAAe/J,KAAM,mBAAoBwL,GAE7CE,YAAYC,EAAUC,GAClB,OAAOtE,EAAUtH,UAAM,OAAQ,GAAQ,YAEnC,MAAM6L,EAAK,CACPrK,GAAIxB,KAAKG,QACTI,MAAM,IAAAuL,WAAU,CAACH,GAAU,EAAAI,EAAA,IAAS/L,KAAKuL,MAAQK,GAAc,QAEnE,IACI,OAAOT,QAAkBnL,KAAKsL,SAASU,KAAKH,IAEhD,MAAO1G,GACH,OAAIA,EAAM8G,KAAS,EAAArM,OAAA,sBACR,SAMvBsM,YAAYC,EAAUC,GAClB,MAAMC,EAAWjC,EAAUkC,OAAOH,IAMlC,GALgB,MAAZE,GACA,EAAOE,WAAW,0BAA0BJ,IAAY,EAAAvM,OAAA,6BAAqC,CACzF4M,UAAW,cAAcL,OAGZ,QAAjBE,EAAS5B,IACT,OAAOzK,KAAKsL,SAASG,UAAUtL,QAAQiM,GAE3C,MAAMK,GAAQ,IAAAC,UAASN,GAEvB,GAAsB,MAAlBC,EAAS/B,MAAe,CACxB,MAAMA,EAAQ8B,EAASO,MAAM,6CAC7B,GAAIrC,EAAO,CACP,MAAM1F,EAASmB,SAASuE,EAAM,GAAI,IAClC,GAAIA,EAAM,GAAG1F,SAAoB,EAATA,GAAcA,GAAU,GAAKA,GAAU,GAC3D,OAAOgG,GAAa,IAAAE,QAAO,CAAC,CAACuB,EAAS/B,OAAS,KAAOA,EAAM,OAKxE,GAAqB,MAAjB+B,EAAS9B,KAAc,CACvB,MAAMA,EAAO6B,EAASO,MAAM,yCAC5B,GAAIpC,EAAM,CACN,MAAM3F,EAASmB,SAASwE,EAAK,GAAI,IACjC,GAAIA,EAAK,GAAG3F,SAAoB,EAATA,GAAcA,GAAU,GAAKA,GAAU,GAC1D,OAAOgG,GAAa,IAAAE,QAAO,CAAC,CAACuB,EAAS9B,MAAQ,KAAOA,EAAK,OAKtE,GAAuB,MAAnB8B,EAAS7B,OAAgB,CACzB,MAAM5F,EAAS6H,EAAM,GAErB,IAAI/M,EAAU+M,EAAM,GASpB,GARgB,IAAZ/M,EACe,KAAXkF,GAA4B,KAAXA,IACjBlF,GAAW,GAIfA,GAAW,EAEXA,GAAW,GAAK+M,EAAM7H,SAAW,EAAIA,GAAUA,GAAU,GAAKA,GAAU,GAAI,CAC5E,MAAMgI,EAAQ,YAAeH,EAAMhE,MAAM,IAEzC,OADAmE,EAAMC,QAAQnN,GACP,WAAc2M,EAAS7B,OAAQoC,IAG9C,OAAO,KAEX/H,WAAWsH,GACP,OAAO7E,EAAUtH,UAAM,OAAQ,GAAQ,YAKnC,GAJgB,MAAZmM,IACAA,EAAW,IAGE,KAAbA,EACA,IAEI,MAAMvL,EAAc,CAChBY,GAAIxB,KAAKG,QACTI,KAAO,cAAe,EAAAwL,EAAA,IAAS/L,KAAKuL,MAAM/G,UAAU,IAElD4H,QAAiBpM,KAAKsL,SAASU,KAAKpL,GAE1C,MAAiB,OAAbwL,GAAqBA,IAAa,IAC3B,KAEJpM,KAAKsL,SAASG,UAAU3G,YAAYsH,GAE/C,MAAOjH,GACH,GAAIA,EAAM8G,OAAS,EAAArM,OAAA,sBACf,OAAO,KAEX,MAAMuF,EAId,MAAMiH,QAAiBpM,KAAK0L,YAAY,aAAchB,EAAWyB,IAEjE,GAAgB,MAAZC,GAAiC,OAAbA,EACpB,OAAO,KAGX,MAAMjM,EAAUH,KAAKkM,YAAYC,EAAUC,GAQ3C,OAPe,MAAXjM,GACA,EAAOoM,WAAW,mCAAoC,EAAA3M,OAAA,6BAAqC,CACvF4M,UAAW,cAAcL,KACzBA,SAAUA,EACV5L,KAAM6L,IAGPjM,KAGf2M,YACI,OAAOxF,EAAUtH,UAAM,OAAQ,GAAQ,YACnC,MAAM+M,EAAU,GAChB,IACI,MAAMC,QAAehN,KAAKiN,QAAQ,UAClC,GAAc,MAAVD,EACA,OAAO,KAEX,IAAK,IAAIE,EAAI,EAAGA,EAAIlC,EAASpG,OAAQsI,IAAK,CACtC,MAAMP,EAAQK,EAAOL,MAAM3B,EAASkC,IACpC,GAAa,MAATP,EAGJ,OAAQA,EAAM,IACV,IAAK,QAED,OADAI,EAAQhG,KAAK,CAAEpG,KAAM,MAAOwM,QAASH,IAC9B,CAAED,QAAAA,EAASK,IAAKJ,GAC3B,IAAK,OAED,OADAD,EAAQhG,KAAK,CAAEpG,KAAM,OAAQwM,QAASH,IAC/B,CAAED,QAAAA,EAASK,IAAKJ,GAC3B,IAAK,OAED,OADAD,EAAQhG,KAAK,CAAEpG,KAAM,OAAQwM,QAASH,IAC/B,CAAED,QAAAA,EAASK,IAAK,gCAAiCJ,EAAOxI,UAAU,MAC7E,IAAK,SACL,IAAK,UAAW,CAEZ,MAAMmH,EAAyB,WAAbgB,EAAM,GAAmB,aAAe,aAC1DI,EAAQhG,KAAK,CAAEpG,KAAMgM,EAAM,GAAIQ,QAASH,IAExC,MAAMK,EAASrN,KAAKsN,yBAA2BtN,KAAK6E,cAC9CqF,GAASyC,EAAM,IAAM,IAAI1C,MAAM,KACrC,GAAqB,IAAjBC,EAAMtF,OACN,OAAO,KAEX,MAAM2I,QAAavN,KAAKsL,SAASG,UAAUtL,QAAQ+J,EAAM,IACnDsD,GAAU,IAAApI,YAAW,UAAe8E,EAAM,IAAIS,cAAe,IAEnE,GAAiB,WAAbgC,EAAM,GAAiB,CAEvB,MAAMc,EAAazN,KAAKsL,SAASG,UAAU3G,kBAAkB9E,KAAKsL,SAASU,KAAK,CAC5ExK,GAAI+L,EAAMhN,MAAM,IAAAuL,WAAU,CAAC,aAAc0B,OAE7C,GAAIH,IAAUI,EACV,OAAO,KAEXV,EAAQhG,KAAK,CAAEpG,KAAM,QAASwM,QAASM,SAEtC,GAAiB,YAAbd,EAAM,GAAkB,CAE7B,MAAMe,EAAU,gBAAqB1N,KAAKsL,SAASU,KAAK,CACpDxK,GAAI+L,EAAMhN,MAAM,IAAAuL,WAAU,CAAC,cAAc,IAAA1G,YAAWiI,EAAO,IAAKG,OAEpE,GAAIE,EAAQ/H,SACR,OAAO,KAEXoH,EAAQhG,KAAK,CAAEpG,KAAM,UAAWwM,QAASO,EAAQC,aAGrD,MAAM9B,EAAK,CACPrK,GAAIxB,KAAKsL,SAASG,UAAUtL,QAAQ+J,EAAM,IAC1C3J,MAAM,IAAAuL,WAAU,CAACH,EAAU6B,KAE/B,IAAII,EAAc1C,QAAmBlL,KAAKsL,SAASU,KAAKH,IACxD,GAAmB,MAAf+B,EACA,OAAO,KAEXb,EAAQhG,KAAK,CAAEpG,KAAM,eAAgBwM,QAASS,IAE7B,YAAbjB,EAAM,KACNiB,EAAcA,EAAY5H,QAAQ,OAAQwH,EAAQhJ,UAAU,KAGhE,MAAMqJ,QAAiB,IAAAC,WAAUF,GAEjC,OAAKC,GAAwC,kBAApBA,EAAc,OAAmBA,EAASE,MAAMpB,MAAM,iBAG/EI,EAAQhG,KAAK,CAAEpG,KAAM,WAAYwM,QAASa,KAAKC,UAAUJ,KACzDd,EAAQhG,KAAK,CAAEpG,KAAM,MAAOwM,QAASU,EAASE,QACvC,CAAEhB,QAAAA,EAASK,IAAKS,EAASE,QAJrB,QAS3B,MAAO5I,IACP,OAAO,QAGf+I,iBACI,OAAO5G,EAAUtH,UAAM,OAAQ,GAAQ,YAEnC,MAAMoM,QAAiBpM,KAAK0L,YAAY,cAExC,GAAgB,MAAZU,GAAiC,OAAbA,EACpB,OAAO,KAGX,MAAM+B,EAAO/B,EAASO,MAAM,iEAC5B,GAAIwB,EAAM,CACN,MAAMvJ,EAASmB,SAASoI,EAAK,GAAI,IACjC,GAAIA,EAAK,GAAGvJ,SAAoB,EAATA,EACnB,MAAO,UAAa,EAAAiG,OAAA,OAAc,KAAOsD,EAAK,IAItD,MAAMC,EAAQhC,EAASO,MAAM,iCAC7B,OAAIyB,GACwB,KAApBA,EAAM,GAAGxJ,OACF,SAAYwJ,EAAM,GAG1B,EAAO7B,WAAW,2CAA4C,EAAA3M,OAAA,6BAAqC,CACtG4M,UAAW,mBACXjM,KAAM6L,OAIlBa,QAAQzG,GACJ,OAAOc,EAAUtH,UAAM,OAAQ,GAAQ,YAEnC,IAAIqO,GAAW,QAAY7H,GAG3B6H,GAAW,IAAAvD,QAAO,CAACJ,EAAW,IAAKA,EAAW2D,EAASzJ,QAASyJ,IAE3DA,EAASzJ,OAAS,KAAQ,IAC3ByJ,GAAW,IAAAvD,QAAO,CAACuD,GAAU,IAAAjJ,YAAW,KAAM,GAAMoB,EAAI5B,OAAS,OAErE,MAAMwH,QAAiBpM,KAAK0L,YAAY,cAAc,IAAA4C,SAAQD,IAC9D,OAAgB,MAAZjC,GAAiC,OAAbA,EACb,MAEJ,QAAaA,OAIhC,IAAImC,EAAmB,KACnBC,EAAa,EACV,MAAMC,UAAqB,KAU9B3O,YAAY4O,GAcR,GAbA,EAAO3O,oBAAqB,MAC5B4O,QAEA3O,KAAK4O,QAAU,GACf5O,KAAK6O,SAAW,CAAE7L,OAAQ,GAC1BhD,KAAKyL,qBAAuBqD,gBAI5B,IAAA/E,gBAAe/J,KAAM,aAA2B,QAAZ0O,GAChC1O,KAAK+O,aACLL,EAAU1O,KAAKgP,iBAEfN,aAAmB/G,QACnB3H,KAAKiP,gBAAkBP,EAEvBA,EAAQQ,OAAO/J,QAEfnF,KAAKmP,SAASD,OAAO/J,YAEpB,CACD,MAAMiK,GAAe,IAAAC,sBAAsB,aAAtB,CAAoCX,GACrDU,IACA,IAAArF,gBAAe/J,KAAM,WAAYoP,GACjCpP,KAAKsP,KAAK,UAAWF,EAAc,OAGnC,EAAO1K,mBAAmB,kBAAmB,UAAWgK,GAGhE1O,KAAKuP,yBAA2B,KAChCvP,KAAKwP,kBAAoB,EACzBxP,KAAKyP,iBAAmB,IACxBzP,KAAK0P,eAAiB,EAE1BP,SACI,OAAO7H,EAAUtH,UAAM,OAAQ,GAAQ,YACnC,GAAqB,MAAjBA,KAAK2P,SAAkB,CACvB,IAAIjB,EAAU,KACd,GAAI1O,KAAKiP,gBACL,IACIP,QAAgB1O,KAAKiP,gBAEzB,MAAO9J,IAGI,MAAXuJ,IACAA,QAAgB1O,KAAKgP,iBAIpBN,GACD,EAAOnC,WAAW,sBAAuB,EAAA3M,OAAA,qBAA6B,IAGrD,MAAjBI,KAAK2P,WACD3P,KAAK+O,WACL/O,KAAK2P,SAAWjB,GAGhB,IAAA3E,gBAAe/J,KAAM,WAAY0O,GAErC1O,KAAKsP,KAAK,UAAWZ,EAAS,OAGtC,OAAO1O,KAAK2P,YAMhBC,YACA,OAAO,IAAAC,OAAK,IACD7P,KAAKmP,SAAS/G,MAAMsG,GAChBA,IACPvJ,IAEA,GAAIA,EAAM8G,OAAS,EAAArM,OAAA,sBAA+C,cAAhBuF,EAAM6E,MAGxD,MAAM7E,OAKlBmB,sBAII,OAHwB,MAApBiI,IACAA,EAAmB,IAAI1O,GAEpB0O,EAGXjI,kBAAkBoI,GACd,OAAO,OAAuB,MAAXA,EAAmB,YAAcA,GAIxDoB,wBAAwBC,GACpB,OAAOzI,EAAUtH,UAAM,OAAQ,GAAQ,YAGnC,SAFMA,KAAKmP,SAEPY,EAAS,EAET,KAAO/P,KAAKgQ,sBAAsB,CAE9B,MAAMC,EAAsBjQ,KAAKgQ,qBACjC,IAEI,MAAMrL,QAAesL,EACrB,GAAK5G,IAAY1E,EAAOuL,UAAaH,EACjC,OAAOpL,EAAO3D,YAGlB,MAEJ,MAAOmE,GAKH,GAAInF,KAAKgQ,uBAAyBC,EAC9B,OAKhB,MAAME,EAAU9G,IACV+G,GAA2B,IAAAC,mBAAkB,CAC/CrP,YAAahB,KAAKsQ,QAAQ,iBAAkB,IAC5CC,aAAcvQ,KAAKwQ,aAAapI,MAAMsG,GAAY,OAASvJ,GAAU,MACtEiD,MAAK,EAAGpH,YAAAA,EAAauP,aAAAA,MACpB,GAAIA,EAKA,MAHIvQ,KAAKgQ,uBAAyBI,IAC9BpQ,KAAKgQ,qBAAuB,MAE1BO,EAEV,MAAML,EAAW7G,IAOjB,OANArI,EAAc,UAAeA,GAAaoD,YACxBpE,KAAKuP,0BACnBvO,EAAchB,KAAKuP,yBAEvBvP,KAAKuP,wBAA0BvO,EAC/BhB,KAAKyQ,oBAAoBzP,GAClB,CAAEA,YAAAA,EAAamP,QAAAA,EAASD,SAAAA,MAUnC,OARAlQ,KAAKgQ,qBAAuBI,EAE5BA,EAAyBlB,OAAO/J,IAExBnF,KAAKgQ,uBAAyBI,IAC9BpQ,KAAKgQ,qBAAuB,gBAGtBI,GAA0BpP,eAGhD6O,OACI,OAAOvI,EAAUtH,UAAM,OAAQ,GAAQ,YACnC,MAAM0Q,EAASlC,IAETmC,EAAU,GAChB,IAAI3P,EAAc,KAClB,IACIA,QAAoBhB,KAAK8P,wBAAwB,IAAM9P,KAAK4Q,gBAAkB,GAElF,MAAOzL,GAEH,YADAnF,KAAKsP,KAAK,QAASnK,GAOvB,GAJAnF,KAAKyQ,oBAAoBzP,GAEzBhB,KAAKsP,KAAK,OAAQoB,EAAQ1P,GAEtBA,IAAgBhB,KAAKwP,iBAAzB,CAQA,IAH6B,IAAzBxP,KAAK6O,SAAS7L,QACdhD,KAAK6O,SAAS7L,MAAQhC,EAAc,GAEpC6P,KAAKC,IAAK9Q,KAAK6O,SAAc,MAAI7N,GAAe,IAChD,EAAOoI,KAAK,+DAA+DpJ,KAAK6O,SAAS7L,oBAAoBhC,MAC7GhB,KAAKsP,KAAK,QAAS,EAAOyB,UAAU,8BAA+B,EAAAnR,OAAA,qBAA6B,CAC5FoB,YAAaA,EACbgJ,MAAO,YACPgH,oBAAqBhR,KAAK6O,SAAS7L,SAEvChD,KAAKsP,KAAK,QAAStO,QAInB,IAAK,IAAIkM,EAAIlN,KAAK6O,SAAS7L,MAAQ,EAAGkK,GAAKlM,EAAakM,IACpDlN,KAAKsP,KAAK,QAASpC,GAIvBlN,KAAK6O,SAAS7L,QAAUhC,IACxBhB,KAAK6O,SAAS7L,MAAQhC,EACtB6H,OAAOC,KAAK9I,KAAK6O,UAAU/H,SAASN,IAEhC,GAAY,UAARA,EACA,OAGJ,MAAMyK,EAAmBjR,KAAK6O,SAASrI,GAId,YAArByK,GAKAjQ,EAAciQ,EAAmB,WAC1BjR,KAAK6O,SAASrI,QAKF,IAA3BxG,KAAKwP,mBACLxP,KAAKwP,iBAAmBxO,EAAc,GAG1ChB,KAAK4O,QAAQ9H,SAASkD,IAClB,OAAQA,EAAMrJ,MACV,IAAK,KAAM,CACP,MAAMH,EAAOwJ,EAAMxJ,KACnB,IAAI0Q,EAASlR,KAAKmR,sBAAsB3Q,GAAM4H,MAAM7F,GAC3CA,GAAkC,MAAvBA,EAAQvB,aAGxBhB,KAAK6O,SAAS,KAAOrO,GAAQ+B,EAAQvB,YACrChB,KAAKsP,KAAK9O,EAAM+B,GACT,MAJI,OAKZ2M,OAAO/J,IAAYnF,KAAKsP,KAAK,QAASnK,MACzCwL,EAAQ5J,KAAKmK,GACb,MAEJ,IAAK,SAAU,CACX,MAAMvN,EAASqG,EAAMrG,OACrBA,EAAOC,UAAY5D,KAAKwP,iBAAmB,EAC3C7L,EAAOG,QAAU9C,EACjB,MAAMkQ,EAASlR,KAAKoR,QAAQzN,GAAQyE,MAAMxF,IAClB,IAAhBA,EAAKgC,QAGThC,EAAKkE,SAASO,IACVrH,KAAK6O,SAAS,KAAOxH,EAAItG,WAAasG,EAAIrG,YAC1ChB,KAAK6O,SAAS,KAAOxH,EAAIlF,iBAAmBkF,EAAIrG,YAChDhB,KAAKsP,KAAK3L,EAAQ0D,SAEvB6H,OAAO/J,IAAYnF,KAAKsP,KAAK,QAASnK,MACzCwL,EAAQ5J,KAAKmK,GACb,WAIZlR,KAAKwP,iBAAmBxO,EAExB2G,QAAQ0J,IAAIV,GAASvI,MAAK,KACtBpI,KAAKsP,KAAK,UAAWoB,MACtBxB,OAAO/J,IAAYnF,KAAKsP,KAAK,QAASnK,WAxFrCnF,KAAKsP,KAAK,UAAWoB,MA6FjCY,iBAAiBtQ,GACbhB,KAAKwP,iBAAmBxO,EAAc,EAClChB,KAAKuR,SACLvR,KAAK6P,OAGTnB,cACA,OAAO1O,KAAK2P,SAIhBX,gBACI,OAAO1H,EAAUtH,UAAM,OAAQ,GAAQ,YACnC,OAAO,EAAOuM,WAAW,8CAA+C,EAAA3M,OAAA,6BAAqC,CACzG4M,UAAW,8BAIvBgE,aACI,OAAOlJ,EAAUtH,UAAM,OAAQ,GAAQ,YACnC,MAAM0O,QAAgB1O,KAAKmP,SAIrBqC,QAAuBxR,KAAKgP,gBAClC,GAAIN,EAAQ7I,UAAY2L,EAAe3L,QAAS,CAG5C,GAAI7F,KAAK+O,WAeL,OAdA/O,KAAK2P,SAAW6B,EAEhBxR,KAAKwP,kBAAoB,EACzBxP,KAAKyR,iBAAmB,KACxBzR,KAAK0R,wBAA0B,KAC/B1R,KAAK0P,eAAiB,EACtB1P,KAAK6O,SAAS7L,OAAS,EACvBhD,KAAKuP,yBAA2B,KAChCvP,KAAKgQ,qBAAuB,KAI5BhQ,KAAKsP,KAAK,UAAWkC,EAAgB9C,SAC/BnF,EAAM,GACLvJ,KAAK2P,SAEhB,MAAMxK,EAAQ,EAAO4L,UAAU,6BAA8B,EAAAnR,OAAA,qBAA6B,CACtFoK,MAAO,UACP0E,QAASA,EACTiD,gBAAiBH,IAGrB,MADAxR,KAAKsP,KAAK,QAASnK,GACbA,EAEV,OAAOuJ,KAGX1N,kBAIA,OAHAhB,KAAK8P,wBAAwB,IAAM9P,KAAK4Q,gBAAkB,GAAGxI,MAAMpH,IAC/DhB,KAAKyQ,oBAAoBzP,MACzBmE,QAC6B,MAAzBnF,KAAKyR,iBAA4BzR,KAAKyR,kBAAoB,EAElEF,cACA,OAAwB,MAAhBvR,KAAK4R,QAEbL,YAAQ9P,GACJA,IAAUzB,KAAK4R,SACf5R,KAAK4R,QAAUC,aAAY,KAAQ7R,KAAK6P,SAAW7P,KAAK4Q,iBACnD5Q,KAAK8R,iBACN9R,KAAK8R,eAAiBrI,YAAW,KAC7BzJ,KAAK6P,OAGL7P,KAAK8R,eAAiBrI,YAAW,KAGxBzJ,KAAK4R,SACN5R,KAAK6P,OAGT7P,KAAK8R,eAAiB,OACvB9R,KAAK4Q,mBACT,MAGDnP,GAASzB,KAAK4R,UACpBG,cAAc/R,KAAK4R,SACnB5R,KAAK4R,QAAU,MAGnBhB,sBACA,OAAO5Q,KAAKyP,iBAEZmB,oBAAgBnP,GAChB,GAAuB,kBAAZ,GAAwBA,GAAS,GAAKsE,SAASuG,OAAO7K,KAAWA,EACxE,MAAM,IAAI6C,MAAM,4BAEpBtE,KAAKyP,iBAAmBhO,EACpBzB,KAAK4R,UACLG,cAAc/R,KAAK4R,SACnB5R,KAAK4R,QAAUC,aAAY,KAAQ7R,KAAK6P,SAAW7P,KAAKyP,mBAGhEuC,sBACI,MAAMC,EAAM5I,IAWZ,OATK4I,EAAMjS,KAAK0P,eAAkB,EAAI1P,KAAKyP,mBACvCzP,KAAK0P,eAAiBuC,EACtBjS,KAAK0R,wBAA0B1R,KAAKkS,iBAAiB9J,MAAMpH,KAC1B,MAAzBhB,KAAKyR,kBAA4BzQ,EAAchB,KAAKyR,oBACpDzR,KAAKyR,iBAAmBzQ,GAErBhB,KAAKyR,qBAGbzR,KAAK0R,wBAEhBjB,oBAAoBzP,GAEa,MAAzBhB,KAAKyR,kBAA4BzQ,EAAchB,KAAKyR,mBAIxDzR,KAAK0P,eAAiBrG,KAEO,MAAzBrJ,KAAKyR,kBAA4BzQ,EAAchB,KAAKyR,oBACpDzR,KAAKyR,iBAAmBzQ,EACxBhB,KAAK0R,wBAA0B/J,QAAQC,QAAQ5G,KAGvDmR,mBAAmBhQ,EAAiBjB,EAAekR,GAC/C,OAAO9K,EAAUtH,UAAM,OAAQ,GAAQ,YACnC,OAAOA,KAAKqS,oBAAoBlQ,EAAmC,MAAjBjB,EAAyB,EAAIA,EAAekR,GAAW,EAAG,SAGpHC,oBAAoBlQ,EAAiBjB,EAAekR,EAASE,GACzD,OAAOhL,EAAUtH,UAAM,OAAQ,GAAQ,YACnC,MAAMuC,QAAgBvC,KAAKmR,sBAAsBhP,GAEjD,OAAKI,EAAUA,EAAQrB,cAAgB,IAAMA,EAClCqB,EAGJ,IAAIoF,SAAQ,CAACC,EAASC,KACzB,MAAM0K,EAAc,GACpB,IAAIpK,GAAO,EACX,MAAMqK,EAAc,WAChB,QAAIrK,IAGJA,GAAO,EACPoK,EAAYzL,SAAS2L,IAAWA,QACzB,IAELC,EAAgBnQ,IACdA,EAAQrB,cAAgBA,GAGxBsR,KAGJ5K,EAAQrF,IAIZ,GAFAvC,KAAK2S,GAAGxQ,EAAiBuQ,GACzBH,EAAYxL,MAAK,KAAQ/G,KAAK4S,eAAezQ,EAAiBuQ,MAC1DJ,EAAa,CACb,IAAIO,EAAkBP,EAAYQ,WAC9BC,EAAe,KACnB,MAAMC,EAAkBhS,GAAgBsG,EAAUtH,UAAM,OAAQ,GAAQ,YAChEmI,UAMEoB,EAAM,KACZvJ,KAAKiT,oBAAoBX,EAAYnR,MAAMiH,MAAM1G,GAAU4F,EAAUtH,UAAM,OAAQ,GAAQ,YACvF,IAAImI,EAAJ,CAGA,GAAIzG,GAAS4Q,EAAY5Q,MACrBmR,EAAkB7R,MAEjB,CAED,CACI,MAAMkS,QAAclT,KAAKmT,eAAehR,GACxC,GAAI+Q,GAA8B,MAArBA,EAAMlS,YACf,OAaR,IANoB,MAAhB+R,IACAA,EAAeF,EAAkB,EAC7BE,EAAeT,EAAYQ,aAC3BC,EAAeT,EAAYQ,aAG5BC,GAAgB/R,GAAa,CAChC,GAAImH,EACA,OAEJ,MAAMnF,QAAchD,KAAKoT,yBAAyBL,GAClD,IAAK,IAAIM,EAAK,EAAGA,EAAKrQ,EAAMM,aAAasB,OAAQyO,IAAM,CACnD,MAAMxH,EAAK7I,EAAMM,aAAa+P,GAE9B,GAAIxH,EAAGrL,OAAS2B,EACZ,OAGJ,GAAI0J,EAAG1K,OAASmR,EAAYnR,MAAQ0K,EAAGnK,QAAU4Q,EAAY5Q,MAAO,CAChE,GAAIyG,EACA,OAGJ,MAAM5F,QAAgBvC,KAAKmS,mBAAmBtG,EAAGrL,KAAMU,GAEvD,GAAIsR,IACA,OAGJ,IAAIc,EAAS,WAeb,OAdIzH,EAAGtL,OAAS+R,EAAY/R,MAAQsL,EAAGrK,KAAO8Q,EAAY9Q,IAAMqK,EAAGpK,MAAM8R,GAAGjB,EAAY7Q,OACpF6R,EAAS,WAEQ,OAAZzH,EAAGtL,MAAiBsL,EAAG1K,OAAS0K,EAAGrK,IAAMqK,EAAGpK,MAAMkE,WACvD2N,EAAS,kBAGbzL,EAAO,EAAOkJ,UAAU,2BAA4B,EAAAnR,OAAA,4BAAoC,CACpF4T,UAAuB,aAAXF,GAAoC,cAAXA,EACrCA,OAAAA,EACAG,YAAazT,KAAK0T,iBAAiB7H,GACnCrL,KAAM2B,EACNI,QAAAA,MAKZwQ,KAGJ5K,GAGJnI,KAAK8J,KAAK,QAASkJ,SAClB7N,IACGgD,GAGJnI,KAAK8J,KAAK,QAASkJ,UAG3B,GAAI7K,EACA,OAEJnI,KAAK8J,KAAK,QAASkJ,GACnBT,EAAYxL,MAAK,KACb/G,KAAK4S,eAAe,QAASI,MAGrC,GAAyB,kBAAd,GAA0BZ,EAAU,EAAG,CAC9C,MAAMuB,EAAQlK,YAAW,KACjB+I,KAGJ3K,EAAO,EAAOkJ,UAAU,mBAAoB,EAAAnR,OAAA,eAAuB,CAAEwS,QAASA,OAC/EA,GACCuB,EAAMC,OACND,EAAMC,QAEVrB,EAAYxL,MAAK,KAAQ8M,aAAaF,aAKtDzB,iBACI,OAAO5K,EAAUtH,UAAM,OAAQ,GAAQ,YACnC,OAAOA,KAAK8P,wBAAwB,MAG5CgE,cACI,OAAOxM,EAAUtH,UAAM,OAAQ,GAAQ,kBAC7BA,KAAKwQ,aACX,MAAM7L,QAAe3E,KAAKsQ,QAAQ,cAAe,IACjD,IACI,OAAO,UAAe3L,GAE1B,MAAOQ,GACH,OAAO,EAAOoH,WAAW,0BAA2B,EAAA3M,OAAA,oBAA4B,CAC5EmU,OAAQ,cACRpP,OAAAA,EAAQQ,MAAAA,QAKxB6O,WAAWC,EAAe3T,GACtB,OAAOgH,EAAUtH,UAAM,OAAQ,GAAQ,kBAC7BA,KAAKwQ,aACX,MAAM0D,QAAe,IAAA7D,mBAAkB,CACnClQ,QAASH,KAAKkM,YAAY+H,GAC1B3T,SAAUN,KAAKmU,aAAa7T,KAE1BqE,QAAe3E,KAAKsQ,QAAQ,aAAc4D,GAChD,IACI,OAAO,UAAevP,GAE1B,MAAOQ,GACH,OAAO,EAAOoH,WAAW,0BAA2B,EAAA3M,OAAA,oBAA4B,CAC5EmU,OAAQ,aACRG,OAAAA,EAAQvP,OAAAA,EAAQQ,MAAAA,QAKhC8N,oBAAoBgB,EAAe3T,GAC/B,OAAOgH,EAAUtH,UAAM,OAAQ,GAAQ,kBAC7BA,KAAKwQ,aACX,MAAM0D,QAAe,IAAA7D,mBAAkB,CACnClQ,QAASH,KAAKkM,YAAY+H,GAC1B3T,SAAUN,KAAKmU,aAAa7T,KAE1BqE,QAAe3E,KAAKsQ,QAAQ,sBAAuB4D,GACzD,IACI,OAAO,UAAevP,GAAQP,WAElC,MAAOe,GACH,OAAO,EAAOoH,WAAW,0BAA2B,EAAA3M,OAAA,oBAA4B,CAC5EmU,OAAQ,sBACRG,OAAAA,EAAQvP,OAAAA,EAAQQ,MAAAA,QAKhCiP,QAAQH,EAAe3T,GACnB,OAAOgH,EAAUtH,UAAM,OAAQ,GAAQ,kBAC7BA,KAAKwQ,aACX,MAAM0D,QAAe,IAAA7D,mBAAkB,CACnClQ,QAASH,KAAKkM,YAAY+H,GAC1B3T,SAAUN,KAAKmU,aAAa7T,KAE1BqE,QAAe3E,KAAKsQ,QAAQ,UAAW4D,GAC7C,IACI,OAAO,IAAA5F,SAAQ3J,GAEnB,MAAOQ,GACH,OAAO,EAAOoH,WAAW,0BAA2B,EAAA3M,OAAA,oBAA4B,CAC5EmU,OAAQ,UACRG,OAAAA,EAAQvP,OAAAA,EAAQQ,MAAAA,QAKhCkP,aAAaJ,EAAeK,EAAUhU,GAClC,OAAOgH,EAAUtH,UAAM,OAAQ,GAAQ,kBAC7BA,KAAKwQ,aACX,MAAM0D,QAAe,IAAA7D,mBAAkB,CACnClQ,QAASH,KAAKkM,YAAY+H,GAC1B3T,SAAUN,KAAKmU,aAAa7T,GAC5BgU,SAAU3M,QAAQC,QAAQ0M,GAAUlM,MAAMmM,IAAM,IAAAtP,UAASsP,OAEvD5P,QAAe3E,KAAKsQ,QAAQ,eAAgB4D,GAClD,IACI,OAAO,IAAA5F,SAAQ3J,GAEnB,MAAOQ,GACH,OAAO,EAAOoH,WAAW,0BAA2B,EAAA3M,OAAA,oBAA4B,CAC5EmU,OAAQ,eACRG,OAAAA,EAAQvP,OAAAA,EAAQQ,MAAAA,QAMhCuO,iBAAiB7H,EAAIrL,EAAMsS,GACvB,GAAY,MAARtS,GAAwC,MAAxB,IAAA0E,eAAc1E,GAC9B,MAAM,IAAI8D,MAAM,sCAEpB,MAAMK,EAASkH,EAuCf,OArCY,MAARrL,GAAgBqL,EAAGrL,OAASA,GAC5B,EAAO+L,WAAW,2DAA4D,EAAA3M,OAAA,qBAA6B,CAAE4U,aAAc3I,EAAGrL,KAAMiU,aAAcjU,IAEtJmE,EAAO+P,KAAO,CAACC,EAAUvC,IAAY9K,EAAUtH,UAAM,OAAQ,GAAQ,YAQjE,IAAIyT,EAPY,MAAZkB,IACAA,EAAW,GAEA,MAAXvC,IACAA,EAAU,GAIG,IAAbuC,GAAgC,MAAd7B,IAClBW,EAAc,CACVlT,KAAMsL,EAAGtL,KACTY,KAAM0K,EAAG1K,KACTO,MAAOmK,EAAGnK,MACVF,GAAIqK,EAAGrK,GACPC,MAAOoK,EAAGpK,MACVqR,WAAAA,IAGR,MAAMvQ,QAAgBvC,KAAKqS,oBAAoBxG,EAAGrL,KAAMmU,EAAUvC,EAASqB,GAC3E,OAAe,MAAXlR,GAAgC,IAAboS,EACZ,MAGX3U,KAAK6O,SAAS,KAAOhD,EAAGrL,MAAQ+B,EAAQvB,YACjB,IAAnBuB,EAAQQ,QACR,EAAOwJ,WAAW,qBAAsB,EAAA3M,OAAA,sBAA8B,CAClEuC,gBAAiB0J,EAAGrL,KACpBI,YAAaiL,EACbtJ,QAASA,IAGVA,MAEJoC,EAEXiQ,gBAAgBC,GACZ,OAAOvN,EAAUtH,UAAM,OAAQ,GAAQ,kBAC7BA,KAAKwQ,aACX,MAAMsE,QAAcnN,QAAQC,QAAQiN,GAAmBzM,MAAK2M,IAAK,IAAAzG,SAAQyG,KACnElJ,EAAK7L,KAAKyL,UAAU7K,YAAYiU,GACd,MAApBhJ,EAAG3K,gBACH2K,EAAG3K,cAAgB,GAEvB,MAAMF,QAAoBhB,KAAK8P,wBAAwB,IAAM,EAAI9P,KAAK4Q,iBACtE,IACI,MAAMpQ,QAAaR,KAAKsQ,QAAQ,kBAAmB,CAAEuE,kBAAmBC,IACxE,OAAO9U,KAAK0T,iBAAiB7H,EAAIrL,EAAMQ,GAE3C,MAAOmE,GAGH,MAFAA,EAAMvE,YAAciL,EACpB1G,EAAMhD,gBAAkB0J,EAAGrL,KACrB2E,MAIlB6P,uBAAuBpU,GACnB,OAAO0G,EAAUtH,UAAM,OAAQ,GAAQ,YACnC,MAAMiV,QAAerU,EACfiL,EAAK,GA4BX,MA3BA,CAAC,OAAQ,MAAM/E,SAASN,IACD,MAAfyO,EAAOzO,KAGXqF,EAAGrF,GAAOmB,QAAQC,QAAQqN,EAAOzO,IAAM4B,MAAMtG,GAAOA,EAAI9B,KAAKkM,YAAYpK,GAAK,WAElF,CAAC,WAAY,WAAY,eAAgB,uBAAwB,SAASgF,SAASN,IAC5D,MAAfyO,EAAOzO,KAGXqF,EAAGrF,GAAOmB,QAAQC,QAAQqN,EAAOzO,IAAM4B,MAAMtG,GAAOA,EAAI,UAAeA,GAAK,WAEhF,CAAC,QAAQgF,SAASN,IACK,MAAfyO,EAAOzO,KAGXqF,EAAGrF,GAAOmB,QAAQC,QAAQqN,EAAOzO,IAAM4B,MAAMtG,GAAa,MAALA,EAAaA,EAAI,WAEtEmT,EAAOpU,aACPgL,EAAGhL,WAAab,KAAKyL,UAAU5K,WAAWoU,EAAOpU,aAErD,CAAC,QAAQiG,SAASN,IACK,MAAfyO,EAAOzO,KAGXqF,EAAGrF,GAAOmB,QAAQC,QAAQqN,EAAOzO,IAAM4B,MAAMtG,GAAOA,GAAI,IAAAwM,SAAQxM,GAAK,WAElE9B,KAAKyL,UAAUxJ,yBAAyB,IAAAoO,mBAAkBxE,OAGzEqJ,WAAWvR,GACP,OAAO2D,EAAUtH,UAAM,OAAQ,GAAQ,YACnC2D,QAAeA,EACf,MAAMgB,EAAS,GAgBf,OAfsB,MAAlBhB,EAAOxD,UACPwE,EAAOxE,QAAUH,KAAKkM,YAAYvI,EAAOxD,UAE7C,CAAC,YAAa,UAAU2G,SAASN,IACV,MAAf7C,EAAO6C,KAGX7B,EAAO6B,GAAO7C,EAAO6C,OAEzB,CAAC,YAAa,WAAWM,SAASN,IACX,MAAf7C,EAAO6C,KAGX7B,EAAO6B,GAAOxG,KAAKmU,aAAaxQ,EAAO6C,QAEpCxG,KAAKyL,UAAU9H,aAAa,IAAA0M,mBAAkB1L,OAG7DqH,KAAKpL,EAAaN,GACd,OAAOgH,EAAUtH,UAAM,OAAQ,GAAQ,kBAC7BA,KAAKwQ,aACX,MAAM0D,QAAe,IAAA7D,mBAAkB,CACnCzP,YAAaZ,KAAKgV,uBAAuBpU,GACzCN,SAAUN,KAAKmU,aAAa7T,KAE1BqE,QAAe3E,KAAKsQ,QAAQ,OAAQ4D,GAC1C,IACI,OAAO,IAAA5F,SAAQ3J,GAEnB,MAAOQ,GACH,OAAO,EAAOoH,WAAW,0BAA2B,EAAA3M,OAAA,oBAA4B,CAC5EmU,OAAQ,OACRG,OAAAA,EAAQvP,OAAAA,EAAQQ,MAAAA,QAKhCgQ,YAAYvU,GACR,OAAO0G,EAAUtH,UAAM,OAAQ,GAAQ,kBAC7BA,KAAKwQ,aACX,MAAM0D,QAAe,IAAA7D,mBAAkB,CACnCzP,YAAaZ,KAAKgV,uBAAuBpU,KAEvC+D,QAAe3E,KAAKsQ,QAAQ,cAAe4D,GACjD,IACI,OAAO,UAAevP,GAE1B,MAAOQ,GACH,OAAO,EAAOoH,WAAW,0BAA2B,EAAA3M,OAAA,oBAA4B,CAC5EmU,OAAQ,cACRG,OAAAA,EAAQvP,OAAAA,EAAQQ,MAAAA,QAKhC+G,YAAY+H,GACR,OAAO3M,EAAUtH,UAAM,OAAQ,GAAQ,YAEJ,kBAD/BiU,QAAsBA,IAElB,EAAOvP,mBAAmB,8BAA+B,OAAQuP,GAErE,MAAM9T,QAAgBH,KAAKoV,YAAYnB,GAMvC,OALe,MAAX9T,GACA,EAAOoM,WAAW,0BAA2B,EAAA3M,OAAA,6BAAqC,CAC9E4M,UAAW,eAAewB,KAAKC,UAAUgG,QAG1C9T,KAGfkV,UAAUC,EAAqBC,GAC3B,OAAOjO,EAAUtH,UAAM,OAAQ,GAAQ,kBAC7BA,KAAKwQ,aACX8E,QAA4BA,EAE5B,IAAItU,GAAe,IACnB,MAAMkT,EAAS,CACXqB,sBAAuBA,GAE3B,IAAI,IAAA9Q,aAAY6Q,EAAqB,IACjCpB,EAAOnT,UAAYuU,OAGnB,IACIpB,EAAO5T,eAAiBN,KAAKmU,aAAamB,IACtC,IAAA7Q,aAAYyP,EAAO5T,YACnBU,EAAc+E,SAASmO,EAAO5T,SAASkE,UAAU,GAAI,KAG7D,MAAOW,GACH,EAAOT,mBAAmB,kCAAmC,sBAAuB4Q,GAG5F,OAAO,IAAAzF,OAAK,IAAMvI,EAAUtH,UAAM,OAAQ,GAAQ,YAC9C,MAAMgD,QAAchD,KAAKsQ,QAAQ,WAAY4D,GAE7C,GAAa,MAATlR,EAIA,OAAwB,MAApBkR,EAAOnT,WACuC,MAA1Cf,KAAK6O,SAAS,KAAOqF,EAAOnT,YAKb,MAAnBmT,EAAO5T,UACHU,EAAchB,KAAK6O,SAAS7L,MALrB,UAUf,EAGJ,GAAIuS,EAAqB,CACrB,IAAIvU,EAAc,KAClB,IAAK,IAAIkM,EAAI,EAAGA,EAAIlK,EAAMM,aAAasB,OAAQsI,IAAK,CAChD,MAAMrB,EAAK7I,EAAMM,aAAa4J,GAC9B,GAAsB,MAAlBrB,EAAG7K,YACH6K,EAAG3K,cAAgB,OAElB,GAAwB,MAApB2K,EAAG3K,cAAuB,CACZ,MAAfF,IACAA,QAAoBhB,KAAK8P,wBAAwB,IAAM,EAAI9P,KAAK4Q,kBAGpE,IAAI1P,EAAiBF,EAAc6K,EAAG7K,YAAe,EACjDE,GAAiB,IACjBA,EAAgB,GAEpB2K,EAAG3K,cAAgBA,GAG3B,MAAMsU,EAAexV,KAAKyL,UAAUjI,sBAAsBR,GAE1D,OADAwS,EAAalS,aAAekS,EAAalS,aAAa+C,KAAKwF,GAAO7L,KAAK0T,iBAAiB7H,KACjF2J,EAEX,OAAOxV,KAAKyL,UAAUzI,MAAMA,OAC5B,CAAEyS,SAAUzV,UAGxB0V,SAASJ,GACL,OAAQtV,KAAKqV,UAAUC,GAAqB,GAEhDlC,yBAAyBkC,GACrB,OAAQtV,KAAKqV,UAAUC,GAAqB,GAEhDnC,eAAehR,GACX,OAAOmF,EAAUtH,UAAM,OAAQ,GAAQ,kBAC7BA,KAAKwQ,aACXrO,QAAwBA,EACxB,MAAM+R,EAAS,CAAE/R,gBAAiBnC,KAAKyL,UAAUjL,KAAK2B,GAAiB,IACvE,OAAO,IAAA0N,OAAK,IAAMvI,EAAUtH,UAAM,OAAQ,GAAQ,YAC9C,MAAM2E,QAAe3E,KAAKsQ,QAAQ,iBAAkB4D,GACpD,GAAc,MAAVvP,EACA,OAA6C,MAAzC3E,KAAK6O,SAAS,KAAO1M,GACd,UAEX,EAEJ,MAAM0J,EAAK7L,KAAKyL,UAAU/H,oBAAoBiB,GAC9C,GAAsB,MAAlBkH,EAAG7K,YACH6K,EAAG3K,cAAgB,OAElB,GAAwB,MAApB2K,EAAG3K,cAAuB,CAG/B,IAAIA,SAFsBlB,KAAK8P,wBAAwB,IAAM,EAAI9P,KAAK4Q,kBAEnC/E,EAAG7K,YAAe,EACjDE,GAAiB,IACjBA,EAAgB,GAEpB2K,EAAG3K,cAAgBA,EAEvB,OAAOlB,KAAK0T,iBAAiB7H,OAC7B,CAAE4J,SAAUzV,UAGxBmR,sBAAsBhP,GAClB,OAAOmF,EAAUtH,UAAM,OAAQ,GAAQ,kBAC7BA,KAAKwQ,aACXrO,QAAwBA,EACxB,MAAM+R,EAAS,CAAE/R,gBAAiBnC,KAAKyL,UAAUjL,KAAK2B,GAAiB,IACvE,OAAO,IAAA0N,OAAK,IAAMvI,EAAUtH,UAAM,OAAQ,GAAQ,YAC9C,MAAM2E,QAAe3E,KAAKsQ,QAAQ,wBAAyB4D,GAC3D,GAAc,MAAVvP,EACA,OAA6C,MAAzC3E,KAAK6O,SAAS,KAAO1M,GACd,UAEX,EAGJ,GAAwB,MAApBwC,EAAO5D,UACP,OAEJ,MAAMwB,EAAUvC,KAAKyL,UAAUlJ,QAAQoC,GACvC,GAA2B,MAAvBpC,EAAQvB,YACRuB,EAAQrB,cAAgB,OAEvB,GAA6B,MAAzBqB,EAAQrB,cAAuB,CAGpC,IAAIA,SAFsBlB,KAAK8P,wBAAwB,IAAM,EAAI9P,KAAK4Q,kBAEnCrO,EAAQvB,YAAe,EACtDE,GAAiB,IACjBA,EAAgB,GAEpBqB,EAAQrB,cAAgBA,EAE5B,OAAOqB,MACP,CAAEkT,SAAUzV,UAGxBoR,QAAQzN,GACJ,OAAO2D,EAAUtH,UAAM,OAAQ,GAAQ,kBAC7BA,KAAKwQ,aACX,MAAM0D,QAAe,IAAA7D,mBAAkB,CAAE1M,OAAQ3D,KAAKkV,WAAWvR,KAC3Df,QAAa5C,KAAKsQ,QAAQ,UAAW4D,GAM3C,OALAtR,EAAKkE,SAASO,IACS,MAAfA,EAAIrD,UACJqD,EAAIrD,SAAU,MAGfnE,EAAUwC,QAAQrC,KAAKyL,UAAU1H,UAAU3D,KAAKJ,KAAKyL,WAArD5L,CAAiE+C,MAGhF+S,gBACI,OAAOrO,EAAUtH,UAAM,OAAQ,GAAQ,YAEnC,aADMA,KAAKwQ,aACJxQ,KAAKsQ,QAAQ,gBAAiB,OAG7C6D,aAAa7T,GACT,OAAOgH,EAAUtH,UAAM,OAAQ,GAAQ,YAEnC,GAA0B,kBAD1BM,QAAiBA,IACqBA,EAAW,EAAG,CAC5CA,EAAW,GACX,EAAOoE,mBAAmB,mBAAoB,WAAYpE,GAE9D,IAAIU,QAAoBhB,KAAK8P,wBAAwB,IAAM,EAAI9P,KAAK4Q,iBAKpE,OAJA5P,GAAeV,EACXU,EAAc,IACdA,EAAc,GAEXhB,KAAKyL,UAAUnL,SAASU,GAEnC,OAAOhB,KAAKyL,UAAUnL,SAASA,MAGvCsV,YAAYrK,GACR,OAAOjE,EAAUtH,UAAM,OAAQ,GAAQ,YACnC,IACI,MAAMG,QAAgBH,KAAK6V,aAAatK,GACxC,OAAe,MAAXpL,EACO,KAEJ,IAAIkL,EAASrL,KAAMG,EAASoL,GAEvC,MAAOpG,GACH,OAAIA,EAAM8G,KAAS,EAAArM,OAAA,sBACR,SAMvBiW,aAAatK,GACT,OAAOjE,EAAUtH,UAAM,OAAQ,GAAQ,YAEnC,MAAM0O,QAAgB1O,KAAKwQ,aAEtB9B,EAAQoH,YACT,EAAOvJ,WAAW,+BAAgC,EAAA3M,OAAA,6BAAqC,CAAE4M,UAAW,MAAOkC,QAASA,EAAQnD,OAGhI,MAAM3K,EAAc,CAChBY,GAAIkN,EAAQoH,WACZvV,KAAO,cAAe,EAAAwL,EAAA,IAASR,GAAM/G,UAAU,IAEnD,IACI,OAAOxE,KAAKyL,UAAU3G,kBAAkB9E,KAAKgM,KAAKpL,IAEtD,MAAOuE,GACH,GAAIA,EAAM8G,OAAS,EAAArM,OAAA,sBACf,OAAO,KAEX,MAAMuF,MAIlBiQ,YAAY7J,GACR,OAAOjE,EAAUtH,UAAM,OAAQ,GAAQ,YACnCuL,QAAaA,EAEb,IACI,OAAO5D,QAAQC,QAAQ5H,KAAKyL,UAAUtL,QAAQoL,IAElD,MAAOpG,GAEH,IAAI,IAAAV,aAAY8G,GACZ,MAAMpG,EAGQ,kBAAX,GACP,EAAOT,mBAAmB,mBAAoB,OAAQ6G,GAG1D,MAAMwK,QAAiB/V,KAAK4V,YAAYrK,GACxC,OAAKwK,QAGQA,EAASlR,aAFX,QAKnBmR,cAAc7V,GACV,OAAOmH,EAAUtH,UAAM,OAAQ,GAAQ,YACnCG,QAAgBA,EAEhB,MAAM8V,GADN9V,EAAUH,KAAKyL,UAAUtL,QAAQA,IACLqE,UAAU,GAAGH,cAAgB,gBACnD6R,QAAwBlW,KAAK6V,aAAaI,GAChD,IAAKC,EACD,OAAO,KAGX,IAAIzJ,GAAQ,IAAAC,gBAAe1M,KAAKgM,KAAK,CACjCxK,GAAI0U,EACJ3V,KAAO,cAAe,EAAAwL,EAAA,IAASkK,GAAazR,UAAU,MAG1D,GAAIiI,EAAM7H,OAAS,KAAO,UAAe6H,EAAMhE,MAAM,EAAG,KAAK8K,GAAG,IAC5D,OAAO,KAIX,GAFA9G,EAAQA,EAAMhE,MAAM,IAEhBgE,EAAM7H,OAAS,GACf,OAAO,KAGX,MAAMA,EAAS,UAAe6H,EAAMhE,MAAM,EAAG,KAAKrE,WAGlD,GAFAqI,EAAQA,EAAMhE,MAAM,IAEhB7D,EAAS6H,EAAM7H,OACf,OAAO,KAEX,MAAM2G,GAAO,QAAakB,EAAMhE,MAAM,EAAG7D,IAGzC,aADmB5E,KAAKoV,YAAY7J,KACxBpL,EACD,KAEJoL,KAGfuB,UAAUqJ,GACN,OAAO7O,EAAUtH,UAAM,OAAQ,GAAQ,YACnC,IAAI+V,EAAW,KACf,IAAI,IAAAtR,aAAY0R,GAAgB,CAE5B,MAAMhW,EAAUH,KAAKyL,UAAUtL,QAAQgW,GACjCF,EAAc9V,EAAQqE,UAAU,GAAGH,cAAgB,gBACnD6R,QAAwBlW,KAAK6V,aAAaI,GAChD,IAAKC,EACD,OAAO,KAEXH,EAAW,IAAI1K,EAASrL,KAAMkW,EAAiB,IAAK/V,QAIpD4V,QAAiB/V,KAAK4V,YAAYO,GAEtC,MAAMnJ,QAAe+I,EAASjJ,YAC9B,OAAc,MAAVE,EACO,KAEJA,EAAOI,OAGtBkD,QAAQyD,EAAQG,GACZ,OAAO,EAAO3H,WAAWwH,EAAS,mBAAoB,EAAAnU,OAAA,uBAA+B,CAAE4M,UAAWuH,IAEtGqC,YAAYpM,GACRhK,KAAKuR,QAAWvR,KAAK4O,QAAQjL,QAAQsE,GAAMA,EAAEkC,aAAYvF,OAAS,EAEtEyR,WAAWrM,GACPhK,KAAKuR,QAAWvR,KAAK4O,QAAQjL,QAAQsE,GAAMA,EAAEkC,aAAYvF,OAAS,EAEtE0R,kBAAkBpN,EAAWW,EAAUC,GACnC,MAAME,EAAQ,IAAIL,EAAMV,EAAYC,GAAYW,EAAUC,GAG1D,OAFA9J,KAAK4O,QAAQ7H,KAAKiD,GAClBhK,KAAKoW,YAAYpM,GACVhK,KAEX2S,GAAGzJ,EAAWW,GACV,OAAO7J,KAAKsW,kBAAkBpN,EAAWW,GAAU,GAEvDC,KAAKZ,EAAWW,GACZ,OAAO7J,KAAKsW,kBAAkBpN,EAAWW,GAAU,GAEvDyF,KAAKpG,KAAcqN,GACf,IAAI5R,GAAS,EACT6R,EAAU,GACVC,EAAWxN,EAAYC,GAgB3B,OAfAlJ,KAAK4O,QAAU5O,KAAK4O,QAAQjL,QAAQqG,GAC5BA,EAAMJ,MAAQ6M,IAGlBhN,YAAW,KACPO,EAAMH,SAASxB,MAAMrI,KAAMuW,KAC5B,GACH5R,GAAS,GACLqF,EAAMF,OACN0M,EAAQzP,KAAKiD,IACN,MAIfwM,EAAQ1P,SAASkD,IAAYhK,KAAKqW,WAAWrM,MACtCrF,EAEX+R,cAAcxN,GACV,IAAKA,EACD,OAAOlJ,KAAK4O,QAAQhK,OAExB,IAAI6R,EAAWxN,EAAYC,GAC3B,OAAOlJ,KAAK4O,QAAQjL,QAAQqG,GAChBA,EAAMJ,MAAQ6M,IACvB7R,OAEP+R,UAAUzN,GACN,GAAiB,MAAbA,EACA,OAAOlJ,KAAK4O,QAAQvI,KAAK2D,GAAUA,EAAMH,WAE7C,IAAI4M,EAAWxN,EAAYC,GAC3B,OAAOlJ,KAAK4O,QACPjL,QAAQqG,GAAWA,EAAMJ,MAAQ6M,IACjCpQ,KAAK2D,GAAUA,EAAMH,WAE9B+M,IAAI1N,EAAWW,GACX,GAAgB,MAAZA,EACA,OAAO7J,KAAK6W,mBAAmB3N,GAEnC,MAAMsN,EAAU,GAChB,IAAIM,GAAQ,EACRL,EAAWxN,EAAYC,GAa3B,OAZAlJ,KAAK4O,QAAU5O,KAAK4O,QAAQjL,QAAQqG,GAC5BA,EAAMJ,MAAQ6M,GAAYzM,EAAMH,UAAYA,MAG5CiN,IAGJA,GAAQ,EACRN,EAAQzP,KAAKiD,IACN,MAEXwM,EAAQ1P,SAASkD,IAAYhK,KAAKqW,WAAWrM,MACtChK,KAEX6W,mBAAmB3N,GACf,IAAIsN,EAAU,GACd,GAAiB,MAAbtN,EACAsN,EAAUxW,KAAK4O,QACf5O,KAAK4O,QAAU,OAEd,CACD,MAAM6H,EAAWxN,EAAYC,GAC7BlJ,KAAK4O,QAAU5O,KAAK4O,QAAQjL,QAAQqG,GAC5BA,EAAMJ,MAAQ6M,IAGlBD,EAAQzP,KAAKiD,IACN,KAIf,OADAwM,EAAQ1P,SAASkD,IAAYhK,KAAKqW,WAAWrM,MACtChK,M,0BClqDX,EAAwC,SAAUuH,EAASC,EAAYC,EAAGC,GAE1E,OAAO,IAAKD,IAAMA,EAAIE,WAAU,SAAUC,EAASC,GAC/C,SAASC,EAAUrG,GAAS,IAAMsG,EAAKL,EAAUM,KAAKvG,IAAW,MAAOwG,GAAKJ,EAAOI,IACpF,SAASC,EAASzG,GAAS,IAAMsG,EAAKL,EAAiB,MAAEjG,IAAW,MAAOwG,GAAKJ,EAAOI,IACvF,SAASF,EAAKpD,GAJlB,IAAelD,EAIakD,EAAOwD,KAAOP,EAAQjD,EAAOlD,QAJ1CA,EAIyDkD,EAAOlD,MAJhDA,aAAiBgG,EAAIhG,EAAQ,IAAIgG,GAAE,SAAUG,GAAWA,EAAQnG,OAIT2G,KAAKN,EAAWI,GAClGH,GAAML,EAAYA,EAAUW,MAAMd,EAASC,GAAc,KAAKQ,YAatE,MAAM,EAAS,IAAI,EAAApI,OAAOF,GAEpBqX,EAAW,CAAC,OAAQ,eAC1B,SAASC,EAAWjD,EAAQ5O,EAAO+O,GAG/B,GAAe,SAAXH,GAAqB5O,EAAM8G,OAAS,EAAArM,OAAA,oBAA4B,CAChE,MAAMqI,EAAI9C,EAAMA,MAChB,GAAI8C,GAAKA,EAAEgP,QAAQtK,MAAM,cAAe,IAAAlI,aAAYwD,EAAE1H,MAClD,OAAO0H,EAAE1H,KAEb,EAAOgM,WAAW,wCAAyC,EAAA3M,OAAA,sBAA8B,CACrFuF,MAAAA,EAAO5E,KAAM,OAGrB,IAAI0W,EAAU9R,EAAM8R,QAChB9R,EAAM8G,OAAS,EAAArM,OAAA,qBAA8BuF,EAAMA,OAA0C,kBAAzBA,EAAMA,MAAa,QACvF8R,EAAU9R,EAAMA,MAAM8R,QAEO,kBAAhB9R,EAAU,KACvB8R,EAAU9R,EAAM+R,KAEqB,kBAAxB/R,EAAkB,eAC/B8R,EAAU9R,EAAMgS,cAEpBF,GAAWA,GAAW,IAAI5S,cAC1B,MAAMzD,EAAcsT,EAAOtT,aAAesT,EAAOW,kBA8BjD,MA5BIoC,EAAQtK,MAAM,kDACd,EAAOJ,WAAW,oDAAqD,EAAA3M,OAAA,0BAAkC,CACrGuF,MAAAA,EAAO4O,OAAAA,EAAQnT,YAAAA,IAInBqW,EAAQtK,MAAM,kBACd,EAAOJ,WAAW,8BAA+B,EAAA3M,OAAA,qBAA6B,CAC1EuF,MAAAA,EAAO4O,OAAAA,EAAQnT,YAAAA,IAInBqW,EAAQtK,MAAM,wCACd,EAAOJ,WAAW,0BAA2B,EAAA3M,OAAA,+BAAuC,CAChFuF,MAAAA,EAAO4O,OAAAA,EAAQnT,YAAAA,IAInBqW,EAAQtK,MAAM,0BACd,EAAOJ,WAAW,gDAAiD,EAAA3M,OAAA,6BAAqC,CACpGuF,MAAAA,EAAO4O,OAAAA,EAAQnT,YAAAA,IAGnBmW,EAAS5N,QAAQ4K,IAAW,GAAKkD,EAAQtK,MAAM,iFAC/C,EAAOJ,WAAW,4EAA6E,EAAA3M,OAAA,+BAAuC,CAClIuF,MAAAA,EAAO4O,OAAAA,EAAQnT,YAAAA,IAGjBuE,EAEV,SAASwO,EAAMvB,GACX,OAAO,IAAIzK,SAAQ,SAAUC,GACzB6B,WAAW7B,EAASwK,MAG5B,SAASgF,EAAUC,GACf,GAAIA,EAAQlS,MAAO,CAEf,MAAMA,EAAQ,IAAIb,MAAM+S,EAAQlS,MAAM8R,SAGtC,MAFA9R,EAAM8G,KAAOoL,EAAQlS,MAAM8G,KAC3B9G,EAAM5E,KAAO8W,EAAQlS,MAAM5E,KACrB4E,EAEV,OAAOkS,EAAQ1S,OAEnB,SAAS2S,GAAa7V,GAClB,OAAIA,EACOA,EAAM4C,cAEV5C,EAEX,MAAM8V,GAAoB,GACnB,MAAMC,WAAsB,EAAAC,OAC/B3X,YAAY4X,EAAkBpM,EAAUqM,GAGpC,GAFA,EAAO5X,oBAAqByX,IAC5B7I,QACI+I,IAAqBH,GACrB,MAAM,IAAIjT,MAAM,+EAEpB,IAAAyF,gBAAe/J,KAAM,WAAYsL,GACX,MAAlBqM,IACAA,EAAiB,GAEW,kBAArB,IACP,IAAA5N,gBAAe/J,KAAM,WAAYA,KAAKsL,SAASG,UAAUtL,QAAQwX,KACjE,IAAA5N,gBAAe/J,KAAM,SAAU,OAEE,kBAArB,IACZ,IAAA+J,gBAAe/J,KAAM,SAAU2X,IAC/B,IAAA5N,gBAAe/J,KAAM,WAAY,OAGjC,EAAO0E,mBAAmB,2BAA4B,iBAAkBiT,GAGhFC,QAAQtM,GACJ,OAAO,EAAOiB,WAAW,0CAA2C,EAAA3M,OAAA,6BAAqC,CACrG4M,UAAW,YAGnBqL,mBACI,OAAO,IAAIC,GAAuBP,GAAmBvX,KAAKsL,SAAUtL,KAAK+X,UAAY/X,KAAKgY,QAE9FnT,aACI,OAAI7E,KAAK+X,SACEpQ,QAAQC,QAAQ5H,KAAK+X,UAEzB/X,KAAKsL,SAAS2M,KAAK,eAAgB,IAAI7P,MAAM8P,IAC5CA,EAAStT,QAAU5E,KAAKgY,QACxB,EAAOzL,WAAW,oBAAsBvM,KAAKgY,OAAQ,EAAApY,OAAA,6BAAqC,CACtF4M,UAAW,eAGZxM,KAAKsL,SAASG,UAAUtL,QAAQ+X,EAASlY,KAAKgY,YAG7DG,yBAAyBvX,GACrBA,GAAc,IAAA6C,aAAY7C,GAC1B,MAAMwX,EAAcpY,KAAK6E,aAAauD,MAAMjI,IACpCA,IACAA,EAAUA,EAAQkE,eAEflE,KAKX,GAA4B,MAAxBS,EAAYW,SAAkB,CAC9B,MAAM8W,GAAW,IAAA5U,aAAY7C,GAC7ByX,EAASlX,KAAOiX,EAChBxX,EAAYW,SAAWvB,KAAKsL,SAAS6J,YAAYkD,GAcrD,OAZsB,MAAlBzX,EAAYY,KACZZ,EAAYY,GAAKmG,QAAQC,QAAQhH,EAAYY,IAAI4G,MAAM5G,GAAO,EAAUxB,UAAM,OAAQ,GAAQ,YAC1F,GAAU,MAANwB,EACA,OAAO,KAEX,MAAMrB,QAAgBH,KAAKsL,SAAS8J,YAAY5T,GAIhD,OAHe,MAAXrB,GACA,EAAOuE,mBAAmB,qCAAsC,QAASlD,GAEtErB,SAGR,IAAAkQ,mBAAkB,CACrBxE,IAAI,IAAAwE,mBAAkBzP,GACtB0X,OAAQF,IACThQ,MAAK,EAAGyD,GAAAA,EAAIyM,OAAAA,MACI,MAAXzM,EAAG1K,KACC0K,EAAG1K,KAAKkD,gBAAkBiU,GAC1B,EAAO5T,mBAAmB,wBAAyB,cAAe9D,GAItEiL,EAAG1K,KAAOmX,EAEd,MAAMxD,EAAQ9U,KAAKsL,SAASxL,YAAYyY,mBAAmB1M,EAAI,CAAE1K,MAAM,IACvE,OAAOnB,KAAKsL,SAAS2M,KAAK,sBAAuB,CAACnD,IAAQ1M,MAAM5H,GACrDA,IACP2E,GACO6R,EAAW,kBAAmB7R,EAAO2P,QAIxD0D,gBAAgB5X,GACZ,OAAO,EAAO2L,WAAW,sCAAuC,EAAA3M,OAAA,6BAAqC,CACjG4M,UAAW,oBAGnBoI,gBAAgBhU,GACZ,OAAO,EAAUZ,UAAM,OAAQ,GAAQ,YAEnC,MAAMgB,QAAoBhB,KAAKsL,SAASwE,wBAAwB,IAAM,EAAI9P,KAAKsL,SAASsF,iBAElFpQ,QAAaR,KAAKmY,yBAAyBvX,GACjD,IAII,aAAa,IAAAiP,OAAK,IAAM,EAAU7P,UAAM,OAAQ,GAAQ,YACpD,MAAM6L,QAAW7L,KAAKsL,SAAS6H,eAAe3S,GAC9C,GAAW,OAAPqL,EAGJ,OAAO7L,KAAKsL,SAASoI,iBAAiB7H,EAAIrL,EAAMQ,OAChD,CAAEyU,SAAUzV,KAAKsL,WAEzB,MAAOnG,GAEH,MADAA,EAAMhD,gBAAkB3B,EAClB2E,MAIlBsT,YAAYxB,GACR,OAAO,EAAUjX,UAAM,OAAQ,GAAQ,YACnC,MAAMO,EAA8B,kBAAd,GAA0B,QAAY0W,GAAWA,EACjE9W,QAAgBH,KAAK6E,aAC3B,aAAa7E,KAAKsL,SAAS2M,KAAK,gBAAiB,EAAC,IAAA3J,SAAQ/N,GAAOJ,EAAQkE,mBAGjFqU,mBAAmBzB,GACf,OAAO,EAAUjX,UAAM,OAAQ,GAAQ,YACnC,MAAMO,EAA8B,kBAAd,GAA0B,QAAY0W,GAAWA,EACjE9W,QAAgBH,KAAK6E,aAE3B,aAAa7E,KAAKsL,SAAS2M,KAAK,WAAY,CAAC9X,EAAQkE,eAAe,IAAAiK,SAAQ/N,QAGpFoY,eAAeC,EAAQC,EAAOpX,GAC1B,OAAO,EAAUzB,UAAM,OAAQ,GAAQ,YAEnC,MAAM8Y,QAAkB,iBAA+BF,EAAQC,EAAOpX,GAAQ8J,GACnEvL,KAAKsL,SAAS8J,YAAY7J,KAE/BpL,QAAgBH,KAAK6E,aAC3B,aAAa7E,KAAKsL,SAAS2M,KAAK,uBAAwB,CACpD9X,EAAQkE,cACR2J,KAAKC,UAAU,eAA6B6K,EAAUF,OAAQC,EAAOC,EAAUrX,aAI3FsX,OAAOC,GACH,OAAO,EAAUhZ,UAAM,OAAQ,GAAQ,YACnC,MAAMsL,EAAWtL,KAAKsL,SAChBnL,QAAgBH,KAAK6E,aAC3B,OAAOyG,EAAS2M,KAAK,yBAA0B,CAAC9X,EAAQkE,cAAe2U,EAAU,WAI7F,MAAMlB,WAA+BN,GACjC5C,gBAAgBhU,GACZ,OAAOZ,KAAKmY,yBAAyBvX,GAAawH,MAAM5H,IAC7C,CACHA,KAAMA,EACNkB,MAAO,KACPH,SAAU,KACVH,SAAU,KACVb,KAAM,KACNkB,MAAO,KACPoE,QAAS,KACT3E,cAAe,EACfC,KAAM,KACNuT,KAAOxT,GAA2BlB,KAAKsL,SAAS6G,mBAAmB3R,EAAMU,QAKzF,MAAM+X,GAAyB,CAC3BpT,SAAS,EAAMtF,MAAM,EAAMgB,UAAU,EAAMH,UAAU,EAAMM,OAAO,EAAMF,IAAI,EAAMC,OAAO,EACzFd,MAAM,EAAME,YAAY,EACxBS,cAAc,EAAMD,sBAAsB,GAEvC,MAAM6X,WAAwBzK,EACjC3O,YAAYsN,EAAKsB,GACb,EAAO3O,oBAAqBmZ,IAC5B,IAAIC,EAAiBzK,EAEC,MAAlByK,IACAA,EAAiB,IAAIxR,SAAQ,CAACC,EAASC,KACnC4B,YAAW,KACPzJ,KAAKgP,gBAAgB5G,MAAMsG,IACvB9G,EAAQ8G,MACRvJ,IACA0C,EAAO1C,QAEZ,OAGXwJ,MAAMwK,GAED/L,IACDA,GAAM,IAAAiC,WAAUrP,KAAKF,YAAa,aAA5B,IAEW,kBAAV,GACP,IAAAiK,gBAAe/J,KAAM,aAAc6I,OAAOuQ,OAAO,CAC7ChM,IAAKA,MAIT,IAAArD,gBAAe/J,KAAM,aAAc6I,OAAOuQ,QAAO,IAAA3V,aAAY2J,KAEjEpN,KAAKqZ,QAAU,GAEfC,aAIA,OAH4B,MAAxBtZ,KAAKuZ,kBACLvZ,KAAKuZ,gBAAkB,IAEpBvZ,KAAKuZ,gBAEhBjT,oBACI,MAAO,wBAEX0I,gBAQI,OAPKhP,KAAKsZ,OAAsB,gBAC5BtZ,KAAKsZ,OAAsB,cAAItZ,KAAKwZ,yBAEpC/P,YAAW,KACPzJ,KAAKsZ,OAAsB,cAAI,OAChC,IAEAtZ,KAAKsZ,OAAsB,cAEtCE,yBACI,OAAO,EAAUxZ,UAAM,OAAQ,GAAQ,kBAC7B2T,EAAM,GACZ,IAAI9N,EAAU,KACd,IACIA,QAAgB7F,KAAKiY,KAAK,cAAe,IAE7C,MAAO9S,GACH,IACIU,QAAgB7F,KAAKiY,KAAK,cAAe,IAE7C,MAAO9S,KAEX,GAAe,MAAXU,EAAiB,CACjB,MAAM2K,GAAa,IAAAnB,WAAUrP,KAAKF,YAAa,cAC/C,IACI,OAAO0Q,EAAW,UAAe3K,GAASzB,YAE9C,MAAOe,GACH,OAAO,EAAOoH,WAAW,2BAA4B,EAAA3M,OAAA,qBAA6B,CAC9EiG,QAASA,EACTmE,MAAO,iBACPyP,YAAatU,KAIzB,OAAO,EAAOoH,WAAW,2BAA4B,EAAA3M,OAAA,qBAA6B,CAC9EoK,MAAO,iBAInB0P,UAAU/B,GACN,OAAO,IAAIH,GAAcD,GAAmBvX,KAAM2X,GAEtDgC,mBAAmBhC,GACf,OAAO3X,KAAK0Z,UAAU/B,GAAgBE,mBAE1C+B,eACI,OAAO5Z,KAAKiY,KAAK,eAAgB,IAAI7P,MAAM8P,GAChCA,EAAS7R,KAAKwT,GAAM7Z,KAAKyL,UAAUtL,QAAQ0Z,OAG1D5B,KAAKlE,EAAQG,GACT,MAAM4F,EAAU,CACZ/F,OAAQA,EACRG,OAAQA,EACR6F,GAAK/Z,KAAKqZ,UACVW,QAAS,OAEbha,KAAKsP,KAAK,QAAS,CACf2K,OAAQ,UACRH,SAAS,IAAAI,UAASJ,GAClBxO,SAAUtL,OAId,MAAMma,EAAS,CAAC,cAAe,mBAAmBhR,QAAQ4K,IAAW,EACrE,GAAIoG,GAASna,KAAKsZ,OAAOvF,GACrB,OAAO/T,KAAKsZ,OAAOvF,GAEvB,MAAMpP,GAAS,IAAAmJ,WAAU9N,KAAKoa,WAAYpM,KAAKC,UAAU6L,GAAU1C,GAAWhP,MAAMzD,IAChF3E,KAAKsP,KAAK,QAAS,CACf2K,OAAQ,WACRH,QAASA,EACTO,SAAU1V,EACV2G,SAAUtL,OAEP2E,KACPQ,IAOA,MANAnF,KAAKsP,KAAK,QAAS,CACf2K,OAAQ,WACR9U,MAAOA,EACP2U,QAASA,EACTxO,SAAUtL,OAERmF,KASV,OANIgV,IACAna,KAAKsZ,OAAOvF,GAAUpP,EACtB8E,YAAW,KACPzJ,KAAKsZ,OAAOvF,GAAU,OACvB,IAEApP,EAEX2V,eAAevG,EAAQG,GACnB,OAAQH,GACJ,IAAK,iBACD,MAAO,CAAC,kBAAmB,IAC/B,IAAK,cACD,MAAO,CAAC,eAAgB,IAC5B,IAAK,aACD,MAAO,CAAC,iBAAkB,CAACuD,GAAapD,EAAO/T,SAAU+T,EAAO5T,WACpE,IAAK,sBACD,MAAO,CAAC,0BAA2B,CAACgX,GAAapD,EAAO/T,SAAU+T,EAAO5T,WAC7E,IAAK,UACD,MAAO,CAAC,cAAe,CAACgX,GAAapD,EAAO/T,SAAU+T,EAAO5T,WACjE,IAAK,eACD,MAAO,CAAC,mBAAoB,CAACgX,GAAapD,EAAO/T,SAAU+T,EAAOI,SAAUJ,EAAO5T,WACvF,IAAK,kBACD,MAAO,CAAC,yBAA0B,CAAC4T,EAAOW,oBAC9C,IAAK,WACD,OAAIX,EAAO5T,SACA,CAAC,uBAAwB,CAAC4T,EAAO5T,WAAY4T,EAAOqB,sBAEtDrB,EAAOnT,UACL,CAAC,qBAAsB,CAACmT,EAAOnT,YAAamT,EAAOqB,sBAEvD,KACX,IAAK,iBACD,MAAO,CAAC,2BAA4B,CAACrB,EAAO/R,kBAChD,IAAK,wBACD,MAAO,CAAC,4BAA6B,CAAC+R,EAAO/R,kBACjD,IAAK,OAED,MAAO,CAAC,WAAY,EADO,IAAAkN,WAAUrP,KAAKF,YAAa,qBAClCyY,CAAmBrE,EAAOtT,YAAa,CAAEO,MAAM,IAAS+S,EAAO5T,WAExF,IAAK,cAED,MAAO,CAAC,kBAAmB,EADA,IAAA+O,WAAUrP,KAAKF,YAAa,qBAC3ByY,CAAmBrE,EAAOtT,YAAa,CAAEO,MAAM,MAE/E,IAAK,UAID,OAHI+S,EAAOvQ,QAAmC,MAAzBuQ,EAAOvQ,OAAOxD,UAC/B+T,EAAOvQ,OAAOxD,QAAUmX,GAAapD,EAAOvQ,OAAOxD,UAEhD,CAAC,cAAe,CAAC+T,EAAOvQ,SAIvC,OAAO,KAEX2M,QAAQyD,EAAQG,GACZ,OAAO,EAAUlU,UAAM,OAAQ,GAAQ,YAGnC,GAAe,SAAX+T,GAAgC,gBAAXA,EAA0B,CAC/C,MAAMlI,EAAKqI,EAAOtT,YAClB,GAAIiL,GAAiB,MAAXA,EAAGlL,MAAgB,UAAekL,EAAGlL,MAAMgF,UAE1B,MAAnBkG,EAAGvK,cAAmD,MAA3BuK,EAAGxK,qBAA8B,CAC5D,MAAMkZ,QAAgBva,KAAKwa,aACC,MAAxBD,EAAQjZ,cAAwD,MAAhCiZ,EAAQlZ,wBAExC6S,GAAS,IAAAzQ,aAAYyQ,IACdtT,aAAc,IAAA6C,aAAYoI,UAC1BqI,EAAOtT,YAAYD,OAK1C,MAAM4V,EAAOvW,KAAKsa,eAAevG,EAAQG,GAC7B,MAARqC,GACA,EAAOhK,WAAWwH,EAAS,mBAAoB,EAAAnU,OAAA,uBAA+B,CAAE4M,UAAWuH,IAE/F,IACI,aAAa/T,KAAKiY,KAAK1B,EAAK,GAAIA,EAAK,IAEzC,MAAOpR,GACH,OAAO6R,EAAWjD,EAAQ5O,EAAO+O,OAI7CkC,YAAYpM,GACU,YAAdA,EAAMJ,KACN5J,KAAKya,gBAET9L,MAAMyH,YAAYpM,GAEtByQ,gBACI,GAA2B,MAAvBza,KAAK0a,eACL,OAEJ,MAAMC,EAAO3a,KACP4a,EAAgB5a,KAAKiY,KAAK,kCAAmC,IACnEjY,KAAK0a,eAAiBE,EACtBA,EAAcxS,MAAK,SAAUyS,GA8BzB,OA7BA,SAAShL,IACL8K,EAAK1C,KAAK,uBAAwB,CAAC4C,IAAWzS,MAAK,SAAU0S,GACzD,GAAIH,EAAKD,gBAAkBE,EACvB,OAAO,KAEX,IAAIG,EAAMpT,QAAQC,UAWlB,OAVAkT,EAAOhU,SAAQ,SAAUtG,GAErBma,EAAK9L,SAAS,KAAOrO,EAAK6D,eAAiB,UAC3C0W,EAAMA,EAAI3S,MAAK,WACX,OAAOuS,EAAKxH,eAAe3S,GAAM4H,MAAK,SAAUyD,GAE5C,OADA8O,EAAKrL,KAAK,UAAWzD,GACd,cAIZkP,EAAI3S,MAAK,WACZ,OAAOuL,EAAM,WAElBvL,MAAK,WACJ,GAAIuS,EAAKD,gBAAkBE,EAK3B,OADAnR,YAAW,WAAcoG,MAAW,GAC7B,KAJH8K,EAAK1C,KAAK,sBAAuB,CAAC4C,OAKvC3L,OAAO/J,QAEd0K,GACOgL,KACR3L,OAAO/J,QAEdkR,WAAWrM,GACW,YAAdA,EAAMJ,KAAuD,IAAlC5J,KAAK0W,cAAc,aAC9C1W,KAAK0a,eAAiB,MAE1B/L,MAAM0H,WAAWrM,GAWrB1D,0BAA0B1F,EAAaoa,GAEnC,MAAMC,GAAU,IAAAxX,aAAYwV,IAC5B,GAAI+B,EACA,IAAK,MAAMxU,KAAOwU,EACVA,EAAWxU,KACXyU,EAAQzU,IAAO,IAI3B,IAAA0U,iBAAgBta,EAAaqa,GAC7B,MAAMtW,EAAS,GAqBf,MAnBA,CAAC,WAAY,WAAY,OAAQ,eAAgB,uBAAwB,QAAS,SAASmC,SAAQ,SAAUN,GACzG,GAAwB,MAApB5F,EAAY4F,GACZ,OAEJ,MAAM/E,GAAQ,IAAAwD,UAASrE,EAAY4F,IACvB,aAARA,IACAA,EAAM,OAEV7B,EAAO6B,GAAO/E,KAElB,CAAC,OAAQ,KAAM,QAAQqF,SAAQ,SAAUN,GACb,MAApB5F,EAAY4F,KAGhB7B,EAAO6B,IAAO,IAAA8H,SAAQ1N,EAAY4F,QAElC5F,EAAYC,aACZ8D,EAAmB,YAAI,IAAAR,eAAcvD,EAAYC,aAE9C8D,GCvkBf,IAAIwW,GAAK,KACT,IAEI,GADAA,GAAKC,UACK,MAAND,GACA,MAAM,IAAI7W,MAAM,iBAGxB,MAAOa,IACH,MAAMxF,EAAS,IAAI,EAAAC,OAAOF,GAC1Byb,GAAK,WACDxb,EAAO4M,WAAW,+CAAgD,EAAA3M,OAAA,6BAAqC,CACnG4M,UAAW,qBCbvB,IAAI,GAAwC,SAAUjF,EAASC,EAAYC,EAAGC,GAE1E,OAAO,IAAKD,IAAMA,EAAIE,WAAU,SAAUC,EAASC,GAC/C,SAASC,EAAUrG,GAAS,IAAMsG,EAAKL,EAAUM,KAAKvG,IAAW,MAAOwG,GAAKJ,EAAOI,IACpF,SAASC,EAASzG,GAAS,IAAMsG,EAAKL,EAAiB,MAAEjG,IAAW,MAAOwG,GAAKJ,EAAOI,IACvF,SAASF,EAAKpD,GAJlB,IAAelD,EAIakD,EAAOwD,KAAOP,EAAQjD,EAAOlD,QAJ1CA,EAIyDkD,EAAOlD,MAJhDA,aAAiBgG,EAAIhG,EAAQ,IAAIgG,GAAE,SAAUG,GAAWA,EAAQnG,OAIT2G,KAAKN,EAAWI,GAClGH,GAAML,EAAYA,EAAUW,MAAMd,EAASC,GAAc,KAAKQ,YAStE,MAAM,GAAS,IAAI,EAAApI,OAAOF,GAe1B,IAAI2b,GAAS,EAGN,MAAMC,WAA0BpC,GACnCpZ,YAAYsN,EAAKsB,GAEG,QAAZA,GACA,GAAOnC,WAAW,uDAAwD,EAAA3M,OAAA,6BAAqC,CAC3G4M,UAAW,gBAGnBmC,MAAMvB,EAAKsB,GACX1O,KAAKyP,kBAAoB,EACzBzP,KAAKub,UAAW,GAChB,IAAAxR,gBAAe/J,KAAM,aAAc,IAAI,GAAUA,KAAKoa,WAAWhN,OACjE,IAAArD,gBAAe/J,KAAM,YAAa,KAClC,IAAA+J,gBAAe/J,KAAM,QAAS,KAC9B,IAAA+J,gBAAe/J,KAAM,UAAW,KAChC,IAAA+J,gBAAe/J,KAAM,iBAAkB2O,MAAMK,iBAE7ChP,KAAKwb,WAAWC,OAAS,KACrBzb,KAAKub,UAAW,EAChB1S,OAAOC,KAAK9I,KAAK0b,WAAW5U,SAASiT,IACjC/Z,KAAKwb,WAAWvD,KAAKjY,KAAK0b,UAAU3B,GAAI1C,aAGhDrX,KAAKwb,WAAWG,UAAaC,IACzB,MAAMrb,EAAOqb,EAAarb,KACpBoE,EAASqJ,KAAK/H,MAAM1F,GAC1B,GAAiB,MAAboE,EAAOoV,GAAY,CACnB,MAAMA,EAAKzN,OAAO3H,EAAOoV,IACnBD,EAAU9Z,KAAK0b,UAAU3B,GAE/B,UADO/Z,KAAK0b,UAAU3B,QACAlW,IAAlBc,EAAOA,OACPmV,EAAQ+B,SAAS,KAAMlX,EAAOA,QAC9B3E,KAAKsP,KAAK,QAAS,CACf2K,OAAQ,WACRH,QAAS9L,KAAK/H,MAAM6T,EAAQzC,SAC5BgD,SAAU1V,EAAOA,OACjB2G,SAAUtL,WAGb,CACD,IAAImF,EAAQ,KACRR,EAAOQ,OACPA,EAAQ,IAAIb,MAAMK,EAAOQ,MAAM8R,SAAW,kBAC1C,IAAAlN,gBAAe5E,EAAO,OAAQR,EAAOQ,MAAM8G,MAAQ,OACnD,IAAAlC,gBAAe5E,EAAO,WAAY5E,IAGlC4E,EAAQ,IAAIb,MAAM,iBAEtBwV,EAAQ+B,SAAS1W,OAAOtB,GACxB7D,KAAKsP,KAAK,QAAS,CACf2K,OAAQ,WACR9U,MAAOA,EACP2U,QAAS9L,KAAK/H,MAAM6T,EAAQzC,SAC5B/L,SAAUtL,aAIjB,GAAsB,qBAAlB2E,EAAOoP,OAA+B,CAE3C,MAAM+H,EAAM9b,KAAK+b,MAAMpX,EAAOuP,OAAO8H,cACjCF,GAEAA,EAAIG,YAAYtX,EAAOuP,OAAOvP,aAIlCyC,QAAQgC,KAAK,2BAMrB,MAAM8S,EAAWrK,aAAY,KACzB7R,KAAKsP,KAAK,UACX,KACC4M,EAAStI,OACTsI,EAAStI,QAGjB5E,gBACI,OAAOhP,KAAKmc,eAEZvL,sBACA,OAAO,EAEXU,iBAAiBtQ,GACb,GAAOuL,WAAW,iDAAkD,EAAA3M,OAAA,6BAAqC,CACrG4M,UAAW,oBAGfoE,oBAAgBnP,GAChB,GAAO8K,WAAW,mDAAoD,EAAA3M,OAAA,6BAAqC,CACvG4M,UAAW,uBAGnBqD,OACI,OAAO,GAAU7P,UAAM,OAAQ,GAAQ,YACnC,OAAO,QAGXuR,YAAQ9P,GACHA,GAGL,GAAO8K,WAAW,0CAA2C,EAAA3M,OAAA,6BAAqC,CAC9F4M,UAAW,eAGnByL,KAAKlE,EAAQG,GACT,MAAMkI,EAAMf,KACZ,OAAO,IAAI1T,SAAQ,CAACC,EAASC,KAOzB,MAAMwP,EAAUrJ,KAAKC,UAAU,CAC3B8F,OAAQA,EACRG,OAAQA,EACR6F,GAAIqC,EACJpC,QAAS,QAEbha,KAAKsP,KAAK,QAAS,CACf2K,OAAQ,UACRH,QAAS9L,KAAK/H,MAAMoR,GACpB/L,SAAUtL,OAEdA,KAAK0b,UAAUpP,OAAO8P,IAAQ,CAAEP,SAjBhC,SAAkB1W,EAAOR,GACrB,OAAIQ,EACO0C,EAAO1C,GAEXyC,EAAQjD,IAauB0S,QAAAA,GACtCrX,KAAKub,UACLvb,KAAKwb,WAAWvD,KAAKZ,MAIjC/Q,oBACI,MAAO,sBAEX+V,WAAWzS,EAAK0S,EAAOL,GACnB,OAAO,GAAUjc,UAAM,OAAQ,GAAQ,YACnC,IAAIuc,EAAevc,KAAKwc,QAAQ5S,GACZ,MAAhB2S,IACAA,EAAe5U,QAAQ0J,IAAIiL,GAAOlU,MAAMkU,GAC7Btc,KAAKiY,KAAK,gBAAiBqE,KAEtCtc,KAAKwc,QAAQ5S,GAAO2S,GAExB,MAAME,QAAcF,EACpBvc,KAAK+b,MAAMU,GAAS,CAAE7S,IAAAA,EAAKqS,YAAAA,MAGnC7F,YAAYpM,GACR,OAAQA,EAAMrJ,MACV,IAAK,QACDX,KAAKqc,WAAW,QAAS,CAAC,aAAc1X,IACpC,MAAM3D,EAAc,UAAe2D,EAAOjE,QAAQ0D,WAClDpE,KAAK6O,SAAS7L,MAAQhC,EACtBhB,KAAKsP,KAAK,QAAStO,MAEvB,MACJ,IAAK,UACDhB,KAAKqc,WAAW,UAAW,CAAC,2BAA4B1X,IACpD3E,KAAKsP,KAAK,UAAW3K,MAEzB,MACJ,IAAK,SACD3E,KAAKqc,WAAWrS,EAAMJ,IAAK,CAAC,OAAQ5J,KAAKkV,WAAWlL,EAAMrG,UAAWgB,IAC3C,MAAlBA,EAAOX,UACPW,EAAOX,SAAU,GAErBhE,KAAKsP,KAAKtF,EAAMrG,OAAQ3D,KAAKyL,UAAU1H,UAAUY,OAErD,MACJ,IAAK,KAAM,CACP,MAAM+X,EAAe1S,IACjB,MAAMxJ,EAAOwJ,EAAMxJ,KACnBR,KAAKmR,sBAAsB3Q,GAAM4H,MAAM7F,IAC9BA,GAGLvC,KAAKsP,KAAK9O,EAAM+B,OAIxBma,EAAY1S,GAKZhK,KAAKqc,WAAW,KAAM,CAAC,aAAc1X,IACjC3E,KAAK4O,QAAQjL,QAAQsE,GAAkB,OAAXA,EAAEtH,OAAgBmG,QAAQ4V,MAE1D,MAGJ,IAAK,QACL,IAAK,OACL,IAAK,WACL,IAAK,UACL,IAAK,QACD,MACJ,QACItV,QAAQC,IAAI,aAAc2C,IAItCqM,WAAWrM,GACP,IAAIJ,EAAMI,EAAMJ,IAChB,GAAmB,OAAfI,EAAMrJ,KAAe,CAErB,GAAIX,KAAK4O,QAAQjL,QAAQsE,GAAkB,OAAXA,EAAEtH,OAAgBiE,OAC9C,OAEJgF,EAAM,UAEL,GAAI5J,KAAK0W,cAAc1M,EAAMA,OAE9B,OAEJ,MAAMyS,EAAQzc,KAAKwc,QAAQ5S,GACtB6S,WAGEzc,KAAKwc,QAAQ5S,GACpB6S,EAAMrU,MAAMqU,IACHzc,KAAK+b,MAAMU,YAGTzc,KAAK+b,MAAMU,GAClBzc,KAAKiY,KAAK,kBAAmB,CAACwE,SAGtCE,UACI,OAAO,GAAU3c,UAAM,OAAQ,GAAQ,YAE/BA,KAAKwb,WAAWoB,aAAe,sBACzB,IAAKjV,SAASC,IAChB5H,KAAKwb,WAAWC,OAAS,WACrB7T,GAAQ,IAEZ5H,KAAKwb,WAAWqB,QAAU,WACtBjV,GAAQ,QAMpB5H,KAAKwb,WAAWsB,MAAM,SCxRlC,IAAI,GAAwC,SAAUvV,EAASC,EAAYC,EAAGC,GAE1E,OAAO,IAAKD,IAAMA,EAAIE,WAAU,SAAUC,EAASC,GAC/C,SAASC,EAAUrG,GAAS,IAAMsG,EAAKL,EAAUM,KAAKvG,IAAW,MAAOwG,GAAKJ,EAAOI,IACpF,SAASC,EAASzG,GAAS,IAAMsG,EAAKL,EAAiB,MAAEjG,IAAW,MAAOwG,GAAKJ,EAAOI,IACvF,SAASF,EAAKpD,GAJlB,IAAelD,EAIakD,EAAOwD,KAAOP,EAAQjD,EAAOlD,QAJ1CA,EAIyDkD,EAAOlD,MAJhDA,aAAiBgG,EAAIhG,EAAQ,IAAIgG,GAAE,SAAUG,GAAWA,EAAQnG,OAIT2G,KAAKN,EAAWI,GAClGH,GAAML,EAAYA,EAAUW,MAAMd,EAASC,GAAc,KAAKQ,YAMtE,MAAM,GAAS,IAAI,EAAApI,OAAOF,GAanB,MAAMqd,WAA8B7D,GACvClK,gBACI,MAAMgO,EAASnU,OAAOoU,OAAO,KAAM,CAC/BjO,cAAe,CAAEkO,IAAK,IAAMvO,MAAMK,iBAEtC,OAAO,GAAUhP,UAAM,OAAQ,GAAQ,YACnC,IAAI0O,EAAU1O,KAAK0O,QAanB,OAZe,MAAXA,IACAA,QAAgBsO,EAAOhO,cAAchD,KAAKhM,MACrC0O,GACD,GAAOnC,WAAW,sBAAuB,EAAA3M,OAAA,qBAA6B,IAGrD,MAAjBI,KAAK2P,YAEL,IAAA5F,gBAAe/J,KAAM,WAAY0O,GACjC1O,KAAKsP,KAAK,UAAWZ,EAAS,QAG/BA,MAIZ,MAAMyO,WAA2BJ,GACpCjd,YAAY4O,EAAS0O,GACjB,GAAOC,yBAA0BF,IAEjCzO,GAAU,IAAAW,sBAAsB,aAAtB,CAAoCX,GAC9C0O,GAAS,IAAA/N,sBAAsB,YAAtB,CAAmC+N,GAE5CzO,OADmB,IAAAU,sBAAsB,SAAtB,CAAgCX,EAAS0O,GAC1C1O,GACM,kBAAb,GACP,IAAA3E,gBAAe/J,KAAM,SAAUod,GAEhB,MAAVA,GACLvU,OAAOC,KAAKsU,GAAQtW,SAASN,KACzB,IAAAuD,gBAAe/J,KAAMwG,EAAK4W,EAAO5W,OAI7CiU,gBACI,GAAOrR,KAAK,0DAEhBnC,sBACI,OAAO,EAEXyS,UAAUvZ,GACN,OAAO,GAAOoM,WAAW,wCAAyC,EAAA3M,OAAA,6BAAqC,CAAE4M,UAAW,cAExHoN,eACI,OAAOjS,QAAQC,QAAQ,IAG3BtB,iBAAiB8W,GACb,OAAOA,EAKX9W,cAAcoI,EAAS0O,GACnB,OAAO,GAAO7Q,WAAW,oDAAqD,EAAA3M,OAAA,uBAA+B,CACzG4M,UAAW,YCjFvB,MAAM,GAAS,IAAI,EAAA5M,OAAOF,GAMpB4d,GAAgB,mCACf,MAAMC,WAAiCjC,GAC1Cxb,YAAY4O,EAAS0O,GACjB,MAAM9R,EAAW,IAAIkS,GAAgB9O,EAAS0O,GAG9CzO,MAFYrD,EAAS8O,WAAWhN,IAAIpH,QAAQ,SAAU,MACjDA,QAAQ,eAAgB,mBAClBsF,EAASoD,UACpB,IAAA3E,gBAAe/J,KAAM,SAAUsL,EAAS8R,QAE5CnW,sBACI,OAAQjH,KAAKod,SAAWE,IAGzB,MAAME,WAAwBL,GACjC7W,4BAA4BoI,EAAS0O,GACjC,OAAO,IAAIG,GAAyB7O,EAAS0O,GAEjD9W,iBAAiB8W,GACb,OAAc,MAAVA,EACOE,IAEPF,GAA8B,kBAAb,GACjB,GAAO1Y,mBAAmB,iBAAkB,SAAU0Y,GAEnDA,GAEX9W,cAAcoI,EAAS0O,GACnB,IAAIK,EAAO,KACX,OAAQ/O,EAAQnD,MACZ,IAAK,YACDkS,EAAO,gCACP,MACJ,IAAK,UACDA,EAAO,gCACP,MACJ,IAAK,UACDA,EAAO,gCACP,MACJ,IAAK,SACDA,EAAO,+BACP,MACJ,IAAK,QACDA,EAAO,8BACP,MACJ,IAAK,QACDA,EAAO,oCACP,MACJ,IAAK,WACDA,EAAO,mCACP,MACJ,QACI,GAAO/Y,mBAAmB,sBAAuB,UAAWgZ,UAAU,IAE9E,MAAO,CACHC,WAAW,EACXvQ,IAAM,WAAkBqQ,EAAOL,EAC/BQ,iBAAkB,CAACC,EAASzQ,KACpBgQ,IAAWE,IACXnW,IAEGQ,QAAQC,SAAQ,KAInCX,sBACI,OAAQjH,KAAKod,SAAWE,IC5EhC,IAAI,GAAwC,SAAU/V,EAASC,EAAYC,EAAGC,GAE1E,OAAO,IAAKD,IAAMA,EAAIE,WAAU,SAAUC,EAASC,GAC/C,SAASC,EAAUrG,GAAS,IAAMsG,EAAKL,EAAUM,KAAKvG,IAAW,MAAOwG,GAAKJ,EAAOI,IACpF,SAASC,EAASzG,GAAS,IAAMsG,EAAKL,EAAiB,MAAEjG,IAAW,MAAOwG,GAAKJ,EAAOI,IACvF,SAASF,EAAKpD,GAJlB,IAAelD,EAIakD,EAAOwD,KAAOP,EAAQjD,EAAOlD,QAJ1CA,EAIyDkD,EAAOlD,MAJhDA,aAAiBgG,EAAIhG,EAAQ,IAAIgG,GAAE,SAAUG,GAAWA,EAAQnG,OAIT2G,KAAKN,EAAWI,GAClGH,GAAML,EAAYA,EAAUW,MAAMd,EAASC,GAAc,KAAKQ,YAMtE,MAAM,GAAS,IAAI,EAAApI,OAAOF,GACnB,MAAMoe,WAA2BX,GACpC7W,iBAAiB8W,GAIb,OAHc,MAAVA,GACA,GAAO1Y,mBAAmB,sCAAuC,SAAU0Y,GAExE,KAEX9W,cAAcoI,EAAS0O,GACnB,IAAIK,EAAO,KACX,GACS,cADD/O,EAAQnD,KAERkS,EAAO,mCAGP,GAAO/Y,mBAAmB,sBAAuB,UAAWgZ,UAAU,IAE9E,OAAOD,EAEXnN,QAAQyD,EAAQG,GACZ,MAAM8I,EAASnU,OAAOoU,OAAO,KAAM,CAC/B3M,QAAS,CAAE4M,IAAK,IAAMvO,MAAM2B,WAEhC,OAAO,GAAUtQ,UAAM,OAAQ,GAAQ,YAGnC,GAAe,mBAAX+T,EAA6B,CAE7B,aADoBiJ,EAAO1M,QAAQtE,KAAKhM,KAAM,WAAY,CAAEM,SAAU,YACzDI,OAEjB,OAAOsc,EAAO1M,QAAQtE,KAAKhM,KAAM+T,EAAQG,OC1CrD,IAAI,GAAwC,SAAU3M,EAASC,EAAYC,EAAGC,GAE1E,OAAO,IAAKD,IAAMA,EAAIE,WAAU,SAAUC,EAASC,GAC/C,SAASC,EAAUrG,GAAS,IAAMsG,EAAKL,EAAUM,KAAKvG,IAAW,MAAOwG,GAAKJ,EAAOI,IACpF,SAASC,EAASzG,GAAS,IAAMsG,EAAKL,EAAiB,MAAEjG,IAAW,MAAOwG,GAAKJ,EAAOI,IACvF,SAASF,EAAKpD,GAJlB,IAAelD,EAIakD,EAAOwD,KAAOP,EAAQjD,EAAOlD,QAJ1CA,EAIyDkD,EAAOlD,MAJhDA,aAAiBgG,EAAIhG,EAAQ,IAAIgG,GAAE,SAAUG,GAAWA,EAAQnG,OAIT2G,KAAKN,EAAWI,GAClGH,GAAML,EAAYA,EAAUW,MAAMd,EAASC,GAAc,KAAKQ,YAUtE,MAAM,GAAS,IAAI,EAAApI,OAAOF,GAG1B,SAASqe,GAAuBnd,GAC5B,MAAM+D,EAAS,GACf,IAAK,IAAI6B,KAAO5F,EAAa,CACzB,GAAwB,MAApBA,EAAY4F,GACZ,SAEJ,IAAI/E,EAAQb,EAAY4F,GACZ,SAARA,GAA4B,IAAV/E,IAQlBA,EAJA,CAAEd,MAAM,EAAMY,UAAU,EAAMH,UAAU,EAAM4c,aAAa,EAAM3c,sBAAsB,EAAMK,OAAO,EAAMD,OAAO,GAAO+E,IAChH,IAAAvB,WAAS,IAAAqJ,SAAQ7M,IAEZ,eAAR+E,EACG,KAAM,IAAArC,eAAc1C,GAAO4E,KAAK4X,GAC7B,aAAaA,EAAI9d,0BAA0B8d,EAAIC,YAAYlV,KAAK,cACxEA,KAAK,KAAO,KAGP,IAAAsF,SAAQ7M,GAEpBkD,EAAO6B,GAAO/E,GAElB,OAAOkD,EAEX,SAAS,GAAUA,GAEf,GAAqB,GAAjBA,EAAO5B,SAAmC,qBAAnB4B,EAAOsS,SAAqD,0BAAnBtS,EAAOsS,SACvE,OAAOtS,EAAOA,OAElB,GAAqB,GAAjBA,EAAO5B,QAAiC,MAAlB4B,EAAOsS,QAAiB,CAC9C,MAAM9R,EAAQ,IAAIb,MAAM,oBAKxB,MAJAa,EAAMR,OAASqJ,KAAKC,UAAUtJ,IACzBA,EAAOA,QAAU,IAAIN,cAAc8E,QAAQ,eAAiB,IAC7DhE,EAAMgZ,eAAgB,GAEpBhZ,EAEV,OAAOR,EAAOA,OAElB,SAASyZ,GAAczZ,GAEnB,GAAIA,GAA2B,GAAjBA,EAAO5B,QAAiC,SAAlB4B,EAAOsS,UAAuBtS,EAAOA,QAAU,IAAIN,cAAc8E,QAAQ,eAAiB,EAAG,CAC7H,MAAMhE,EAAQ,IAAIb,MAAM,sBAGxB,MAFAa,EAAMR,OAASqJ,KAAKC,UAAUtJ,GAC9BQ,EAAMgZ,eAAgB,EAChBhZ,EAEV,GAAsB,OAAlBR,EAAOqV,QAAkB,CAEzB,MAAM7U,EAAQ,IAAIb,MAAM,oBAExB,MADAa,EAAMR,OAASqJ,KAAKC,UAAUtJ,GACxBQ,EAEV,GAAIR,EAAOQ,MAAO,CAEd,MAAMA,EAAQ,IAAIb,MAAMK,EAAOQ,MAAM8R,SAAW,iBAOhD,MANItS,EAAOQ,MAAM8G,OACb9G,EAAM8G,KAAOtH,EAAOQ,MAAM8G,MAE1BtH,EAAOQ,MAAM5E,OACb4E,EAAM5E,KAAOoE,EAAOQ,MAAM5E,MAExB4E,EAEV,OAAOR,EAAOA,OAGlB,SAAS0Z,GAAY/d,GACjB,GAAiB,YAAbA,EACA,MAAM,IAAIgE,MAAM,yBAEpB,MAAiB,WAAbhE,EACOA,EAEJyF,SAASzF,EAASkE,UAAU,GAAI,IAE3C,MAAM,GAAgB,qCACtB,SAAS,GAAWuP,EAAQ5O,EAAOvE,GAG/B,GAAe,SAAXmT,GAAqB5O,EAAM8G,OAAS,EAAArM,OAAA,oBAA4B,CAChE,MAAMqI,EAAI9C,EAAMA,MAEhB,GAAI8C,IAAMA,EAAEgP,QAAQtK,MAAM,cAAgB1E,EAAEgP,QAAQtK,MAAM,wBAAyB,CAE/E,IAAIpM,EAAO0H,EAAE1H,KAIb,GAHIA,IACAA,EAAO,KAAOA,EAAKyF,QAAQ,SAAU,MAErC,IAAAvB,aAAYlE,GACZ,OAAOA,EAEX,GAAOgM,WAAW,wCAAyC,EAAA3M,OAAA,sBAA8B,CACrFuF,MAAAA,EAAO5E,KAAM,QAKzB,IAAI0W,EAAU9R,EAAM8R,QAoCpB,MAnCI9R,EAAM8G,OAAS,EAAArM,OAAA,sBACXuF,EAAMA,OAA0C,kBAAzBA,EAAMA,MAAa,QAC1C8R,EAAU9R,EAAMA,MAAM8R,QAEO,kBAAhB9R,EAAU,KACvB8R,EAAU9R,EAAM+R,KAEqB,kBAAxB/R,EAAkB,eAC/B8R,EAAU9R,EAAMgS,eAGxBF,GAAWA,GAAW,IAAI5S,cAEtB4S,EAAQtK,MAAM,uBACd,GAAOJ,WAAW,oDAAqD,EAAA3M,OAAA,0BAAkC,CACrGuF,MAAAA,EAAO4O,OAAAA,EAAQnT,YAAAA,IAInBqW,EAAQtK,MAAM,8EACd,GAAOJ,WAAW,8BAA+B,EAAA3M,OAAA,qBAA6B,CAC1EuF,MAAAA,EAAO4O,OAAAA,EAAQnT,YAAAA,IAInBqW,EAAQtK,MAAM,wCACd,GAAOJ,WAAW,0BAA2B,EAAA3M,OAAA,+BAAuC,CAChFuF,MAAAA,EAAO4O,OAAAA,EAAQnT,YAAAA,IAGnBqW,EAAQtK,MAAM,4DACd,GAAOJ,WAAW,4EAA6E,EAAA3M,OAAA,+BAAuC,CAClIuF,MAAAA,EAAO4O,OAAAA,EAAQnT,YAAAA,IAGjBuE,EAEH,MAAMmZ,WAA0B7P,EACnC3O,YAAY4O,EAAS0O,GACjB,GAAOrd,oBAAqBue,IAC5B3P,MAAMD,IACN,IAAA3E,gBAAe/J,KAAM,UAAWA,KAAKue,eACrC,IAAAxU,gBAAe/J,KAAM,SAAUod,GAAU,IAE7CmB,aACI,OAAQve,KAAK0O,QAAU1O,KAAK0O,QAAQnD,KAAO,WACvC,IAAK,YACD,MAAO,2BACX,IAAK,UACD,MAAO,mCACX,IAAK,UACD,MAAO,mCACX,IAAK,QACD,MAAO,iCACX,IAAK,SACD,MAAO,kCAGf,OAAO,GAAO7G,mBAAmB,sBAAuB,UAAW6G,MAEvEiT,OAAOC,EAAQvK,GACX,MAAMwK,EAAQ7V,OAAOC,KAAKoL,GAAQyK,QAAO,CAACC,EAAOpY,KAC7C,MAAM/E,EAAQyS,EAAO1N,GAIrB,OAHa,MAAT/E,IACAmd,GAAS,IAAIpY,KAAO/E,KAEjBmd,IACR,IACGxB,EAAWpd,KAAW,OAAI,WAAWA,KAAKod,SAAW,GAC3D,MAAO,GAAGpd,KAAK6e,sBAAsBJ,IAASC,IAAQtB,IAE1D0B,aACI,MAAO,GAAG9e,KAAK6e,cAEnBE,YAAYN,EAAQvK,GAGhB,OAFAA,EAAOuK,OAASA,EAChBvK,EAAO8K,OAAShf,KAAKod,OACdlJ,EAEX+K,MAAMR,EAAQvK,EAAQgL,GAClB,OAAO,GAAUlf,UAAM,OAAQ,GAAQ,YACnC,MAAMoN,EAAO8R,EAAOlf,KAAK8e,aAAe9e,KAAKwe,OAAOC,EAAQvK,GACtDmD,EAAW6H,EAAOlf,KAAK+e,YAAYN,EAAQvK,GAAU,KACrDiL,EAAuB,UAAXV,EAAsBL,GAAgB,GACxDpe,KAAKsP,KAAK,QAAS,CACf2K,OAAQ,UACRH,QAAS1M,EACT9B,SAAUtL,OAEd,MAAMoa,EAAa,CACfhN,IAAKA,EACLgS,qBAAsB,IACtBxB,iBAAkB,CAACC,EAASzQ,KACpBpN,KAAKiH,uBACLE,IAEGQ,QAAQC,SAAQ,KAG/B,IAAIyX,EAAa,KACbhI,IACA+C,EAAWkF,QAAU,CAAE,eAAgB,oDACvCD,EAAaxW,OAAOC,KAAKuO,GAAShR,KAAKG,GAC5B,GAAGA,KAAO6Q,EAAQ7Q,OAC1BwC,KAAK,MAEZ,MAAMrE,QAAe,IAAAmJ,WAAUsM,EAAYiF,EAAYF,GAAYf,IAOnE,OANApe,KAAKsP,KAAK,QAAS,CACf2K,OAAQ,WACRH,QAAS1M,EACTiN,UAAU,IAAAH,UAASvV,GACnB2G,SAAUtL,OAEP2E,KAGfqK,gBACI,OAAO,GAAUhP,UAAM,OAAQ,GAAQ,YACnC,OAAOA,KAAK0O,WAGpB4B,QAAQyD,EAAQG,GACZ,MAAM8I,EAASnU,OAAOoU,OAAO,KAAM,CAC/B3M,QAAS,CAAE4M,IAAK,IAAMvO,MAAM2B,WAEhC,OAAO,GAAUtQ,UAAM,OAAQ,GAAQ,YACnC,OAAQ+T,GACJ,IAAK,iBACD,OAAO/T,KAAKif,MAAM,QAAS,CAAEhF,OAAQ,oBACzC,IAAK,cACD,OAAOja,KAAKif,MAAM,QAAS,CAAEhF,OAAQ,iBACzC,IAAK,aAED,OAAOja,KAAKif,MAAM,UAAW,CACzBhF,OAAQ,UACR9Z,QAAS+T,EAAO/T,QAChByJ,IAAKsK,EAAO5T,WAEpB,IAAK,sBACD,OAAON,KAAKif,MAAM,QAAS,CACvBhF,OAAQ,0BACR9Z,QAAS+T,EAAO/T,QAChByJ,IAAKsK,EAAO5T,WAEpB,IAAK,UACD,OAAON,KAAKif,MAAM,QAAS,CACvBhF,OAAQ,cACR9Z,QAAS+T,EAAO/T,QAChByJ,IAAKsK,EAAO5T,WAEpB,IAAK,eACD,OAAON,KAAKif,MAAM,QAAS,CACvBhF,OAAQ,mBACR9Z,QAAS+T,EAAO/T,QAChBmU,SAAUJ,EAAOI,SACjB1K,IAAKsK,EAAO5T,WAEpB,IAAK,kBACD,OAAON,KAAKif,MAAM,QAAS,CACvBhF,OAAQ,yBACRxZ,IAAKyT,EAAOW,oBACb,GAAM3F,OAAO/J,GACL,GAAW,kBAAmBA,EAAO+O,EAAOW,qBAE3D,IAAK,WACD,GAAIX,EAAO5T,SACP,OAAON,KAAKif,MAAM,QAAS,CACvBhF,OAAQ,uBACRrQ,IAAKsK,EAAO5T,SACZ2D,QAAUiQ,EAAOqB,oBAAsB,OAAS,UAGxD,MAAM,IAAIjR,MAAM,yCACpB,IAAK,iBACD,OAAOtE,KAAKif,MAAM,QAAS,CACvBhF,OAAQ,2BACRsF,OAAQrL,EAAO/R,kBAEvB,IAAK,wBACD,OAAOnC,KAAKif,MAAM,QAAS,CACvBhF,OAAQ,4BACRsF,OAAQrL,EAAO/R,kBAEvB,IAAK,OAAQ,CACT,GAAwB,WAApB+R,EAAO5T,SACP,MAAM,IAAIgE,MAAM,wDAEpB,MAAMkb,EAAWzB,GAAuB7J,EAAOtT,aAC/C4e,EAASf,OAAS,QAClBe,EAASvF,OAAS,WAClB,IACI,aAAaja,KAAKif,MAAM,QAASO,GAAU,GAE/C,MAAOra,IACH,OAAO,GAAW,OAAQA,GAAO+O,EAAOtT,cAGhD,IAAK,cAAe,CAChB,MAAM4e,EAAWzB,GAAuB7J,EAAOtT,aAC/C4e,EAASf,OAAS,QAClBe,EAASvF,OAAS,kBAClB,IACI,aAAaja,KAAKif,MAAM,QAASO,GAAU,GAE/C,MAAOra,IACH,OAAO,GAAW,cAAeA,GAAO+O,EAAOtT,cAGvD,IAAK,UAAW,CACZ,MAAM2V,EAAO,CAAE0D,OAAQ,WAWvB,GAVI/F,EAAOvQ,OAAOC,YACd2S,EAAK3S,UAAYya,GAAYnK,EAAOvQ,OAAOC,YAE3CsQ,EAAOvQ,OAAOG,UACdyS,EAAKzS,QAAUua,GAAYnK,EAAOvQ,OAAOG,UAEzCoQ,EAAOvQ,OAAOxD,UACdoW,EAAKpW,QAAU+T,EAAOvQ,OAAOxD,SAG7B+T,EAAOvQ,OAAOvB,QAAU8R,EAAOvQ,OAAOvB,OAAOwC,OAAS,IAClDsP,EAAOvQ,OAAOvB,OAAOwC,OAAS,GAC9B,GAAO2H,WAAW,0BAA2B,EAAA3M,OAAA,6BAAqC,CAAEwC,OAAQ8R,EAAOvQ,OAAOvB,SAE1E,IAAhC8R,EAAOvQ,OAAOvB,OAAOwC,QAAc,CACnC,MAAM6a,EAASvL,EAAOvQ,OAAOvB,OAAO,GACZ,kBAAb,GAA2C,KAAlBqd,EAAO7a,QACvC,GAAO2H,WAAW,2BAA4B,EAAA3M,OAAA,6BAAqC,CAAE6f,OAAQA,IAEjGlJ,EAAKkJ,OAASA,EAGtB,MAAM7c,QAAa5C,KAAKif,MAAM,OAAQ1I,GAEtC,IAAImJ,EAAS,GAEb,IAAK,IAAIxS,EAAI,EAAGA,EAAItK,EAAKgC,OAAQsI,IAAK,CAClC,MAAM7F,EAAMzE,EAAKsK,GACjB,GAAqB,MAAjB7F,EAAItG,UAAR,CAGA,GAA+B,MAA3B2e,EAAOrY,EAAIrG,aAAsB,CACjC,MAAMgC,QAAchD,KAAK0V,SAASrO,EAAIrG,aAClCgC,IACA0c,EAAOrY,EAAIrG,aAAegC,EAAMxC,MAGxC6G,EAAItG,UAAY2e,EAAOrY,EAAIrG,cAE/B,OAAO4B,EAEX,IAAK,gBACD,MAA0B,cAAtB5C,KAAK0O,QAAQnD,KACN,EAEJoU,kBAAkB3f,KAAKif,MAAM,QAAS,CAAEhF,OAAQ,cAAe2F,QAI9E,OAAO5C,EAAO1M,QAAQtE,KAAKhM,KAAM+T,EAAQG,MAOjD2L,WAAW5L,EAAenB,EAAYgN,GAClC,OAAO,GAAU9f,UAAM,OAAQ,GAAQ,YACnC,MAAMkU,EAAS,CACX+F,OAAQ,SACR9Z,cAAgBH,KAAKoV,YAAYnB,GACjC8L,WAA4B,MAAdjN,EAAsB,EAAIA,EACxCkN,SAAwB,MAAZF,EAAoB,SAAWA,EAC3C/W,KAAM,OAGV,aADqB/I,KAAKif,MAAM,UAAW/K,IAC7B7N,KAAKwF,IACf,CAAC,kBAAmB,MAAM/E,SAAQ,SAAUN,GACzB,IAAXqF,EAAGrF,WACIqF,EAAGrF,MAGA,MAAdqF,EAAG9J,SAAyC,MAAtB8J,EAAGrJ,kBACzBqJ,EAAG9J,QAAU8J,EAAGrJ,iBAEpB,MAAMyd,EAAOjgB,KAAKyL,UAAU/H,oBAAoBmI,GAIhD,OAHIA,EAAGqU,YACHD,EAAK/c,UAAY6C,SAAS8F,EAAGqU,YAE1BD,QAInBhZ,sBACI,OAAQjH,KAAKod,SAAW,I,gBC9Z5B,GAAwC,SAAU7V,EAASC,EAAYC,EAAGC,GAE1E,OAAO,IAAKD,IAAMA,EAAIE,WAAU,SAAUC,EAASC,GAC/C,SAASC,EAAUrG,GAAS,IAAMsG,EAAKL,EAAUM,KAAKvG,IAAW,MAAOwG,GAAKJ,EAAOI,IACpF,SAASC,EAASzG,GAAS,IAAMsG,EAAKL,EAAiB,MAAEjG,IAAW,MAAOwG,GAAKJ,EAAOI,IACvF,SAASF,EAAKpD,GAJlB,IAAelD,EAIakD,EAAOwD,KAAOP,EAAQjD,EAAOlD,QAJ1CA,EAIyDkD,EAAOlD,MAJhDA,aAAiBgG,EAAIhG,EAAQ,IAAIgG,GAAE,SAAUG,GAAWA,EAAQnG,OAIT2G,KAAKN,EAAWI,GAClGH,GAAML,EAAYA,EAAUW,MAAMd,EAASC,GAAc,KAAKQ,YAatE,MAAM,GAAS,IAAI,EAAApI,OAAOF,GAC1B,SAASuS,KAAQ,OAAO,IAAK3I,MAAQD,UAGrC,SAAS8W,GAAcC,GACnB,IAAIzb,EAAS,KACb,IAAK,IAAIuI,EAAI,EAAGA,EAAIkT,EAASxb,OAAQsI,IAAK,CACtC,MAAMwB,EAAU0R,EAASlT,GAEzB,GAAe,MAAXwB,EACA,OAAO,KAEP/J,EAEMA,EAAO4G,OAASmD,EAAQnD,MAAQ5G,EAAOkB,UAAY6I,EAAQ7I,UAC3DlB,EAAOmR,aAAepH,EAAQoH,YAAqC,MAArBnR,EAAOmR,YAA4C,MAAtBpH,EAAQoH,aACrF,GAAOpR,mBAAmB,oBAAqB,WAAY0b,GAI/Dzb,EAAS+J,EAGjB,OAAO/J,EAEX,SAAS0b,GAAOpL,EAAQqL,GACpBrL,EAASA,EAAOxM,QAAQM,OACxB,MAAMwX,EAAS1P,KAAK2P,MAAMvL,EAAOrQ,OAAS,GAE1C,GAAIqQ,EAAOrQ,OAAS,EAChB,OAAOqQ,EAAOsL,GAGlB,MAAM1G,EAAI5E,EAAOsL,EAAS,GAAIE,EAAIxL,EAAOsL,GACzC,OAAgB,MAAZD,GAAoBzP,KAAKC,IAAI+I,EAAI4G,GAAKH,EAC/B,MAEHzG,EAAI4G,GAAK,EAErB,SAASC,GAAUjf,GACf,GAAc,OAAVA,EACA,MAAO,OAEN,GAAuB,kBAAZ,GAA2C,mBAAZ,EAC3C,OAAOuM,KAAKC,UAAUxM,GAErB,GAAuB,kBAAZ,EACZ,OAAOA,EAEN,GAAI,iBAAsBA,GAC3B,OAAOA,EAAMkM,WAEZ,GAAIxH,MAAMC,QAAQ3E,GACnB,OAAOuM,KAAKC,UAAUxM,EAAM4E,KAAK6G,GAAMwT,GAAUxT,MAEhD,GAAuB,kBAAZ,EAAsB,CAClC,MAAMpE,EAAOD,OAAOC,KAAKrH,GAEzB,OADAqH,EAAKC,OACE,IAAMD,EAAKzC,KAAKG,IACnB,IAAI1E,EAAIL,EAAM+E,GAOd,OALI1E,EADe,oBAAR,EACH,aAGA4e,GAAU5e,GAEXkM,KAAKC,UAAUzH,GAAO,IAAM1E,KACpCkH,KAAK,KAAO,IAEnB,MAAM,IAAI1E,MAAM,8BAAgC,GAGpD,IAAIqc,GAAU,EAEd,SAAS,GAAMnX,GACX,IAAIoX,EAAS,KACTjN,EAAQ,KACRkN,EAAU,IAAKlZ,SAASC,IACxBgZ,EAAS,WACDjN,IACAE,aAAaF,GACbA,EAAQ,MAEZ/L,KAEJ+L,EAAQlK,WAAWmX,EAAQpX,MAS/B,MAAO,CAAEoX,OAAAA,EAAQE,WAHjB,WACI,OAAOD,GAEkBnM,KAPfjC,IACVoO,EAAUA,EAAQzY,KAAKqK,GAChBoO,IAOf,MAAME,GAAgB,CAClB,EAAAnhB,OAAA,sBACA,EAAAA,OAAA,0BACA,EAAAA,OAAA,qBACA,EAAAA,OAAA,+BACA,EAAAA,OAAA,gCAEEohB,GAAoB,CACtB,UACA,OACA,YACA,iBACA,SACA,eAGJ,SAASC,GAAkBC,EAAQjP,GAC/B,MAAMtN,EAAS,CACXwc,OAAQD,EAAOC,QAiBnB,OAfAtY,OAAOuY,eAAezc,EAAQ,WAAY,CAAEuY,IAAK,IAAMgE,EAAO5V,WAC1D4V,EAAOG,QACP1c,EAAO0c,MAAQH,EAAOG,OAEtBpP,IACAtN,EAAO6E,SAAYyI,EAAMiP,EAAOG,OAEhCH,EAAO/Y,OACH+Y,EAAO/b,MACPR,EAAOQ,MAAQ+b,EAAO/b,MAGtBR,EAAOA,OAASuc,EAAOvc,QAAU,MAGlCA,EAyBX,SAAS2c,GAAehW,EAAUyI,EAAQG,GACtC,IAAIqN,EAAYb,GAChB,OAAQ3M,GACJ,IAAK,iBAKD,OAAO,SAAUyN,GACb,MAAMvM,EAASuM,EAAQnb,KAAKob,GAAMA,EAAE9c,SAEpC,IAAI3D,EAAcqf,GAAOmB,EAAQnb,KAAKob,GAAMA,EAAE9c,SAAS,GACvD,GAAmB,MAAf3D,EAYJ,OATAA,EAAc6P,KAAK6Q,KAAK1gB,GAEpBiU,EAAO9L,QAAQnI,EAAc,IAAM,GACnCA,IAGAA,GAAesK,EAASqW,sBACxBrW,EAASqW,oBAAsB3gB,GAE5BsK,EAASqW,qBAExB,IAAK,cAID,OAAO,SAAUH,GACb,MAAMvM,EAASuM,EAAQnb,KAAKob,GAAMA,EAAE9c,SAEpC,OADAsQ,EAAOlM,OACAkM,EAAOpE,KAAK2P,MAAMvL,EAAOrQ,OAAS,KAEjD,IAAK,gBAGD,OAAO,SAAU4c,GACb,OAAOnB,GAAOmB,EAAQnb,KAAKob,GAAMA,EAAE9c,WAG3C,IAAK,aACL,IAAK,sBACL,IAAK,UACL,IAAK,eACL,IAAK,OACL,IAAK,cACL,IAAK,UACD,MAEJ,IAAK,iBACL,IAAK,wBACD4c,EAAY,SAAU1V,GAClB,OAAU,MAANA,EACO,OAEXA,GAAK,IAAApI,aAAYoI,IACd3K,eAAiB,EACbwf,GAAU7U,KAErB,MAEJ,IAAK,WAGG0V,EADArN,EAAOqB,oBACK,SAAUvS,GAClB,OAAa,MAATA,EACO,OAEXA,GAAQ,IAAAS,aAAYT,IACdM,aAAeN,EAAMM,aAAa+C,KAAKwF,KACzCA,GAAK,IAAApI,aAAYoI,IACd3K,eAAiB,EACb2K,KAEJ6U,GAAU1d,KAIT,SAAUA,GAClB,OAAa,MAATA,EACO,KAEJ0d,GAAU1d,IAGzB,MACJ,QACI,MAAM,IAAIsB,MAAM,mBAAqByP,GAI7C,OApHJ,SAAyBwN,EAAWK,GAChC,OAAO,SAAUJ,GAEb,MAAMK,EAAQ,GACdL,EAAQ1a,SAAS2a,IACb,MAAMhgB,EAAQ8f,EAAUE,EAAE9c,QACrBkd,EAAMpgB,KACPogB,EAAMpgB,GAAS,CAAEqgB,MAAO,EAAGnd,OAAQ8c,EAAE9c,SAEzCkd,EAAMpgB,GAAOqgB,WAGjB,MAAMhZ,EAAOD,OAAOC,KAAK+Y,GACzB,IAAK,IAAI3U,EAAI,EAAGA,EAAIpE,EAAKlE,OAAQsI,IAAK,CAClC,MAAMzH,EAAQoc,EAAM/Y,EAAKoE,IACzB,GAAIzH,EAAMqc,OAASF,EACf,OAAOnc,EAAMd,SAoGlBod,CAAgBR,EAAWjW,EAASsW,QAI/C,SAASI,GAAYd,EAAQlgB,GACzB,OAAO,GAAUhB,UAAM,OAAQ,GAAQ,YACnC,MAAMsL,EAAY4V,EAAe,SACjC,OAA6B,MAAxB5V,EAAStK,aAAuBsK,EAAStK,aAAeA,IAAiC,IAAjBA,EAClEsK,GAEJ,IAAAuE,OAAK,IACD,IAAIlI,SAAQ,CAACC,EAASC,KACzB4B,YAAW,WAEP,OAAI6B,EAAStK,aAAeA,EACjB4G,EAAQ0D,GAGf4V,EAAO1N,UACA5L,EAAQ,MAGZA,OAAQ/D,KAChB,OAER,CAAE4R,SAAUnK,OAGvB,SAAS2W,GAAUf,EAAQgB,EAAoBnO,EAAQG,GACnD,OAAO,GAAUlU,UAAM,OAAQ,GAAQ,YACnC,IAAIsL,EAAW4V,EAAO5V,SACtB,OAAQyI,GACJ,IAAK,iBACL,IAAK,cACD,OAAOzI,EAASyI,KACpB,IAAK,gBACD,GAAIzI,EAASqK,cACT,OAAOrK,EAASqK,gBAEpB,MACJ,IAAK,aACL,IAAK,sBACL,IAAK,UAID,OAHIzB,EAAO5T,WAAY,IAAAmE,aAAYyP,EAAO5T,YACtCgL,QAAiB0W,GAAYd,EAAQgB,IAElC5W,EAASyI,GAAQG,EAAO/T,QAAS+T,EAAO5T,UAAY,UAC/D,IAAK,eAID,OAHI4T,EAAO5T,WAAY,IAAAmE,aAAYyP,EAAO5T,YACtCgL,QAAiB0W,GAAYd,EAAQgB,IAElC5W,EAAS+I,aAAaH,EAAO/T,QAAS+T,EAAOI,SAAUJ,EAAO5T,UAAY,UACrF,IAAK,WAID,OAHI4T,EAAO5T,WAAY,IAAAmE,aAAYyP,EAAO5T,YACtCgL,QAAiB0W,GAAYd,EAAQgB,IAElC5W,EAAU4I,EAAOqB,oBAAsB,2BAA6B,YAAarB,EAAO5T,UAAY4T,EAAOnT,WACtH,IAAK,OACL,IAAK,cAID,OAHImT,EAAO5T,WAAY,IAAAmE,aAAYyP,EAAO5T,YACtCgL,QAAiB0W,GAAYd,EAAQgB,IAElC5W,EAASyI,GAAQG,EAAOtT,aACnC,IAAK,iBACL,IAAK,wBACD,OAAO0K,EAASyI,GAAQG,EAAO/R,iBACnC,IAAK,UAAW,CACZ,IAAIwB,EAASuQ,EAAOvQ,OAIpB,OAHKA,EAAOC,YAAa,IAAAa,aAAYd,EAAOC,YAAgBD,EAAOG,UAAW,IAAAW,aAAYd,EAAOG,YAC7FwH,QAAiB0W,GAAYd,EAAQgB,IAElC5W,EAAS8F,QAAQzN,IAGhC,OAAO,GAAO4I,WAAW,uBAAwB,EAAA3M,OAAA,qBAA6B,CAC1EmU,OAAQA,EACRG,OAAQA,OAIb,MAAMiO,WAAyB1T,EAClC3O,YAAYsiB,EAAWR,GACnB,GAAO7hB,oBAAqBoiB,IACH,IAArBC,EAAUxd,QACV,GAAOF,mBAAmB,oBAAqB,YAAa0d,GAEhE,MAAMC,EAAkBD,EAAU/b,KAAI,CAACic,EAAkBC,KACrD,GAAI,gBAAoBD,GAAmB,CACvC,MAAME,EAAevb,EAAoBqb,GAAoB,IAAO,IAC9DG,EAAW,EACjB,OAAO5Z,OAAOuQ,OAAO,CAAE9N,SAAUgX,EAAkBnB,OAAQ,EAAGqB,aAAAA,EAAcC,SAAAA,IAEhF,MAAMvB,GAAS,IAAAzd,aAAY6e,GACJ,MAAnBpB,EAAOuB,WACPvB,EAAOuB,SAAW,GAEK,MAAvBvB,EAAOsB,eACPtB,EAAOsB,aAAevb,EAAoBqb,GAAoB,IAAO,KAEpD,MAAjBpB,EAAOC,SACPD,EAAOC,OAAS,GAEpB,MAAMA,EAASD,EAAOC,OAItB,OAHIA,EAAS,GAAKA,EAAS,KAAOA,EAAS,IACvC,GAAOzc,mBAAmB,8CAA+C,aAAa6d,YAAiBpB,GAEpGtY,OAAOuQ,OAAO8H,MAEnBwB,EAAQL,EAAgB1D,QAAO,CAACC,EAAO6C,IAAO7C,EAAQ6C,EAAEN,QAAS,GACzD,MAAVS,EACAA,EAASc,EAAQ,EAEZd,EAASc,GACd,GAAOhe,mBAAmB,oDAAqD,SAAUkd,GAG7F,IAAIzI,EAAiBgH,GAAckC,EAAgBhc,KAAKob,GAAOA,EAAU,SAAE/S,WAErD,MAAlByK,IACAA,EAAiB,IAAIxR,SAAQ,CAACC,EAASC,KACnC4B,YAAW,KACPzJ,KAAKgP,gBAAgB5G,KAAKR,EAASC,KACpC,OAGX8G,MAAMwK,IAEN,IAAApP,gBAAe/J,KAAM,kBAAmB6I,OAAOuQ,OAAOiJ,KACtD,IAAAtY,gBAAe/J,KAAM,SAAU4hB,GAC/B5hB,KAAK2hB,qBAAuB,EAEhC3S,gBACI,OAAO,GAAUhP,UAAM,OAAQ,GAAQ,YAEnC,OAAOmgB,SADgBxY,QAAQ0J,IAAIrR,KAAKqiB,gBAAgBhc,KAAKob,GAAMA,EAAEnW,SAASkF,oBAItFF,QAAQyD,EAAQG,GACZ,OAAO,GAAUlU,UAAM,OAAQ,GAAQ,YAEnC,GAAe,oBAAX+T,EAA8B,CAC9B,MAAM4O,QAAgBhb,QAAQ0J,IAAIrR,KAAKqiB,gBAAgBhc,KAAKob,GACjDA,EAAEnW,SAASsJ,gBAAgBV,EAAOW,mBAAmBzM,MAAMzD,GACvDA,EAAOnE,OACd2E,GACOA,OAIf,IAAK,IAAI+H,EAAI,EAAGA,EAAIyV,EAAQ/d,OAAQsI,IAAK,CACrC,MAAMvI,EAASge,EAAQzV,GACvB,GAAwB,kBAAb,EACP,OAAOvI,EAIf,MAAMge,EAAQ,IAIgB,IAA9B3iB,KAAK2hB,qBAAyC,mBAAX5N,UAC7B/T,KAAKkS,kBAEf,MAAM+J,EAAcqF,GAAethB,KAAM+T,EAAQG,GAG3CsN,GAAU,EAAAoB,GAAA,GAAS5iB,KAAKqiB,gBAAgBhc,IAAI,EAAA5C,cAClD+d,EAAQzY,MAAK,CAAC8Q,EAAG4G,IAAO5G,EAAE4I,SAAWhC,EAAEgC,WACvC,MAAMP,EAAqBliB,KAAK2hB,oBAChC,IAAIzU,EAAI,EACJ2V,GAAQ,EACZ,OAAa,CACT,MAAMC,EAAK7Q,KAEX,IAAI8Q,EAAiBvB,EAAQ7d,QAAQ8d,GAAOA,EAAEvQ,QAAY4R,EAAKrB,EAAEJ,MAASI,EAAEe,eACvE7D,QAAO,CAACC,EAAO6C,IAAO7C,EAAQ6C,EAAEN,QAAS,GAE9C,KAAO4B,EAAiB/iB,KAAK4hB,QAAU1U,EAAIsU,EAAQ5c,QAAQ,CACvD,MAAMsc,EAASM,EAAQtU,KACjBkP,EAAMuE,KACZO,EAAOG,MAAQpP,KACfiP,EAAO8B,QAAU,GAAM9B,EAAOsB,cAC9BtB,EAAO8B,QAAQtO,MAAK,KAAQwM,EAAO8B,QAAU,QAC7C9B,EAAOhQ,OAAS+Q,GAAUf,EAAQgB,EAAoBnO,EAAQG,GAAQ9L,MAAMzD,IACxEuc,EAAO/Y,MAAO,EACd+Y,EAAOvc,OAASA,EACZ3E,KAAK0W,cAAc,UACnB1W,KAAKsP,KAAK,QAAS,CACf2K,OAAQ,UACRmC,IAAKA,EACL6G,QAAShC,GAAkBC,EAAQjP,MACnC6H,QAAS,CAAE/F,OAAQA,EAAQG,QAAQ,IAAAgG,UAAShG,IAC5C5I,SAAUtL,UAGlBmF,IACA+b,EAAO/Y,MAAO,EACd+Y,EAAO/b,MAAQA,EACXnF,KAAK0W,cAAc,UACnB1W,KAAKsP,KAAK,QAAS,CACf2K,OAAQ,UACRmC,IAAKA,EACL6G,QAAShC,GAAkBC,EAAQjP,MACnC6H,QAAS,CAAE/F,OAAQA,EAAQG,QAAQ,IAAAgG,UAAShG,IAC5C5I,SAAUtL,UAIlBA,KAAK0W,cAAc,UACnB1W,KAAKsP,KAAK,QAAS,CACf2K,OAAQ,UACRmC,IAAKA,EACL6G,QAAShC,GAAkBC,EAAQ,MACnCpH,QAAS,CAAE/F,OAAQA,EAAQG,QAAQ,IAAAgG,UAAShG,IAC5C5I,SAAUtL,OAGlB+iB,GAAkB7B,EAAOC,OAG7B,MAAM+B,EAAU,GAChB1B,EAAQ1a,SAAS2a,KACTA,EAAEtZ,MAASsZ,EAAEvQ,SAGjBgS,EAAQnc,KAAK0a,EAAEvQ,QACXuQ,EAAEuB,SACFE,EAAQnc,KAAK0a,EAAEuB,QAAQlC,kBAG3BoC,EAAQte,eACF+C,QAAQwb,KAAKD,IAIvB,MAAMP,EAAUnB,EAAQ7d,QAAQ8d,GAAOA,EAAEtZ,MAAmB,MAAXsZ,EAAEtc,QACnD,GAAIwd,EAAQ/d,QAAU5E,KAAK4hB,OAAQ,CAC/B,MAAMjd,EAASsX,EAAY0G,GAC3B,QAAe9e,IAAXc,EAQA,OANA6c,EAAQ1a,SAAQ2a,IACRA,EAAEuB,SACFvB,EAAEuB,QAAQpC,SAEda,EAAEjO,WAAY,KAEX7O,EAENke,UACK,GAAM,KAAK/B,cAErB+B,GAAQ,EAGZ,MAAMO,EAAS5B,EAAQ7C,QAAO,CAACC,EAAO6C,KAClC,IAAKA,EAAEtZ,MAAmB,MAAXsZ,EAAEtc,MACb,OAAOyZ,EAEX,MAAM3S,EAAQwV,EAAO,MAAExV,KAOvB,OANI8U,GAAc5X,QAAQ8C,IAAS,IAC1B2S,EAAM3S,KACP2S,EAAM3S,GAAQ,CAAE9G,MAAOsc,EAAEtc,MAAOgc,OAAQ,IAE5CvC,EAAM3S,GAAMkV,QAAUM,EAAEN,QAErBvC,IACR,IAwBH,GAvBA/V,OAAOC,KAAKsa,GAAQtc,SAASuc,IACzB,MAAMxB,EAAQuB,EAAOC,GACrB,GAAIxB,EAAMV,OAASnhB,KAAK4hB,OACpB,OAGJJ,EAAQ1a,SAAQ2a,IACRA,EAAEuB,SACFvB,EAAEuB,QAAQpC,SAEda,EAAEjO,WAAY,KAElB,MAAMvL,EAAK4Z,EAAW,MAChByB,EAAQ,GACdtC,GAAkBla,SAASyE,IACR,MAAXtD,EAAEsD,KAGN+X,EAAM/X,GAAQtD,EAAEsD,OAEpB,GAAOgB,WAAWtE,EAAEqL,QAAUrL,EAAEgP,QAASoM,EAAWC,MAGV,IAA1C9B,EAAQ7d,QAAQ8d,IAAOA,EAAEtZ,OAAMvD,OAC/B,MAUR,OANA4c,EAAQ1a,SAAQ2a,IACRA,EAAEuB,SACFvB,EAAEuB,QAAQpC,SAEda,EAAEjO,WAAY,KAEX,GAAOjH,WAAW,wBAAyB,EAAA3M,OAAA,oBAA4B,CAC1EmU,OAAQA,EACRG,OAAQA,EAGRyO,QAASnB,EAAQnb,KAAKob,GAAMR,GAAkBQ,KAC9CnW,SAAUtL,WC/jB1B,MAAMujB,GAAc,KCKd,GAAS,IAAI,EAAA3jB,OAAOF,GAEpB8jB,GAAmB,mCAClB,MAAMC,WAAgCnI,GACzCxb,YAAY4O,EAAS0O,GACjB,MAAM9R,EAAW,IAAIoY,GAAehV,EAAS0O,GACvChD,EAAa9O,EAAS8O,WACxBA,EAAWpB,UACX,GAAOzM,WAAW,+CAAgD,EAAA3M,OAAA,6BAAqC,CACnG4M,UAAW,0CAInBmC,MADYyL,EAAWhN,IAAIpH,QAAQ,SAAU,MAAMA,QAAQ,OAAQ,WACxD0I,IACX,IAAA3E,gBAAe/J,KAAM,SAAUsL,EAASqY,YACxC,IAAA5Z,gBAAe/J,KAAM,YAAasL,EAASqY,YAC3C,IAAA5Z,gBAAe/J,KAAM,gBAAiBsL,EAASsY,eAEnD3c,sBACI,OAAQjH,KAAK2jB,YAAcH,IAG5B,MAAME,WAAuBvG,GAChC7W,4BAA4BoI,EAAS0O,GACjC,OAAO,IAAIqG,GAAwB/U,EAAS0O,GAEhD9W,iBAAiB8W,GACb,MAAMyG,EAAY,CACdzG,OAAQoG,GACRG,UAAWH,GACXI,cAAe,MAEnB,OAAc,MAAVxG,IAGoB,kBAAb,EACPyG,EAAUF,UAAYvG,EAEO,MAAxBA,EAAOwG,eACZ,GAAOE,eAA8C,kBAAtB1G,EAAgB,UAAiB,qCAAsC,YAAaA,EAAOuG,WAC1H,GAAOG,eAAkD,kBAA1B1G,EAAoB,cAAiB,wBAAyB,gBAAiB,cAC9GyG,EAAUF,UAAYvG,EAAOuG,UAC7BE,EAAUD,cAAgBxG,EAAOwG,eAE5BxG,EAAOuG,YACZE,EAAUF,UAAYvG,EAAOuG,WAEjCE,EAAUzG,OAASyG,EAAUF,WAdlBE,EAiBfvd,cAAcoI,EAAS0O,GACnB,IAAIK,EAAO,KACX,OAAQ/O,EAAUA,EAAQnD,KAAO,WAC7B,IAAK,YACDkS,EAAO,oBACP,MACJ,IAAK,UACDA,EAAO,oBACP,MACJ,IAAK,UACDA,EAAO,oBACP,MACJ,IAAK,QACDA,EAAO,kBACP,MACJ,IAAK,SACDA,EAAO,mBACP,MACJ,IAAK,QACDA,EAAO,4BACP,MACJ,IAAK,WACDA,EAAO,2BACP,MACJ,QACI,GAAOlR,WAAW,sBAAuB,EAAA3M,OAAA,wBAAgC,CACrEmkB,SAAU,UACVtiB,MAAOiN,IAGnB,MAAM0L,EAAa,CACfuD,WAAW,EACXvQ,IAAM,WAAkBqQ,EAAO,OAASL,EAAOuG,UAC/C/F,iBAAkB,CAACC,EAASzQ,KACpBgQ,EAAOuG,YAAcH,IACrBrc,IAEGQ,QAAQC,SAAQ,KAO/B,OAJ4B,MAAxBwV,EAAOwG,gBACPxJ,EAAW4J,KAAO,GAClB5J,EAAWpB,SAAWoE,EAAOwG,eAE1BxJ,EAEXnT,sBACI,OAAQjH,KAAK2jB,YAAcH,ICnG5B,MAAMS,WAA6B/K,GACtCjB,KAAKlE,EAAQG,GACT,MAAM4F,EAAU,CACZ/F,OAAQA,EACRG,OAAQA,EACR6F,GAAK/Z,KAAKqZ,UACVW,QAAS,OAEa,MAAtBha,KAAKkkB,gBACLlkB,KAAKkkB,cAAgB,IAEzB,MAAMC,EAAkB,CAAErK,QAAAA,EAASlS,QAAS,KAAMC,OAAQ,MACpDgZ,EAAU,IAAIlZ,SAAQ,CAACC,EAASC,KAClCsc,EAAgBvc,QAAUA,EAC1Buc,EAAgBtc,OAASA,KAoD7B,OAlDA7H,KAAKkkB,cAAcnd,KAAKod,GACnBnkB,KAAKokB,0BAENpkB,KAAKokB,wBAA0B3a,YAAW,KAGtC,MAAM4a,EAAQrkB,KAAKkkB,cACnBlkB,KAAKkkB,cAAgB,KACrBlkB,KAAKokB,wBAA0B,KAE/B,MAAMtK,EAAUuK,EAAMhe,KAAKie,GAAaA,EAASxK,UAMjD,OALA9Z,KAAKsP,KAAK,QAAS,CACf2K,OAAQ,eACRH,SAAS,IAAAI,UAASJ,GAClBxO,SAAUtL,QAEP,IAAA8N,WAAU9N,KAAKoa,WAAYpM,KAAKC,UAAU6L,IAAU1R,MAAMzD,IAC7D3E,KAAKsP,KAAK,QAAS,CACf2K,OAAQ,WACRH,QAASA,EACTO,SAAU1V,EACV2G,SAAUtL,OAIdqkB,EAAMvd,SAAQ,CAACqd,EAAiB5B,KAC5B,MAAMlL,EAAU1S,EAAO4d,GACvB,GAAIlL,EAAQlS,MAAO,CACf,MAAMA,EAAQ,IAAIb,MAAM+S,EAAQlS,MAAM8R,SACtC9R,EAAM8G,KAAOoL,EAAQlS,MAAM8G,KAC3B9G,EAAM5E,KAAO8W,EAAQlS,MAAM5E,KAC3B4jB,EAAgBtc,OAAO1C,QAGvBgf,EAAgBvc,QAAQyP,EAAQ1S,cAGxCQ,IACAnF,KAAKsP,KAAK,QAAS,CACf2K,OAAQ,WACR9U,MAAOA,EACP2U,QAASA,EACTxO,SAAUtL,OAEdqkB,EAAMvd,SAASqd,IACXA,EAAgBtc,OAAO1C,WAGhC,KAEA0b,GCjEf,MAAM,GAAS,IAAI,EAAAjhB,OAAOF,GAGnB,MAAM6kB,WAA0BpH,GACnC7W,iBAAiB8W,GAIb,OAHIA,GAA8B,kBAAb,GACjB,GAAO1Y,mBAAmB,iBAAkB,SAAU0Y,GAEnDA,GANO,mBAQlB9W,cAAcoI,EAAS0O,GACnB,GAAOhU,KAAK,qFACZ,IAAIqU,EAAO,KACX,OAAQ/O,EAAQnD,MACZ,IAAK,YACDkS,EAAO,uDACP,MACJ,IAAK,UACDA,EAAO,uDACP,MACJ,IAAK,UACDA,EAAO,uDACP,MACJ,IAAK,SACDA,EAAO,sDACP,MACJ,IAAK,QACDA,EAAO,qDACP,MACJ,QACI,GAAO/Y,mBAAmB,sBAAuB,UAAWgZ,UAAU,IAE9E,OAAQD,EAAO,WAAaL,GCjCpC,MAAM,GAAS,IAAI,EAAAxd,OAAOF,GAGpB8kB,GAAwB,CAC1BC,UAAW,2BACXC,QAAS,2BACTC,QAAS,2BACTC,OAAQ,4BAEL,MAAMC,WAAuB1H,GAChCrd,YAAY4O,EAAS0O,GAGjB,GAAc,MAAVA,EAAgB,CAChB,MAAM0H,GAAI,IAAAzV,sBAAsB,aAAtB,CAAoCX,GAC9C,GAAIoW,EAAG,CACH,MAAMC,EAAgBP,GAAsBM,EAAEvZ,MAC1CwZ,IACA3H,EAAS,CACL2H,cAAeA,EACfC,cAAc,IAKZ,MAAV5H,GACA,GAAO7Q,WAAW,sBAAuB,EAAA3M,OAAA,wBAAgC,CACrEmkB,SAAU,UACVtiB,MAAOiN,IAInBC,MAAMD,EAAS0O,GAEnB9W,iBAAiB8W,GAIC,MAAVA,GACA,GAAO1Y,mBAAmB,wDAAyD,SAAU0Y,GAEjG,MAAMyG,EAAY,CACdkB,cAAe,KACfC,cAAc,EACdC,qBAAsB,MAqB1B,MAlBwB,kBAAb,EACPpB,EAAUkB,cAAgB3H,EAEU,MAA/BA,EAAO6H,sBACZ,GAAOnB,eAAkD,kBAA1B1G,EAAoB,cAAiB,iDAAkD,gBAAiBA,EAAO2H,eAC9I,GAAOjB,eAAyD,kBAAjC1G,EAA2B,qBAAiB,+BAAgC,uBAAwB,cACnIyG,EAAUkB,cAAgB3H,EAAO2H,cACjClB,EAAUoB,qBAAuB7H,EAAO6H,qBACxCpB,EAAUmB,eAAiB5H,EAAO4H,cAE7B5H,EAAO2H,eACZ,GAAOjB,eAAkD,kBAA1B1G,EAAoB,cAAiB,wCAAyC,uBAAwBA,EAAO2H,eAC5IlB,EAAUkB,cAAgB3H,EAAO2H,cACjClB,EAAUmB,eAAiB5H,EAAO4H,cAGlC,GAAOtgB,mBAAmB,oCAAqC,SAAU0Y,GAEtEyG,EAEXvd,cAAcoI,EAAS0O,GACnB,IAAIK,EAAO,KACX,OAAQ/O,EAAUA,EAAQnD,KAAO,WAC7B,IAAK,YACDkS,EAAO,mCACP,MACJ,IAAK,UACDA,EAAO,mCACP,MACJ,IAAK,UACDA,EAAO,mCACP,MACJ,IAAK,SACDA,EAAO,kCACP,MACJ,QACI,GAAOlR,WAAW,sBAAuB,EAAA3M,OAAA,wBAAgC,CACrEmkB,SAAU,UACVtiB,MAAOiN,IAGnB,IAAItB,EAAM,KAENA,EADAgQ,EAAO4H,aACD,WAAYvH,WAAcL,EAAO2H,gBAGjC,WAAYtH,QAAWL,EAAO2H,gBAExC,MAAM3K,EAAa,CAAEhN,IAAAA,EAErBgN,QAAqB,IAMrB,OAJmC,MAA/BgD,EAAO6H,uBACP7K,EAAW4J,KAAO,GAClB5J,EAAWpB,SAAWoE,EAAO6H,sBAE1B7K,EAEXnT,sBACI,OAAQjH,KAAK+kB,gBAAkBP,GAAsBxkB,KAAK0O,QAAQnD,OC1G1E,MAAM,GAAS,IAAI,EAAA3L,OAAOF,GAE1B,IAAI2Z,GAAU,EACd,SAAS6L,GAAuB5Z,EAAU6Z,GACtC,MAAMC,EAAU,oBAChB,OAAO,SAAUrR,EAAQG,GACrB,MAAM4F,EAAU,CACZ/F,OAAQA,EACRG,OAAQA,EACR6F,GAAKV,KACLW,QAAS,OAEb,OAAO,IAAIrS,SAAQ,CAACC,EAASC,KACzB7H,KAAKsP,KAAK,QAAS,CACf2K,OAAQ,UACRmL,QAAAA,EACAtL,SAAS,IAAAI,UAASJ,GAClBxO,SAAUtL,OAEdmlB,EAASrL,GAAS,CAAC3U,EAAOkV,KACtB,GAAIlV,EAQA,OAPAnF,KAAKsP,KAAK,QAAS,CACf2K,OAAQ,WACRmL,QAAAA,EACAjgB,MAAAA,EACA2U,QAAAA,EACAxO,SAAUtL,OAEP6H,EAAO1C,GASlB,GAPAnF,KAAKsP,KAAK,QAAS,CACf2K,OAAQ,WACRmL,QAAAA,EACAtL,QAAAA,EACAO,SAAAA,EACA/O,SAAUtL,OAEVqa,EAASlV,MAAO,CAChB,MAAMA,EAAQ,IAAIb,MAAM+V,EAASlV,MAAM8R,SAGvC,OAFA9R,EAAM8G,KAAOoO,EAASlV,MAAM8G,KAC5B9G,EAAM5E,KAAO8Z,EAASlV,MAAM5E,KACrBsH,EAAO1C,GAElByC,EAAQyS,EAAS1V,eAsC1B,MAAM0gB,WAAqBnM,GAC9BpZ,YAAYwL,EAAUoD,GAClB,GAAO3O,oBAAqBslB,IACZ,MAAZ/Z,GACA,GAAO5G,mBAAmB,mBAAoB,WAAY4G,GAE9D,IAAIga,EAAO,KACPC,EAAmB,KACnBC,EAAc,KACQ,oBAAf,GACPF,EAAO,WACPC,EAAmBja,IAGnBga,EAAOha,EAASmS,MAAQnS,EAASga,MAAQ,IACpCA,GAAQha,EAASma,aAClBH,EAAO,YAEXE,EAAcla,EACVA,EAASwO,SACI,KAATwL,IACAA,EAAO,aAEXC,EAxDhB,SAA6Bja,GACzB,OAAO,SAAUyI,EAAQG,GACP,MAAVA,IACAA,EAAS,IAEb,MAAM4F,EAAU,CAAE/F,OAAAA,EAAQG,OAAAA,GAO1B,OANAlU,KAAKsP,KAAK,QAAS,CACf2K,OAAQ,UACRmL,QAAS,iBACTtL,SAAS,IAAAI,UAASJ,GAClBxO,SAAUtL,OAEPsL,EAASwO,QAAQA,GAAS1R,MAAMiS,IACnCra,KAAKsP,KAAK,QAAS,CACf2K,OAAQ,WACRmL,QAAS,iBACTtL,QAAAA,EACAO,SAAAA,EACA/O,SAAUtL,OAEPqa,KACPlV,IAQA,MAPAnF,KAAKsP,KAAK,QAAS,CACf2K,OAAQ,WACRmL,QAAS,iBACTtL,QAAAA,EACA3U,MAAAA,EACAmG,SAAUtL,OAERmF,MA2BiBugB,CAAoBpa,IAElCA,EAASqa,UACdJ,EAAmBL,GAAuB5Z,EAAUA,EAASqa,UAAUvlB,KAAKkL,IAEvEA,EAAS2M,KACdsN,EAAmBL,GAAuB5Z,EAAUA,EAAS2M,KAAK7X,KAAKkL,IAGvE,GAAO5G,mBAAmB,uBAAwB,WAAY4G,GAE7Dga,IACDA,EAAO,aAGf3W,MAAM2W,EAAM5W,IACZ,IAAA3E,gBAAe/J,KAAM,mBAAoBulB,IACzC,IAAAxb,gBAAe/J,KAAM,WAAYwlB,GAErCvN,KAAKlE,EAAQG,GACT,OAAOlU,KAAKulB,iBAAiBxR,EAAQG,IC5G7C,MAAM,GAAS,IAAI,EAAAtU,OAAOF,GAG1B,SAASkmB,GAAmBlX,EAASmX,GAKjC,GAJe,MAAXnX,IACAA,EAAU,aAGW,kBAAd,EAAwB,CAG/B,MAAM/B,EAAQ+B,EAAQ/B,MAAM,kBAC5B,GAAIA,EACA,OAAQA,EAAM,IACV,IAAK,OACD,OAAO,IAAIuM,GAAgBxK,GAC/B,IAAK,KACD,OAAO,IAAI4M,GAAkB5M,GACjC,QACI,GAAOhK,mBAAmB,yBAA0B,UAAWgK,IAI/E,MAAMoW,GAAI,OAAWpW,GAOrB,OANKoW,GAAMA,EAAEgB,kBACT,GAAOvZ,WAAW,yCAA0C,EAAA3M,OAAA,qBAA6B,CACrF4M,UAAW,qBACXkC,QAASA,IAGVoW,EAAEgB,iBAAiB,CACtB3D,iBAAgB,GAChB3E,gBAAe,GACfM,mBAAkB,GAClBQ,kBAAiB,GACjBoF,eAAc,GACdxK,gBAAe,GACfqL,kBAAiB,GACjBM,eAAc,GACdQ,aAAY,GACZ9B,YAAW,IACZsC","sources":["webpack://_N_E/./node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/lib.esm/_version.js","webpack://_N_E/./node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/lib.esm/formatter.js","webpack://_N_E/./node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/lib.esm/base-provider.js","webpack://_N_E/./node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js","webpack://_N_E/./node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/lib.esm/ws.js","webpack://_N_E/./node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/lib.esm/websocket-provider.js","webpack://_N_E/./node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js","webpack://_N_E/./node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js","webpack://_N_E/./node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js","webpack://_N_E/./node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js","webpack://_N_E/./node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/lib.esm/fallback-provider.js","webpack://_N_E/./node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/lib.esm/ipc-provider.js","webpack://_N_E/./node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/lib.esm/infura-provider.js","webpack://_N_E/./node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js","webpack://_N_E/./node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js","webpack://_N_E/./node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/lib.esm/pocket-provider.js","webpack://_N_E/./node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/lib.esm/web3-provider.js","webpack://_N_E/./node_modules/@web3-onboard/walletconnect/node_modules/@ethersproject/providers/lib.esm/index.js"],"sourcesContent":["export const version = \"providers/5.5.0\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { hexDataLength, hexDataSlice, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { accessListify, parse as parseTransaction } from \"@ethersproject/transactions\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport class Formatter {\n    constructor() {\n        logger.checkNew(new.target, Formatter);\n        this.formats = this.getDefaultFormats();\n    }\n    getDefaultFormats() {\n        const formats = ({});\n        const address = this.address.bind(this);\n        const bigNumber = this.bigNumber.bind(this);\n        const blockTag = this.blockTag.bind(this);\n        const data = this.data.bind(this);\n        const hash = this.hash.bind(this);\n        const hex = this.hex.bind(this);\n        const number = this.number.bind(this);\n        const type = this.type.bind(this);\n        const strictData = (v) => { return this.data(v, true); };\n        formats.transaction = {\n            hash: hash,\n            type: type,\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n            blockHash: Formatter.allowNull(hash, null),\n            blockNumber: Formatter.allowNull(number, null),\n            transactionIndex: Formatter.allowNull(number, null),\n            confirmations: Formatter.allowNull(number, null),\n            from: address,\n            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)\n            // must be set\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            gasLimit: bigNumber,\n            to: Formatter.allowNull(address, null),\n            value: bigNumber,\n            nonce: number,\n            data: data,\n            r: Formatter.allowNull(this.uint256),\n            s: Formatter.allowNull(this.uint256),\n            v: Formatter.allowNull(number),\n            creates: Formatter.allowNull(address, null),\n            raw: Formatter.allowNull(data),\n        };\n        formats.transactionRequest = {\n            from: Formatter.allowNull(address),\n            nonce: Formatter.allowNull(number),\n            gasLimit: Formatter.allowNull(bigNumber),\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            to: Formatter.allowNull(address),\n            value: Formatter.allowNull(bigNumber),\n            data: Formatter.allowNull(strictData),\n            type: Formatter.allowNull(number),\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n        };\n        formats.receiptLog = {\n            transactionIndex: number,\n            blockNumber: number,\n            transactionHash: hash,\n            address: address,\n            topics: Formatter.arrayOf(hash),\n            data: data,\n            logIndex: number,\n            blockHash: hash,\n        };\n        formats.receipt = {\n            to: Formatter.allowNull(this.address, null),\n            from: Formatter.allowNull(this.address, null),\n            contractAddress: Formatter.allowNull(address, null),\n            transactionIndex: number,\n            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n            root: Formatter.allowNull(hex),\n            gasUsed: bigNumber,\n            logsBloom: Formatter.allowNull(data),\n            blockHash: hash,\n            transactionHash: hash,\n            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n            blockNumber: number,\n            confirmations: Formatter.allowNull(number, null),\n            cumulativeGasUsed: bigNumber,\n            effectiveGasPrice: Formatter.allowNull(bigNumber),\n            status: Formatter.allowNull(number),\n            type: type\n        };\n        formats.block = {\n            hash: hash,\n            parentHash: hash,\n            number: number,\n            timestamp: number,\n            nonce: Formatter.allowNull(hex),\n            difficulty: this.difficulty.bind(this),\n            gasLimit: bigNumber,\n            gasUsed: bigNumber,\n            miner: address,\n            extraData: data,\n            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n            baseFeePerGas: Formatter.allowNull(bigNumber)\n        };\n        formats.blockWithTransactions = shallowCopy(formats.block);\n        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n        formats.filter = {\n            fromBlock: Formatter.allowNull(blockTag, undefined),\n            toBlock: Formatter.allowNull(blockTag, undefined),\n            blockHash: Formatter.allowNull(hash, undefined),\n            address: Formatter.allowNull(address, undefined),\n            topics: Formatter.allowNull(this.topics.bind(this), undefined),\n        };\n        formats.filterLog = {\n            blockNumber: Formatter.allowNull(number),\n            blockHash: Formatter.allowNull(hash),\n            transactionIndex: number,\n            removed: Formatter.allowNull(this.boolean.bind(this)),\n            address: address,\n            data: Formatter.allowFalsish(data, \"0x\"),\n            topics: Formatter.arrayOf(hash),\n            transactionHash: hash,\n            logIndex: number,\n        };\n        return formats;\n    }\n    accessList(accessList) {\n        return accessListify(accessList || []);\n    }\n    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n    // Strict! Used on input.\n    number(number) {\n        if (number === \"0x\") {\n            return 0;\n        }\n        return BigNumber.from(number).toNumber();\n    }\n    type(number) {\n        if (number === \"0x\" || number == null) {\n            return 0;\n        }\n        return BigNumber.from(number).toNumber();\n    }\n    // Strict! Used on input.\n    bigNumber(value) {\n        return BigNumber.from(value);\n    }\n    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n    boolean(value) {\n        if (typeof (value) === \"boolean\") {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            value = value.toLowerCase();\n            if (value === \"true\") {\n                return true;\n            }\n            if (value === \"false\") {\n                return false;\n            }\n        }\n        throw new Error(\"invalid boolean - \" + value);\n    }\n    hex(value, strict) {\n        if (typeof (value) === \"string\") {\n            if (!strict && value.substring(0, 2) !== \"0x\") {\n                value = \"0x\" + value;\n            }\n            if (isHexString(value)) {\n                return value.toLowerCase();\n            }\n        }\n        return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n    }\n    data(value, strict) {\n        const result = this.hex(value, strict);\n        if ((result.length % 2) !== 0) {\n            throw new Error(\"invalid data; odd-length - \" + value);\n        }\n        return result;\n    }\n    // Requires an address\n    // Strict! Used on input.\n    address(value) {\n        return getAddress(value);\n    }\n    callAddress(value) {\n        if (!isHexString(value, 32)) {\n            return null;\n        }\n        const address = getAddress(hexDataSlice(value, 12));\n        return (address === AddressZero) ? null : address;\n    }\n    contractAddress(value) {\n        return getContractAddress(value);\n    }\n    // Strict! Used on input.\n    blockTag(blockTag) {\n        if (blockTag == null) {\n            return \"latest\";\n        }\n        if (blockTag === \"earliest\") {\n            return \"0x0\";\n        }\n        if (blockTag === \"latest\" || blockTag === \"pending\") {\n            return blockTag;\n        }\n        if (typeof (blockTag) === \"number\" || isHexString(blockTag)) {\n            return hexValue(blockTag);\n        }\n        throw new Error(\"invalid blockTag\");\n    }\n    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n    hash(value, strict) {\n        const result = this.hex(value, strict);\n        if (hexDataLength(result) !== 32) {\n            return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n        }\n        return result;\n    }\n    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n    difficulty(value) {\n        if (value == null) {\n            return null;\n        }\n        const v = BigNumber.from(value);\n        try {\n            return v.toNumber();\n        }\n        catch (error) { }\n        return null;\n    }\n    uint256(value) {\n        if (!isHexString(value)) {\n            throw new Error(\"invalid uint256\");\n        }\n        return hexZeroPad(value, 32);\n    }\n    _block(value, format) {\n        if (value.author != null && value.miner == null) {\n            value.miner = value.author;\n        }\n        // The difficulty may need to come from _difficulty in recursed blocks\n        const difficulty = (value._difficulty != null) ? value._difficulty : value.difficulty;\n        const result = Formatter.check(format, value);\n        result._difficulty = ((difficulty == null) ? null : BigNumber.from(difficulty));\n        return result;\n    }\n    block(value) {\n        return this._block(value, this.formats.block);\n    }\n    blockWithTransactions(value) {\n        return this._block(value, this.formats.blockWithTransactions);\n    }\n    // Strict! Used on input.\n    transactionRequest(value) {\n        return Formatter.check(this.formats.transactionRequest, value);\n    }\n    transactionResponse(transaction) {\n        // Rename gas to gasLimit\n        if (transaction.gas != null && transaction.gasLimit == null) {\n            transaction.gasLimit = transaction.gas;\n        }\n        // Some clients (TestRPC) do strange things like return 0x0 for the\n        // 0 address; correct this to be a real address\n        if (transaction.to && BigNumber.from(transaction.to).isZero()) {\n            transaction.to = \"0x0000000000000000000000000000000000000000\";\n        }\n        // Rename input to data\n        if (transaction.input != null && transaction.data == null) {\n            transaction.data = transaction.input;\n        }\n        // If to and creates are empty, populate the creates from the transaction\n        if (transaction.to == null && transaction.creates == null) {\n            transaction.creates = this.contractAddress(transaction);\n        }\n        if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {\n            transaction.accessList = [];\n        }\n        const result = Formatter.check(this.formats.transaction, transaction);\n        if (transaction.chainId != null) {\n            let chainId = transaction.chainId;\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n            result.chainId = chainId;\n        }\n        else {\n            let chainId = transaction.networkId;\n            // geth-etc returns chainId\n            if (chainId == null && result.v == null) {\n                chainId = transaction.chainId;\n            }\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n            if (typeof (chainId) !== \"number\" && result.v != null) {\n                chainId = (result.v - 35) / 2;\n                if (chainId < 0) {\n                    chainId = 0;\n                }\n                chainId = parseInt(chainId);\n            }\n            if (typeof (chainId) !== \"number\") {\n                chainId = 0;\n            }\n            result.chainId = chainId;\n        }\n        // 0x0000... should actually be null\n        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n            result.blockHash = null;\n        }\n        return result;\n    }\n    transaction(value) {\n        return parseTransaction(value);\n    }\n    receiptLog(value) {\n        return Formatter.check(this.formats.receiptLog, value);\n    }\n    receipt(value) {\n        const result = Formatter.check(this.formats.receipt, value);\n        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\n        if (result.root != null) {\n            if (result.root.length <= 4) {\n                // Could be 0x00, 0x0, 0x01 or 0x1\n                const value = BigNumber.from(result.root).toNumber();\n                if (value === 0 || value === 1) {\n                    // Make sure if both are specified, they match\n                    if (result.status != null && (result.status !== value)) {\n                        logger.throwArgumentError(\"alt-root-status/status mismatch\", \"value\", { root: result.root, status: result.status });\n                    }\n                    result.status = value;\n                    delete result.root;\n                }\n                else {\n                    logger.throwArgumentError(\"invalid alt-root-status\", \"value.root\", result.root);\n                }\n            }\n            else if (result.root.length !== 66) {\n                // Must be a valid bytes32\n                logger.throwArgumentError(\"invalid root hash\", \"value.root\", result.root);\n            }\n        }\n        if (result.status != null) {\n            result.byzantium = true;\n        }\n        return result;\n    }\n    topics(value) {\n        if (Array.isArray(value)) {\n            return value.map((v) => this.topics(v));\n        }\n        else if (value != null) {\n            return this.hash(value, true);\n        }\n        return null;\n    }\n    filter(value) {\n        return Formatter.check(this.formats.filter, value);\n    }\n    filterLog(value) {\n        return Formatter.check(this.formats.filterLog, value);\n    }\n    static check(format, object) {\n        const result = {};\n        for (const key in format) {\n            try {\n                const value = format[key](object[key]);\n                if (value !== undefined) {\n                    result[key] = value;\n                }\n            }\n            catch (error) {\n                error.checkKey = key;\n                error.checkValue = object[key];\n                throw error;\n            }\n        }\n        return result;\n    }\n    // if value is null-ish, nullValue is returned\n    static allowNull(format, nullValue) {\n        return (function (value) {\n            if (value == null) {\n                return nullValue;\n            }\n            return format(value);\n        });\n    }\n    // If value is false-ish, replaceValue is returned\n    static allowFalsish(format, replaceValue) {\n        return (function (value) {\n            if (!value) {\n                return replaceValue;\n            }\n            return format(value);\n        });\n    }\n    // Requires an Array satisfying check\n    static arrayOf(format) {\n        return (function (array) {\n            if (!Array.isArray(array)) {\n                throw new Error(\"not an array\");\n            }\n            const result = [];\n            array.forEach(function (value) {\n                result.push(format(value));\n            });\n            return result;\n        });\n    }\n}\nexport function isCommunityResourcable(value) {\n    return (value && typeof (value.isCommunityResource) === \"function\");\n}\nexport function isCommunityResource(value) {\n    return (isCommunityResourcable(value) && value.isCommunityResource());\n}\n// Show the throttle message only once\nlet throttleMessage = false;\nexport function showThrottleMessage() {\n    if (throttleMessage) {\n        return;\n    }\n    throttleMessage = true;\n    console.log(\"========= NOTICE =========\");\n    console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https:/\\/docs.ethers.io/api-keys/\");\n    console.log(\"==========================\");\n}\n//# sourceMappingURL=formatter.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ForkEvent, Provider } from \"@ethersproject/abstract-provider\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, concat, hexConcat, hexDataLength, hexDataSlice, hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { HashZero } from \"@ethersproject/constants\";\nimport { namehash } from \"@ethersproject/hash\";\nimport { getNetwork } from \"@ethersproject/networks\";\nimport { defineReadOnly, getStatic, resolveProperties } from \"@ethersproject/properties\";\nimport { sha256 } from \"@ethersproject/sha2\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { fetchJson, poll } from \"@ethersproject/web\";\nimport bech32 from \"bech32\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { Formatter } from \"./formatter\";\n//////////////////////////////\n// Event Serializeing\nfunction checkTopic(topic) {\n    if (topic == null) {\n        return \"null\";\n    }\n    if (hexDataLength(topic) !== 32) {\n        logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n    }\n    return topic.toLowerCase();\n}\nfunction serializeTopics(topics) {\n    // Remove trailing null AND-topics; they are redundant\n    topics = topics.slice();\n    while (topics.length > 0 && topics[topics.length - 1] == null) {\n        topics.pop();\n    }\n    return topics.map((topic) => {\n        if (Array.isArray(topic)) {\n            // Only track unique OR-topics\n            const unique = {};\n            topic.forEach((topic) => {\n                unique[checkTopic(topic)] = true;\n            });\n            // The order of OR-topics does not matter\n            const sorted = Object.keys(unique);\n            sorted.sort();\n            return sorted.join(\"|\");\n        }\n        else {\n            return checkTopic(topic);\n        }\n    }).join(\"&\");\n}\nfunction deserializeTopics(data) {\n    if (data === \"\") {\n        return [];\n    }\n    return data.split(/&/g).map((topic) => {\n        if (topic === \"\") {\n            return [];\n        }\n        const comps = topic.split(\"|\").map((topic) => {\n            return ((topic === \"null\") ? null : topic);\n        });\n        return ((comps.length === 1) ? comps[0] : comps);\n    });\n}\nfunction getEventTag(eventName) {\n    if (typeof (eventName) === \"string\") {\n        eventName = eventName.toLowerCase();\n        if (hexDataLength(eventName) === 32) {\n            return \"tx:\" + eventName;\n        }\n        if (eventName.indexOf(\":\") === -1) {\n            return eventName;\n        }\n    }\n    else if (Array.isArray(eventName)) {\n        return \"filter:*:\" + serializeTopics(eventName);\n    }\n    else if (ForkEvent.isForkEvent(eventName)) {\n        logger.warn(\"not implemented\");\n        throw new Error(\"not implemented\");\n    }\n    else if (eventName && typeof (eventName) === \"object\") {\n        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n    }\n    throw new Error(\"invalid event - \" + eventName);\n}\n//////////////////////////////\n// Helper Object\nfunction getTime() {\n    return (new Date()).getTime();\n}\nfunction stall(duration) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n//////////////////////////////\n// Provider Object\n/**\n *  EventType\n *   - \"block\"\n *   - \"poll\"\n *   - \"didPoll\"\n *   - \"pending\"\n *   - \"error\"\n *   - \"network\"\n *   - filter\n *   - topics array\n *   - transaction hash\n */\nconst PollableEvents = [\"block\", \"network\", \"pending\", \"poll\"];\nexport class Event {\n    constructor(tag, listener, once) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"listener\", listener);\n        defineReadOnly(this, \"once\", once);\n    }\n    get event() {\n        switch (this.type) {\n            case \"tx\":\n                return this.hash;\n            case \"filter\":\n                return this.filter;\n        }\n        return this.tag;\n    }\n    get type() {\n        return this.tag.split(\":\")[0];\n    }\n    get hash() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"tx\") {\n            return null;\n        }\n        return comps[1];\n    }\n    get filter() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"filter\") {\n            return null;\n        }\n        const address = comps[1];\n        const topics = deserializeTopics(comps[2]);\n        const filter = {};\n        if (topics.length > 0) {\n            filter.topics = topics;\n        }\n        if (address && address !== \"*\") {\n            filter.address = address;\n        }\n        return filter;\n    }\n    pollable() {\n        return (this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0);\n    }\n}\n;\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nconst coinInfos = {\n    \"0\": { symbol: \"btc\", p2pkh: 0x00, p2sh: 0x05, prefix: \"bc\" },\n    \"2\": { symbol: \"ltc\", p2pkh: 0x30, p2sh: 0x32, prefix: \"ltc\" },\n    \"3\": { symbol: \"doge\", p2pkh: 0x1e, p2sh: 0x16 },\n    \"60\": { symbol: \"eth\", ilk: \"eth\" },\n    \"61\": { symbol: \"etc\", ilk: \"eth\" },\n    \"700\": { symbol: \"xdai\", ilk: \"eth\" },\n};\nfunction bytes32ify(value) {\n    return hexZeroPad(BigNumber.from(value).toHexString(), 32);\n}\n// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\nfunction base58Encode(data) {\n    return Base58.encode(concat([data, hexDataSlice(sha256(sha256(data)), 0, 4)]));\n}\nconst matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\nfunction _parseString(result) {\n    try {\n        return toUtf8String(_parseBytes(result));\n    }\n    catch (error) { }\n    return null;\n}\nfunction _parseBytes(result) {\n    if (result === \"0x\") {\n        return null;\n    }\n    const offset = BigNumber.from(hexDataSlice(result, 0, 32)).toNumber();\n    const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();\n    return hexDataSlice(result, offset + 32, offset + 32 + length);\n}\nexport class Resolver {\n    // The resolvedAddress is only for creating a ReverseLookup resolver\n    constructor(provider, address, name, resolvedAddress) {\n        defineReadOnly(this, \"provider\", provider);\n        defineReadOnly(this, \"name\", name);\n        defineReadOnly(this, \"address\", provider.formatter.address(address));\n        defineReadOnly(this, \"_resolvedAddress\", resolvedAddress);\n    }\n    _fetchBytes(selector, parameters) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // e.g. keccak256(\"addr(bytes32,uint256)\")\n            const tx = {\n                to: this.address,\n                data: hexConcat([selector, namehash(this.name), (parameters || \"0x\")])\n            };\n            try {\n                return _parseBytes(yield this.provider.call(tx));\n            }\n            catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) {\n                    return null;\n                }\n                return null;\n            }\n        });\n    }\n    _getAddress(coinType, hexBytes) {\n        const coinInfo = coinInfos[String(coinType)];\n        if (coinInfo == null) {\n            logger.throwError(`unsupported coin type: ${coinType}`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${coinType})`\n            });\n        }\n        if (coinInfo.ilk === \"eth\") {\n            return this.provider.formatter.address(hexBytes);\n        }\n        const bytes = arrayify(hexBytes);\n        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n        if (coinInfo.p2pkh != null) {\n            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n            if (p2pkh) {\n                const length = parseInt(p2pkh[1], 16);\n                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([[coinInfo.p2pkh], (\"0x\" + p2pkh[2])]));\n                }\n            }\n        }\n        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n        if (coinInfo.p2sh != null) {\n            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n            if (p2sh) {\n                const length = parseInt(p2sh[1], 16);\n                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([[coinInfo.p2sh], (\"0x\" + p2sh[2])]));\n                }\n            }\n        }\n        // Bech32\n        if (coinInfo.prefix != null) {\n            const length = bytes[1];\n            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n            let version = bytes[0];\n            if (version === 0x00) {\n                if (length !== 20 && length !== 32) {\n                    version = -1;\n                }\n            }\n            else {\n                version = -1;\n            }\n            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {\n                const words = bech32.toWords(bytes.slice(2));\n                words.unshift(version);\n                return bech32.encode(coinInfo.prefix, words);\n            }\n        }\n        return null;\n    }\n    getAddress(coinType) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (coinType == null) {\n                coinType = 60;\n            }\n            // If Ethereum, use the standard `addr(bytes32)`\n            if (coinType === 60) {\n                try {\n                    // keccak256(\"addr(bytes32)\")\n                    const transaction = {\n                        to: this.address,\n                        data: (\"0x3b3b57de\" + namehash(this.name).substring(2))\n                    };\n                    const hexBytes = yield this.provider.call(transaction);\n                    // No address\n                    if (hexBytes === \"0x\" || hexBytes === HashZero) {\n                        return null;\n                    }\n                    return this.provider.formatter.callAddress(hexBytes);\n                }\n                catch (error) {\n                    if (error.code === Logger.errors.CALL_EXCEPTION) {\n                        return null;\n                    }\n                    throw error;\n                }\n            }\n            // keccak256(\"addr(bytes32,uint256\")\n            const hexBytes = yield this._fetchBytes(\"0xf1cb7e06\", bytes32ify(coinType));\n            // No address\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // Compute the address\n            const address = this._getAddress(coinType, hexBytes);\n            if (address == null) {\n                logger.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `getAddress(${coinType})`,\n                    coinType: coinType,\n                    data: hexBytes\n                });\n            }\n            return address;\n        });\n    }\n    getAvatar() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const linkage = [];\n            try {\n                const avatar = yield this.getText(\"avatar\");\n                if (avatar == null) {\n                    return null;\n                }\n                for (let i = 0; i < matchers.length; i++) {\n                    const match = avatar.match(matchers[i]);\n                    if (match == null) {\n                        continue;\n                    }\n                    switch (match[1]) {\n                        case \"https\":\n                            linkage.push({ type: \"url\", content: avatar });\n                            return { linkage, url: avatar };\n                        case \"data\":\n                            linkage.push({ type: \"data\", content: avatar });\n                            return { linkage, url: avatar };\n                        case \"ipfs\":\n                            linkage.push({ type: \"ipfs\", content: avatar });\n                            return { linkage, url: `https:/\\/gateway.ipfs.io/ipfs/${avatar.substring(7)}` };\n                        case \"erc721\":\n                        case \"erc1155\": {\n                            // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                            const selector = (match[1] === \"erc721\") ? \"0xc87b56dd\" : \"0x0e89341c\";\n                            linkage.push({ type: match[1], content: avatar });\n                            // The owner of this name\n                            const owner = (this._resolvedAddress || (yield this.getAddress()));\n                            const comps = (match[2] || \"\").split(\"/\");\n                            if (comps.length !== 2) {\n                                return null;\n                            }\n                            const addr = yield this.provider.formatter.address(comps[0]);\n                            const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);\n                            // Check that this account owns the token\n                            if (match[1] === \"erc721\") {\n                                // ownerOf(uint256 tokenId)\n                                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({\n                                    to: addr, data: hexConcat([\"0x6352211e\", tokenId])\n                                }));\n                                if (owner !== tokenOwner) {\n                                    return null;\n                                }\n                                linkage.push({ type: \"owner\", content: tokenOwner });\n                            }\n                            else if (match[1] === \"erc1155\") {\n                                // balanceOf(address owner, uint256 tokenId)\n                                const balance = BigNumber.from(yield this.provider.call({\n                                    to: addr, data: hexConcat([\"0x00fdd58e\", hexZeroPad(owner, 32), tokenId])\n                                }));\n                                if (balance.isZero()) {\n                                    return null;\n                                }\n                                linkage.push({ type: \"balance\", content: balance.toString() });\n                            }\n                            // Call the token contract for the metadata URL\n                            const tx = {\n                                to: this.provider.formatter.address(comps[0]),\n                                data: hexConcat([selector, tokenId])\n                            };\n                            let metadataUrl = _parseString(yield this.provider.call(tx));\n                            if (metadataUrl == null) {\n                                return null;\n                            }\n                            linkage.push({ type: \"metadata-url\", content: metadataUrl });\n                            // ERC-1155 allows a generic {id} in the URL\n                            if (match[1] === \"erc1155\") {\n                                metadataUrl = metadataUrl.replace(\"{id}\", tokenId.substring(2));\n                            }\n                            // Get the token metadata\n                            const metadata = yield fetchJson(metadataUrl);\n                            // Pull the image URL out\n                            if (!metadata || typeof (metadata.image) !== \"string\" || !metadata.image.match(/^https:\\/\\//i)) {\n                                return null;\n                            }\n                            linkage.push({ type: \"metadata\", content: JSON.stringify(metadata) });\n                            linkage.push({ type: \"url\", content: metadata.image });\n                            return { linkage, url: metadata.image };\n                        }\n                    }\n                }\n            }\n            catch (error) { }\n            return null;\n        });\n    }\n    getContentHash() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // keccak256(\"contenthash()\")\n            const hexBytes = yield this._fetchBytes(\"0xbc1c58d1\");\n            // No contenthash\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // IPFS (CID: 1, Type: DAG-PB)\n            const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n            if (ipfs) {\n                const length = parseInt(ipfs[3], 16);\n                if (ipfs[4].length === length * 2) {\n                    return \"ipfs:/\\/\" + Base58.encode(\"0x\" + ipfs[1]);\n                }\n            }\n            // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n            const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n            if (swarm) {\n                if (swarm[1].length === (32 * 2)) {\n                    return \"bzz:/\\/\" + swarm[1];\n                }\n            }\n            return logger.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"getContentHash()\",\n                data: hexBytes\n            });\n        });\n    }\n    getText(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // The key encoded as parameter to fetchBytes\n            let keyBytes = toUtf8Bytes(key);\n            // The nodehash consumes the first slot, so the string pointer targets\n            // offset 64, with the length at offset 64 and data starting at offset 96\n            keyBytes = concat([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);\n            // Pad to word-size (32 bytes)\n            if ((keyBytes.length % 32) !== 0) {\n                keyBytes = concat([keyBytes, hexZeroPad(\"0x\", 32 - (key.length % 32))]);\n            }\n            const hexBytes = yield this._fetchBytes(\"0x59d1d43c\", hexlify(keyBytes));\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            return toUtf8String(hexBytes);\n        });\n    }\n}\nlet defaultFormatter = null;\nlet nextPollId = 1;\nexport class BaseProvider extends Provider {\n    /**\n     *  ready\n     *\n     *  A Promise<Network> that resolves only once the provider is ready.\n     *\n     *  Sub-classes that call the super with a network without a chainId\n     *  MUST set this. Standard named networks have a known chainId.\n     *\n     */\n    constructor(network) {\n        logger.checkNew(new.target, Provider);\n        super();\n        // Events being listened to\n        this._events = [];\n        this._emitted = { block: -2 };\n        this.formatter = new.target.getFormatter();\n        // If network is any, this Provider allows the underlying\n        // network to change dynamically, and we auto-detect the\n        // current network\n        defineReadOnly(this, \"anyNetwork\", (network === \"any\"));\n        if (this.anyNetwork) {\n            network = this.detectNetwork();\n        }\n        if (network instanceof Promise) {\n            this._networkPromise = network;\n            // Squash any \"unhandled promise\" errors; that do not need to be handled\n            network.catch((error) => { });\n            // Trigger initial network setting (async)\n            this._ready().catch((error) => { });\n        }\n        else {\n            const knownNetwork = getStatic(new.target, \"getNetwork\")(network);\n            if (knownNetwork) {\n                defineReadOnly(this, \"_network\", knownNetwork);\n                this.emit(\"network\", knownNetwork, null);\n            }\n            else {\n                logger.throwArgumentError(\"invalid network\", \"network\", network);\n            }\n        }\n        this._maxInternalBlockNumber = -1024;\n        this._lastBlockNumber = -2;\n        this._pollingInterval = 4000;\n        this._fastQueryDate = 0;\n    }\n    _ready() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._network == null) {\n                let network = null;\n                if (this._networkPromise) {\n                    try {\n                        network = yield this._networkPromise;\n                    }\n                    catch (error) { }\n                }\n                // Try the Provider's network detection (this MUST throw if it cannot)\n                if (network == null) {\n                    network = yield this.detectNetwork();\n                }\n                // This should never happen; every Provider sub-class should have\n                // suggested a network by here (or have thrown).\n                if (!network) {\n                    logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, {});\n                }\n                // Possible this call stacked so do not call defineReadOnly again\n                if (this._network == null) {\n                    if (this.anyNetwork) {\n                        this._network = network;\n                    }\n                    else {\n                        defineReadOnly(this, \"_network\", network);\n                    }\n                    this.emit(\"network\", network, null);\n                }\n            }\n            return this._network;\n        });\n    }\n    // This will always return the most recently established network.\n    // For \"any\", this can change (a \"network\" event is emitted before\n    // any change is reflected); otherwise this cannot change\n    get ready() {\n        return poll(() => {\n            return this._ready().then((network) => {\n                return network;\n            }, (error) => {\n                // If the network isn't running yet, we will wait\n                if (error.code === Logger.errors.NETWORK_ERROR && error.event === \"noNetwork\") {\n                    return undefined;\n                }\n                throw error;\n            });\n        });\n    }\n    // @TODO: Remove this and just create a singleton formatter\n    static getFormatter() {\n        if (defaultFormatter == null) {\n            defaultFormatter = new Formatter();\n        }\n        return defaultFormatter;\n    }\n    // @TODO: Remove this and just use getNetwork\n    static getNetwork(network) {\n        return getNetwork((network == null) ? \"homestead\" : network);\n    }\n    // Fetches the blockNumber, but will reuse any result that is less\n    // than maxAge old or has been requested since the last request\n    _getInternalBlockNumber(maxAge) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this._ready();\n            // Allowing stale data up to maxAge old\n            if (maxAge > 0) {\n                // While there are pending internal block requests...\n                while (this._internalBlockNumber) {\n                    // ...\"remember\" which fetch we started with\n                    const internalBlockNumber = this._internalBlockNumber;\n                    try {\n                        // Check the result is not too stale\n                        const result = yield internalBlockNumber;\n                        if ((getTime() - result.respTime) <= maxAge) {\n                            return result.blockNumber;\n                        }\n                        // Too old; fetch a new value\n                        break;\n                    }\n                    catch (error) {\n                        // The fetch rejected; if we are the first to get the\n                        // rejection, drop through so we replace it with a new\n                        // fetch; all others blocked will then get that fetch\n                        // which won't match the one they \"remembered\" and loop\n                        if (this._internalBlockNumber === internalBlockNumber) {\n                            break;\n                        }\n                    }\n                }\n            }\n            const reqTime = getTime();\n            const checkInternalBlockNumber = resolveProperties({\n                blockNumber: this.perform(\"getBlockNumber\", {}),\n                networkError: this.getNetwork().then((network) => (null), (error) => (error))\n            }).then(({ blockNumber, networkError }) => {\n                if (networkError) {\n                    // Unremember this bad internal block number\n                    if (this._internalBlockNumber === checkInternalBlockNumber) {\n                        this._internalBlockNumber = null;\n                    }\n                    throw networkError;\n                }\n                const respTime = getTime();\n                blockNumber = BigNumber.from(blockNumber).toNumber();\n                if (blockNumber < this._maxInternalBlockNumber) {\n                    blockNumber = this._maxInternalBlockNumber;\n                }\n                this._maxInternalBlockNumber = blockNumber;\n                this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n                return { blockNumber, reqTime, respTime };\n            });\n            this._internalBlockNumber = checkInternalBlockNumber;\n            // Swallow unhandled exceptions; if needed they are handled else where\n            checkInternalBlockNumber.catch((error) => {\n                // Don't null the dead (rejected) fetch, if it has already been updated\n                if (this._internalBlockNumber === checkInternalBlockNumber) {\n                    this._internalBlockNumber = null;\n                }\n            });\n            return (yield checkInternalBlockNumber).blockNumber;\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const pollId = nextPollId++;\n            // Track all running promises, so we can trigger a post-poll once they are complete\n            const runners = [];\n            let blockNumber = null;\n            try {\n                blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);\n            }\n            catch (error) {\n                this.emit(\"error\", error);\n                return;\n            }\n            this._setFastBlockNumber(blockNumber);\n            // Emit a poll event after we have the latest (fast) block number\n            this.emit(\"poll\", pollId, blockNumber);\n            // If the block has not changed, meh.\n            if (blockNumber === this._lastBlockNumber) {\n                this.emit(\"didPoll\", pollId);\n                return;\n            }\n            // First polling cycle, trigger a \"block\" events\n            if (this._emitted.block === -2) {\n                this._emitted.block = blockNumber - 1;\n            }\n            if (Math.abs((this._emitted.block) - blockNumber) > 1000) {\n                logger.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);\n                this.emit(\"error\", logger.makeError(\"network block skew detected\", Logger.errors.NETWORK_ERROR, {\n                    blockNumber: blockNumber,\n                    event: \"blockSkew\",\n                    previousBlockNumber: this._emitted.block\n                }));\n                this.emit(\"block\", blockNumber);\n            }\n            else {\n                // Notify all listener for each block that has passed\n                for (let i = this._emitted.block + 1; i <= blockNumber; i++) {\n                    this.emit(\"block\", i);\n                }\n            }\n            // The emitted block was updated, check for obsolete events\n            if (this._emitted.block !== blockNumber) {\n                this._emitted.block = blockNumber;\n                Object.keys(this._emitted).forEach((key) => {\n                    // The block event does not expire\n                    if (key === \"block\") {\n                        return;\n                    }\n                    // The block we were at when we emitted this event\n                    const eventBlockNumber = this._emitted[key];\n                    // We cannot garbage collect pending transactions or blocks here\n                    // They should be garbage collected by the Provider when setting\n                    // \"pending\" events\n                    if (eventBlockNumber === \"pending\") {\n                        return;\n                    }\n                    // Evict any transaction hashes or block hashes over 12 blocks\n                    // old, since they should not return null anyways\n                    if (blockNumber - eventBlockNumber > 12) {\n                        delete this._emitted[key];\n                    }\n                });\n            }\n            // First polling cycle\n            if (this._lastBlockNumber === -2) {\n                this._lastBlockNumber = blockNumber - 1;\n            }\n            // Find all transaction hashes we are waiting on\n            this._events.forEach((event) => {\n                switch (event.type) {\n                    case \"tx\": {\n                        const hash = event.hash;\n                        let runner = this.getTransactionReceipt(hash).then((receipt) => {\n                            if (!receipt || receipt.blockNumber == null) {\n                                return null;\n                            }\n                            this._emitted[\"t:\" + hash] = receipt.blockNumber;\n                            this.emit(hash, receipt);\n                            return null;\n                        }).catch((error) => { this.emit(\"error\", error); });\n                        runners.push(runner);\n                        break;\n                    }\n                    case \"filter\": {\n                        const filter = event.filter;\n                        filter.fromBlock = this._lastBlockNumber + 1;\n                        filter.toBlock = blockNumber;\n                        const runner = this.getLogs(filter).then((logs) => {\n                            if (logs.length === 0) {\n                                return;\n                            }\n                            logs.forEach((log) => {\n                                this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n                                this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n                                this.emit(filter, log);\n                            });\n                        }).catch((error) => { this.emit(\"error\", error); });\n                        runners.push(runner);\n                        break;\n                    }\n                }\n            });\n            this._lastBlockNumber = blockNumber;\n            // Once all events for this loop have been processed, emit \"didPoll\"\n            Promise.all(runners).then(() => {\n                this.emit(\"didPoll\", pollId);\n            }).catch((error) => { this.emit(\"error\", error); });\n            return;\n        });\n    }\n    // Deprecated; do not use this\n    resetEventsBlock(blockNumber) {\n        this._lastBlockNumber = blockNumber - 1;\n        if (this.polling) {\n            this.poll();\n        }\n    }\n    get network() {\n        return this._network;\n    }\n    // This method should query the network if the underlying network\n    // can change, such as when connected to a JSON-RPC backend\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return logger.throwError(\"provider does not support network detection\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"provider.detectNetwork\"\n            });\n        });\n    }\n    getNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const network = yield this._ready();\n            // Make sure we are still connected to the same network; this is\n            // only an external call for backends which can have the underlying\n            // network change spontaneously\n            const currentNetwork = yield this.detectNetwork();\n            if (network.chainId !== currentNetwork.chainId) {\n                // We are allowing network changes, things can get complex fast;\n                // make sure you know what you are doing if you use \"any\"\n                if (this.anyNetwork) {\n                    this._network = currentNetwork;\n                    // Reset all internal block number guards and caches\n                    this._lastBlockNumber = -2;\n                    this._fastBlockNumber = null;\n                    this._fastBlockNumberPromise = null;\n                    this._fastQueryDate = 0;\n                    this._emitted.block = -2;\n                    this._maxInternalBlockNumber = -1024;\n                    this._internalBlockNumber = null;\n                    // The \"network\" event MUST happen before this method resolves\n                    // so any events have a chance to unregister, so we stall an\n                    // additional event loop before returning from /this/ call\n                    this.emit(\"network\", currentNetwork, network);\n                    yield stall(0);\n                    return this._network;\n                }\n                const error = logger.makeError(\"underlying network changed\", Logger.errors.NETWORK_ERROR, {\n                    event: \"changed\",\n                    network: network,\n                    detectedNetwork: currentNetwork\n                });\n                this.emit(\"error\", error);\n                throw error;\n            }\n            return network;\n        });\n    }\n    get blockNumber() {\n        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {\n            this._setFastBlockNumber(blockNumber);\n        }, (error) => { });\n        return (this._fastBlockNumber != null) ? this._fastBlockNumber : -1;\n    }\n    get polling() {\n        return (this._poller != null);\n    }\n    set polling(value) {\n        if (value && !this._poller) {\n            this._poller = setInterval(() => { this.poll(); }, this.pollingInterval);\n            if (!this._bootstrapPoll) {\n                this._bootstrapPoll = setTimeout(() => {\n                    this.poll();\n                    // We block additional polls until the polling interval\n                    // is done, to prevent overwhelming the poll function\n                    this._bootstrapPoll = setTimeout(() => {\n                        // If polling was disabled, something may require a poke\n                        // since starting the bootstrap poll and it was disabled\n                        if (!this._poller) {\n                            this.poll();\n                        }\n                        // Clear out the bootstrap so we can do another\n                        this._bootstrapPoll = null;\n                    }, this.pollingInterval);\n                }, 0);\n            }\n        }\n        else if (!value && this._poller) {\n            clearInterval(this._poller);\n            this._poller = null;\n        }\n    }\n    get pollingInterval() {\n        return this._pollingInterval;\n    }\n    set pollingInterval(value) {\n        if (typeof (value) !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n            throw new Error(\"invalid polling interval\");\n        }\n        this._pollingInterval = value;\n        if (this._poller) {\n            clearInterval(this._poller);\n            this._poller = setInterval(() => { this.poll(); }, this._pollingInterval);\n        }\n    }\n    _getFastBlockNumber() {\n        const now = getTime();\n        // Stale block number, request a newer value\n        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {\n            this._fastQueryDate = now;\n            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {\n                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n                    this._fastBlockNumber = blockNumber;\n                }\n                return this._fastBlockNumber;\n            });\n        }\n        return this._fastBlockNumberPromise;\n    }\n    _setFastBlockNumber(blockNumber) {\n        // Older block, maybe a stale request\n        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {\n            return;\n        }\n        // Update the time we updated the blocknumber\n        this._fastQueryDate = getTime();\n        // Newer block number, use  it\n        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n            this._fastBlockNumber = blockNumber;\n            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n        }\n    }\n    waitForTransaction(transactionHash, confirmations, timeout) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._waitForTransaction(transactionHash, (confirmations == null) ? 1 : confirmations, timeout || 0, null);\n        });\n    }\n    _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const receipt = yield this.getTransactionReceipt(transactionHash);\n            // Receipt is already good\n            if ((receipt ? receipt.confirmations : 0) >= confirmations) {\n                return receipt;\n            }\n            // Poll until the receipt is good...\n            return new Promise((resolve, reject) => {\n                const cancelFuncs = [];\n                let done = false;\n                const alreadyDone = function () {\n                    if (done) {\n                        return true;\n                    }\n                    done = true;\n                    cancelFuncs.forEach((func) => { func(); });\n                    return false;\n                };\n                const minedHandler = (receipt) => {\n                    if (receipt.confirmations < confirmations) {\n                        return;\n                    }\n                    if (alreadyDone()) {\n                        return;\n                    }\n                    resolve(receipt);\n                };\n                this.on(transactionHash, minedHandler);\n                cancelFuncs.push(() => { this.removeListener(transactionHash, minedHandler); });\n                if (replaceable) {\n                    let lastBlockNumber = replaceable.startBlock;\n                    let scannedBlock = null;\n                    const replaceHandler = (blockNumber) => __awaiter(this, void 0, void 0, function* () {\n                        if (done) {\n                            return;\n                        }\n                        // Wait 1 second; this is only used in the case of a fault, so\n                        // we will trade off a little bit of latency for more consistent\n                        // results and fewer JSON-RPC calls\n                        yield stall(1000);\n                        this.getTransactionCount(replaceable.from).then((nonce) => __awaiter(this, void 0, void 0, function* () {\n                            if (done) {\n                                return;\n                            }\n                            if (nonce <= replaceable.nonce) {\n                                lastBlockNumber = blockNumber;\n                            }\n                            else {\n                                // First check if the transaction was mined\n                                {\n                                    const mined = yield this.getTransaction(transactionHash);\n                                    if (mined && mined.blockNumber != null) {\n                                        return;\n                                    }\n                                }\n                                // First time scanning. We start a little earlier for some\n                                // wiggle room here to handle the eventually consistent nature\n                                // of blockchain (e.g. the getTransactionCount was for a\n                                // different block)\n                                if (scannedBlock == null) {\n                                    scannedBlock = lastBlockNumber - 3;\n                                    if (scannedBlock < replaceable.startBlock) {\n                                        scannedBlock = replaceable.startBlock;\n                                    }\n                                }\n                                while (scannedBlock <= blockNumber) {\n                                    if (done) {\n                                        return;\n                                    }\n                                    const block = yield this.getBlockWithTransactions(scannedBlock);\n                                    for (let ti = 0; ti < block.transactions.length; ti++) {\n                                        const tx = block.transactions[ti];\n                                        // Successfully mined!\n                                        if (tx.hash === transactionHash) {\n                                            return;\n                                        }\n                                        // Matches our transaction from and nonce; its a replacement\n                                        if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {\n                                            if (done) {\n                                                return;\n                                            }\n                                            // Get the receipt of the replacement\n                                            const receipt = yield this.waitForTransaction(tx.hash, confirmations);\n                                            // Already resolved or rejected (prolly a timeout)\n                                            if (alreadyDone()) {\n                                                return;\n                                            }\n                                            // The reason we were replaced\n                                            let reason = \"replaced\";\n                                            if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {\n                                                reason = \"repriced\";\n                                            }\n                                            else if (tx.data === \"0x\" && tx.from === tx.to && tx.value.isZero()) {\n                                                reason = \"cancelled\";\n                                            }\n                                            // Explain why we were replaced\n                                            reject(logger.makeError(\"transaction was replaced\", Logger.errors.TRANSACTION_REPLACED, {\n                                                cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                                                reason,\n                                                replacement: this._wrapTransaction(tx),\n                                                hash: transactionHash,\n                                                receipt\n                                            }));\n                                            return;\n                                        }\n                                    }\n                                    scannedBlock++;\n                                }\n                            }\n                            if (done) {\n                                return;\n                            }\n                            this.once(\"block\", replaceHandler);\n                        }), (error) => {\n                            if (done) {\n                                return;\n                            }\n                            this.once(\"block\", replaceHandler);\n                        });\n                    });\n                    if (done) {\n                        return;\n                    }\n                    this.once(\"block\", replaceHandler);\n                    cancelFuncs.push(() => {\n                        this.removeListener(\"block\", replaceHandler);\n                    });\n                }\n                if (typeof (timeout) === \"number\" && timeout > 0) {\n                    const timer = setTimeout(() => {\n                        if (alreadyDone()) {\n                            return;\n                        }\n                        reject(logger.makeError(\"timeout exceeded\", Logger.errors.TIMEOUT, { timeout: timeout }));\n                    }, timeout);\n                    if (timer.unref) {\n                        timer.unref();\n                    }\n                    cancelFuncs.push(() => { clearTimeout(timer); });\n                }\n            });\n        });\n    }\n    getBlockNumber() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._getInternalBlockNumber(0);\n        });\n    }\n    getGasPrice() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const result = yield this.perform(\"getGasPrice\", {});\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getGasPrice\",\n                    result, error\n                });\n            }\n        });\n    }\n    getBalance(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getBalance\", params);\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getBalance\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getTransactionCount(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getTransactionCount\", params);\n            try {\n                return BigNumber.from(result).toNumber();\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getTransactionCount\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getCode(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getCode\", params);\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getCode\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getStorageAt(addressOrName, position, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag),\n                position: Promise.resolve(position).then((p) => hexValue(p))\n            });\n            const result = yield this.perform(\"getStorageAt\", params);\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getStorageAt\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    // This should be called by any subclass wrapping a TransactionResponse\n    _wrapTransaction(tx, hash, startBlock) {\n        if (hash != null && hexDataLength(hash) !== 32) {\n            throw new Error(\"invalid response - sendTransaction\");\n        }\n        const result = tx;\n        // Check the hash we expect is the same as the hash the server reported\n        if (hash != null && tx.hash !== hash) {\n            logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });\n        }\n        result.wait = (confirms, timeout) => __awaiter(this, void 0, void 0, function* () {\n            if (confirms == null) {\n                confirms = 1;\n            }\n            if (timeout == null) {\n                timeout = 0;\n            }\n            // Get the details to detect replacement\n            let replacement = undefined;\n            if (confirms !== 0 && startBlock != null) {\n                replacement = {\n                    data: tx.data,\n                    from: tx.from,\n                    nonce: tx.nonce,\n                    to: tx.to,\n                    value: tx.value,\n                    startBlock\n                };\n            }\n            const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);\n            if (receipt == null && confirms === 0) {\n                return null;\n            }\n            // No longer pending, allow the polling loop to garbage collect this\n            this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n            if (receipt.status === 0) {\n                logger.throwError(\"transaction failed\", Logger.errors.CALL_EXCEPTION, {\n                    transactionHash: tx.hash,\n                    transaction: tx,\n                    receipt: receipt\n                });\n            }\n            return receipt;\n        });\n        return result;\n    }\n    sendTransaction(signedTransaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const hexTx = yield Promise.resolve(signedTransaction).then(t => hexlify(t));\n            const tx = this.formatter.transaction(signedTransaction);\n            if (tx.confirmations == null) {\n                tx.confirmations = 0;\n            }\n            const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n            try {\n                const hash = yield this.perform(\"sendTransaction\", { signedTransaction: hexTx });\n                return this._wrapTransaction(tx, hash, blockNumber);\n            }\n            catch (error) {\n                error.transaction = tx;\n                error.transactionHash = tx.hash;\n                throw error;\n            }\n        });\n    }\n    _getTransactionRequest(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const values = yield transaction;\n            const tx = {};\n            [\"from\", \"to\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? this._getAddress(v) : null));\n            });\n            [\"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"value\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? BigNumber.from(v) : null));\n            });\n            [\"type\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => ((v != null) ? v : null));\n            });\n            if (values.accessList) {\n                tx.accessList = this.formatter.accessList(values.accessList);\n            }\n            [\"data\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? hexlify(v) : null));\n            });\n            return this.formatter.transactionRequest(yield resolveProperties(tx));\n        });\n    }\n    _getFilter(filter) {\n        return __awaiter(this, void 0, void 0, function* () {\n            filter = yield filter;\n            const result = {};\n            if (filter.address != null) {\n                result.address = this._getAddress(filter.address);\n            }\n            [\"blockHash\", \"topics\"].forEach((key) => {\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = filter[key];\n            });\n            [\"fromBlock\", \"toBlock\"].forEach((key) => {\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = this._getBlockTag(filter[key]);\n            });\n            return this.formatter.filter(yield resolveProperties(result));\n        });\n    }\n    call(transaction, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                transaction: this._getTransactionRequest(transaction),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"call\", params);\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"call\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    estimateGas(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                transaction: this._getTransactionRequest(transaction)\n            });\n            const result = yield this.perform(\"estimateGas\", params);\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"estimateGas\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    _getAddress(addressOrName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            addressOrName = yield addressOrName;\n            if (typeof (addressOrName) !== \"string\") {\n                logger.throwArgumentError(\"invalid address or ENS name\", \"name\", addressOrName);\n            }\n            const address = yield this.resolveName(addressOrName);\n            if (address == null) {\n                logger.throwError(\"ENS name not configured\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `resolveName(${JSON.stringify(addressOrName)})`\n                });\n            }\n            return address;\n        });\n    }\n    _getBlock(blockHashOrBlockTag, includeTransactions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            blockHashOrBlockTag = yield blockHashOrBlockTag;\n            // If blockTag is a number (not \"latest\", etc), this is the block number\n            let blockNumber = -128;\n            const params = {\n                includeTransactions: !!includeTransactions\n            };\n            if (isHexString(blockHashOrBlockTag, 32)) {\n                params.blockHash = blockHashOrBlockTag;\n            }\n            else {\n                try {\n                    params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);\n                    if (isHexString(params.blockTag)) {\n                        blockNumber = parseInt(params.blockTag.substring(2), 16);\n                    }\n                }\n                catch (error) {\n                    logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n                }\n            }\n            return poll(() => __awaiter(this, void 0, void 0, function* () {\n                const block = yield this.perform(\"getBlock\", params);\n                // Block was not found\n                if (block == null) {\n                    // For blockhashes, if we didn't say it existed, that blockhash may\n                    // not exist. If we did see it though, perhaps from a log, we know\n                    // it exists, and this node is just not caught up yet.\n                    if (params.blockHash != null) {\n                        if (this._emitted[\"b:\" + params.blockHash] == null) {\n                            return null;\n                        }\n                    }\n                    // For block tags, if we are asking for a future block, we return null\n                    if (params.blockTag != null) {\n                        if (blockNumber > this._emitted.block) {\n                            return null;\n                        }\n                    }\n                    // Retry on the next block\n                    return undefined;\n                }\n                // Add transactions\n                if (includeTransactions) {\n                    let blockNumber = null;\n                    for (let i = 0; i < block.transactions.length; i++) {\n                        const tx = block.transactions[i];\n                        if (tx.blockNumber == null) {\n                            tx.confirmations = 0;\n                        }\n                        else if (tx.confirmations == null) {\n                            if (blockNumber == null) {\n                                blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                            }\n                            // Add the confirmations using the fast block number (pessimistic)\n                            let confirmations = (blockNumber - tx.blockNumber) + 1;\n                            if (confirmations <= 0) {\n                                confirmations = 1;\n                            }\n                            tx.confirmations = confirmations;\n                        }\n                    }\n                    const blockWithTxs = this.formatter.blockWithTransactions(block);\n                    blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));\n                    return blockWithTxs;\n                }\n                return this.formatter.block(block);\n            }), { oncePoll: this });\n        });\n    }\n    getBlock(blockHashOrBlockTag) {\n        return (this._getBlock(blockHashOrBlockTag, false));\n    }\n    getBlockWithTransactions(blockHashOrBlockTag) {\n        return (this._getBlock(blockHashOrBlockTag, true));\n    }\n    getTransaction(transactionHash) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n            return poll(() => __awaiter(this, void 0, void 0, function* () {\n                const result = yield this.perform(\"getTransaction\", params);\n                if (result == null) {\n                    if (this._emitted[\"t:\" + transactionHash] == null) {\n                        return null;\n                    }\n                    return undefined;\n                }\n                const tx = this.formatter.transactionResponse(result);\n                if (tx.blockNumber == null) {\n                    tx.confirmations = 0;\n                }\n                else if (tx.confirmations == null) {\n                    const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                    // Add the confirmations using the fast block number (pessimistic)\n                    let confirmations = (blockNumber - tx.blockNumber) + 1;\n                    if (confirmations <= 0) {\n                        confirmations = 1;\n                    }\n                    tx.confirmations = confirmations;\n                }\n                return this._wrapTransaction(tx);\n            }), { oncePoll: this });\n        });\n    }\n    getTransactionReceipt(transactionHash) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n            return poll(() => __awaiter(this, void 0, void 0, function* () {\n                const result = yield this.perform(\"getTransactionReceipt\", params);\n                if (result == null) {\n                    if (this._emitted[\"t:\" + transactionHash] == null) {\n                        return null;\n                    }\n                    return undefined;\n                }\n                // \"geth-etc\" returns receipts before they are ready\n                if (result.blockHash == null) {\n                    return undefined;\n                }\n                const receipt = this.formatter.receipt(result);\n                if (receipt.blockNumber == null) {\n                    receipt.confirmations = 0;\n                }\n                else if (receipt.confirmations == null) {\n                    const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                    // Add the confirmations using the fast block number (pessimistic)\n                    let confirmations = (blockNumber - receipt.blockNumber) + 1;\n                    if (confirmations <= 0) {\n                        confirmations = 1;\n                    }\n                    receipt.confirmations = confirmations;\n                }\n                return receipt;\n            }), { oncePoll: this });\n        });\n    }\n    getLogs(filter) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({ filter: this._getFilter(filter) });\n            const logs = yield this.perform(\"getLogs\", params);\n            logs.forEach((log) => {\n                if (log.removed == null) {\n                    log.removed = false;\n                }\n            });\n            return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n        });\n    }\n    getEtherPrice() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            return this.perform(\"getEtherPrice\", {});\n        });\n    }\n    _getBlockTag(blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            blockTag = yield blockTag;\n            if (typeof (blockTag) === \"number\" && blockTag < 0) {\n                if (blockTag % 1) {\n                    logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n                }\n                let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                blockNumber += blockTag;\n                if (blockNumber < 0) {\n                    blockNumber = 0;\n                }\n                return this.formatter.blockTag(blockNumber);\n            }\n            return this.formatter.blockTag(blockTag);\n        });\n    }\n    getResolver(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const address = yield this._getResolver(name);\n                if (address == null) {\n                    return null;\n                }\n                return new Resolver(this, address, name);\n            }\n            catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) {\n                    return null;\n                }\n                return null;\n            }\n        });\n    }\n    _getResolver(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Get the resolver from the blockchain\n            const network = yield this.getNetwork();\n            // No ENS...\n            if (!network.ensAddress) {\n                logger.throwError(\"network does not support ENS\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"ENS\", network: network.name });\n            }\n            // keccak256(\"resolver(bytes32)\")\n            const transaction = {\n                to: network.ensAddress,\n                data: (\"0x0178b8bf\" + namehash(name).substring(2))\n            };\n            try {\n                return this.formatter.callAddress(yield this.call(transaction));\n            }\n            catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) {\n                    return null;\n                }\n                throw error;\n            }\n        });\n    }\n    resolveName(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            name = yield name;\n            // If it is already an address, nothing to resolve\n            try {\n                return Promise.resolve(this.formatter.address(name));\n            }\n            catch (error) {\n                // If is is a hexstring, the address is bad (See #694)\n                if (isHexString(name)) {\n                    throw error;\n                }\n            }\n            if (typeof (name) !== \"string\") {\n                logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n            }\n            // Get the addr from the resovler\n            const resolver = yield this.getResolver(name);\n            if (!resolver) {\n                return null;\n            }\n            return yield resolver.getAddress();\n        });\n    }\n    lookupAddress(address) {\n        return __awaiter(this, void 0, void 0, function* () {\n            address = yield address;\n            address = this.formatter.address(address);\n            const reverseName = address.substring(2).toLowerCase() + \".addr.reverse\";\n            const resolverAddress = yield this._getResolver(reverseName);\n            if (!resolverAddress) {\n                return null;\n            }\n            // keccak(\"name(bytes32)\")\n            let bytes = arrayify(yield this.call({\n                to: resolverAddress,\n                data: (\"0x691f3431\" + namehash(reverseName).substring(2))\n            }));\n            // Strip off the dynamic string pointer (0x20)\n            if (bytes.length < 32 || !BigNumber.from(bytes.slice(0, 32)).eq(32)) {\n                return null;\n            }\n            bytes = bytes.slice(32);\n            // Not a length-prefixed string\n            if (bytes.length < 32) {\n                return null;\n            }\n            // Get the length of the string (from the length-prefix)\n            const length = BigNumber.from(bytes.slice(0, 32)).toNumber();\n            bytes = bytes.slice(32);\n            // Length longer than available data\n            if (length > bytes.length) {\n                return null;\n            }\n            const name = toUtf8String(bytes.slice(0, length));\n            // Make sure the reverse record matches the foward record\n            const addr = yield this.resolveName(name);\n            if (addr != address) {\n                return null;\n            }\n            return name;\n        });\n    }\n    getAvatar(nameOrAddress) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let resolver = null;\n            if (isHexString(nameOrAddress)) {\n                // Address; reverse lookup\n                const address = this.formatter.address(nameOrAddress);\n                const reverseName = address.substring(2).toLowerCase() + \".addr.reverse\";\n                const resolverAddress = yield this._getResolver(reverseName);\n                if (!resolverAddress) {\n                    return null;\n                }\n                resolver = new Resolver(this, resolverAddress, \"_\", address);\n            }\n            else {\n                // ENS name; forward lookup\n                resolver = yield this.getResolver(nameOrAddress);\n            }\n            const avatar = yield resolver.getAvatar();\n            if (avatar == null) {\n                return null;\n            }\n            return avatar.url;\n        });\n    }\n    perform(method, params) {\n        return logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n    }\n    _startEvent(event) {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n    _stopEvent(event) {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n    _addEventListener(eventName, listener, once) {\n        const event = new Event(getEventTag(eventName), listener, once);\n        this._events.push(event);\n        this._startEvent(event);\n        return this;\n    }\n    on(eventName, listener) {\n        return this._addEventListener(eventName, listener, false);\n    }\n    once(eventName, listener) {\n        return this._addEventListener(eventName, listener, true);\n    }\n    emit(eventName, ...args) {\n        let result = false;\n        let stopped = [];\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag) {\n                return true;\n            }\n            setTimeout(() => {\n                event.listener.apply(this, args);\n            }, 0);\n            result = true;\n            if (event.once) {\n                stopped.push(event);\n                return false;\n            }\n            return true;\n        });\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return result;\n    }\n    listenerCount(eventName) {\n        if (!eventName) {\n            return this._events.length;\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event) => {\n            return (event.tag === eventTag);\n        }).length;\n    }\n    listeners(eventName) {\n        if (eventName == null) {\n            return this._events.map((event) => event.listener);\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events\n            .filter((event) => (event.tag === eventTag))\n            .map((event) => event.listener);\n    }\n    off(eventName, listener) {\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n        const stopped = [];\n        let found = false;\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag || event.listener != listener) {\n                return true;\n            }\n            if (found) {\n                return true;\n            }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return this;\n    }\n    removeAllListeners(eventName) {\n        let stopped = [];\n        if (eventName == null) {\n            stopped = this._events;\n            this._events = [];\n        }\n        else {\n            const eventTag = getEventTag(eventName);\n            this._events = this._events.filter((event) => {\n                if (event.tag !== eventTag) {\n                    return true;\n                }\n                stopped.push(event);\n                return false;\n            });\n        }\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return this;\n    }\n}\n//# sourceMappingURL=base-provider.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Signer } from \"@ethersproject/abstract-signer\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { hexlify, hexValue, isHexString } from \"@ethersproject/bytes\";\nimport { _TypedDataEncoder } from \"@ethersproject/hash\";\nimport { checkProperties, deepCopy, defineReadOnly, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { accessListify } from \"@ethersproject/transactions\";\nimport { fetchJson, poll } from \"@ethersproject/web\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { BaseProvider } from \"./base-provider\";\nconst errorGas = [\"call\", \"estimateGas\"];\nfunction checkError(method, error, params) {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === Logger.errors.SERVER_ERROR) {\n        const e = error.error;\n        if (e && e.message.match(\"reverted\") && isHexString(e.data)) {\n            return e.data;\n        }\n        logger.throwError(\"missing revert data in call exception\", Logger.errors.CALL_EXCEPTION, {\n            error, data: \"0x\"\n        });\n    }\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof (error.error.message) === \"string\") {\n        message = error.error.message;\n    }\n    else if (typeof (error.body) === \"string\") {\n        message = error.body;\n    }\n    else if (typeof (error.responseText) === \"string\") {\n        message = error.responseText;\n    }\n    message = (message || \"\").toLowerCase();\n    const transaction = params.transaction || params.signedTransaction;\n    // \"insufficient funds for gas * price + value + cost(data)\"\n    if (message.match(/insufficient funds|base fee exceeds gas limit/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n            error, method, transaction\n        });\n    }\n    // \"nonce too low\"\n    if (message.match(/nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n            error, method, transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/replacement transaction underpriced/)) {\n        logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/only replay-protected/)) {\n        logger.throwError(\"legacy pre-eip-155 transactions not supported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            error, method, transaction\n        });\n    }\n    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n    throw error;\n}\nfunction timer(timeout) {\n    return new Promise(function (resolve) {\n        setTimeout(resolve, timeout);\n    });\n}\nfunction getResult(payload) {\n    if (payload.error) {\n        // @TODO: not any\n        const error = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n    return payload.result;\n}\nfunction getLowerCase(value) {\n    if (value) {\n        return value.toLowerCase();\n    }\n    return value;\n}\nconst _constructorGuard = {};\nexport class JsonRpcSigner extends Signer {\n    constructor(constructorGuard, provider, addressOrIndex) {\n        logger.checkNew(new.target, JsonRpcSigner);\n        super();\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n        }\n        defineReadOnly(this, \"provider\", provider);\n        if (addressOrIndex == null) {\n            addressOrIndex = 0;\n        }\n        if (typeof (addressOrIndex) === \"string\") {\n            defineReadOnly(this, \"_address\", this.provider.formatter.address(addressOrIndex));\n            defineReadOnly(this, \"_index\", null);\n        }\n        else if (typeof (addressOrIndex) === \"number\") {\n            defineReadOnly(this, \"_index\", addressOrIndex);\n            defineReadOnly(this, \"_address\", null);\n        }\n        else {\n            logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n        }\n    }\n    connect(provider) {\n        return logger.throwError(\"cannot alter JSON-RPC Signer connection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"connect\"\n        });\n    }\n    connectUnchecked() {\n        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n    }\n    getAddress() {\n        if (this._address) {\n            return Promise.resolve(this._address);\n        }\n        return this.provider.send(\"eth_accounts\", []).then((accounts) => {\n            if (accounts.length <= this._index) {\n                logger.throwError(\"unknown account #\" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"getAddress\"\n                });\n            }\n            return this.provider.formatter.address(accounts[this._index]);\n        });\n    }\n    sendUncheckedTransaction(transaction) {\n        transaction = shallowCopy(transaction);\n        const fromAddress = this.getAddress().then((address) => {\n            if (address) {\n                address = address.toLowerCase();\n            }\n            return address;\n        });\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (transaction.gasLimit == null) {\n            const estimate = shallowCopy(transaction);\n            estimate.from = fromAddress;\n            transaction.gasLimit = this.provider.estimateGas(estimate);\n        }\n        if (transaction.to != null) {\n            transaction.to = Promise.resolve(transaction.to).then((to) => __awaiter(this, void 0, void 0, function* () {\n                if (to == null) {\n                    return null;\n                }\n                const address = yield this.provider.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            }));\n        }\n        return resolveProperties({\n            tx: resolveProperties(transaction),\n            sender: fromAddress\n        }).then(({ tx, sender }) => {\n            if (tx.from != null) {\n                if (tx.from.toLowerCase() !== sender) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n            }\n            else {\n                tx.from = sender;\n            }\n            const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });\n            return this.provider.send(\"eth_sendTransaction\", [hexTx]).then((hash) => {\n                return hash;\n            }, (error) => {\n                return checkError(\"sendTransaction\", error, hexTx);\n            });\n        });\n    }\n    signTransaction(transaction) {\n        return logger.throwError(\"signing transactions is unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"signTransaction\"\n        });\n    }\n    sendTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // This cannot be mined any earlier than any recent block\n            const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);\n            // Send the transaction\n            const hash = yield this.sendUncheckedTransaction(transaction);\n            try {\n                // Unfortunately, JSON-RPC only provides and opaque transaction hash\n                // for a response, and we need the actual transaction, so we poll\n                // for it; it should show up very quickly\n                return yield poll(() => __awaiter(this, void 0, void 0, function* () {\n                    const tx = yield this.provider.getTransaction(hash);\n                    if (tx === null) {\n                        return undefined;\n                    }\n                    return this.provider._wrapTransaction(tx, hash, blockNumber);\n                }), { oncePoll: this.provider });\n            }\n            catch (error) {\n                error.transactionHash = hash;\n                throw error;\n            }\n        });\n    }\n    signMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = ((typeof (message) === \"string\") ? toUtf8Bytes(message) : message);\n            const address = yield this.getAddress();\n            return yield this.provider.send(\"personal_sign\", [hexlify(data), address.toLowerCase()]);\n        });\n    }\n    _legacySignMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = ((typeof (message) === \"string\") ? toUtf8Bytes(message) : message);\n            const address = yield this.getAddress();\n            // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n            return yield this.provider.send(\"eth_sign\", [address.toLowerCase(), hexlify(data)]);\n        });\n    }\n    _signTypedData(domain, types, value) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Populate any ENS names (in-place)\n            const populated = yield _TypedDataEncoder.resolveNames(domain, types, value, (name) => {\n                return this.provider.resolveName(name);\n            });\n            const address = yield this.getAddress();\n            return yield this.provider.send(\"eth_signTypedData_v4\", [\n                address.toLowerCase(),\n                JSON.stringify(_TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n            ]);\n        });\n    }\n    unlock(password) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const provider = this.provider;\n            const address = yield this.getAddress();\n            return provider.send(\"personal_unlockAccount\", [address.toLowerCase(), password, null]);\n        });\n    }\n}\nclass UncheckedJsonRpcSigner extends JsonRpcSigner {\n    sendTransaction(transaction) {\n        return this.sendUncheckedTransaction(transaction).then((hash) => {\n            return {\n                hash: hash,\n                nonce: null,\n                gasLimit: null,\n                gasPrice: null,\n                data: null,\n                value: null,\n                chainId: null,\n                confirmations: 0,\n                from: null,\n                wait: (confirmations) => { return this.provider.waitForTransaction(hash, confirmations); }\n            };\n        });\n    }\n}\nconst allowedTransactionKeys = {\n    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true\n};\nexport class JsonRpcProvider extends BaseProvider {\n    constructor(url, network) {\n        logger.checkNew(new.target, JsonRpcProvider);\n        let networkOrReady = network;\n        // The network is unknown, query the JSON-RPC for it\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then((network) => {\n                        resolve(network);\n                    }, (error) => {\n                        reject(error);\n                    });\n                }, 0);\n            });\n        }\n        super(networkOrReady);\n        // Default URL\n        if (!url) {\n            url = getStatic(this.constructor, \"defaultUrl\")();\n        }\n        if (typeof (url) === \"string\") {\n            defineReadOnly(this, \"connection\", Object.freeze({\n                url: url\n            }));\n        }\n        else {\n            defineReadOnly(this, \"connection\", Object.freeze(shallowCopy(url)));\n        }\n        this._nextId = 42;\n    }\n    get _cache() {\n        if (this._eventLoopCache == null) {\n            this._eventLoopCache = {};\n        }\n        return this._eventLoopCache;\n    }\n    static defaultUrl() {\n        return \"http:/\\/localhost:8545\";\n    }\n    detectNetwork() {\n        if (!this._cache[\"detectNetwork\"]) {\n            this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n            // Clear this cache at the beginning of the next event loop\n            setTimeout(() => {\n                this._cache[\"detectNetwork\"] = null;\n            }, 0);\n        }\n        return this._cache[\"detectNetwork\"];\n    }\n    _uncachedDetectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield timer(0);\n            let chainId = null;\n            try {\n                chainId = yield this.send(\"eth_chainId\", []);\n            }\n            catch (error) {\n                try {\n                    chainId = yield this.send(\"net_version\", []);\n                }\n                catch (error) { }\n            }\n            if (chainId != null) {\n                const getNetwork = getStatic(this.constructor, \"getNetwork\");\n                try {\n                    return getNetwork(BigNumber.from(chainId).toNumber());\n                }\n                catch (error) {\n                    return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                        chainId: chainId,\n                        event: \"invalidNetwork\",\n                        serverError: error\n                    });\n                }\n            }\n            return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                event: \"noNetwork\"\n            });\n        });\n    }\n    getSigner(addressOrIndex) {\n        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n    }\n    getUncheckedSigner(addressOrIndex) {\n        return this.getSigner(addressOrIndex).connectUnchecked();\n    }\n    listAccounts() {\n        return this.send(\"eth_accounts\", []).then((accounts) => {\n            return accounts.map((a) => this.formatter.address(a));\n        });\n    }\n    send(method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: deepCopy(request),\n            provider: this\n        });\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        const cache = ([\"eth_chainId\", \"eth_blockNumber\"].indexOf(method) >= 0);\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n        const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: request,\n                response: result,\n                provider: this\n            });\n            return result;\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                error: error,\n                request: request,\n                provider: this\n            });\n            throw error;\n        });\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(() => {\n                this._cache[method] = null;\n            }, 0);\n        }\n        return result;\n    }\n    prepareRequest(method, params) {\n        switch (method) {\n            case \"getBlockNumber\":\n                return [\"eth_blockNumber\", []];\n            case \"getGasPrice\":\n                return [\"eth_gasPrice\", []];\n            case \"getBalance\":\n                return [\"eth_getBalance\", [getLowerCase(params.address), params.blockTag]];\n            case \"getTransactionCount\":\n                return [\"eth_getTransactionCount\", [getLowerCase(params.address), params.blockTag]];\n            case \"getCode\":\n                return [\"eth_getCode\", [getLowerCase(params.address), params.blockTag]];\n            case \"getStorageAt\":\n                return [\"eth_getStorageAt\", [getLowerCase(params.address), params.position, params.blockTag]];\n            case \"sendTransaction\":\n                return [\"eth_sendRawTransaction\", [params.signedTransaction]];\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return [\"eth_getBlockByNumber\", [params.blockTag, !!params.includeTransactions]];\n                }\n                else if (params.blockHash) {\n                    return [\"eth_getBlockByHash\", [params.blockHash, !!params.includeTransactions]];\n                }\n                return null;\n            case \"getTransaction\":\n                return [\"eth_getTransactionByHash\", [params.transactionHash]];\n            case \"getTransactionReceipt\":\n                return [\"eth_getTransactionReceipt\", [params.transactionHash]];\n            case \"call\": {\n                const hexlifyTransaction = getStatic(this.constructor, \"hexlifyTransaction\");\n                return [\"eth_call\", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];\n            }\n            case \"estimateGas\": {\n                const hexlifyTransaction = getStatic(this.constructor, \"hexlifyTransaction\");\n                return [\"eth_estimateGas\", [hexlifyTransaction(params.transaction, { from: true })]];\n            }\n            case \"getLogs\":\n                if (params.filter && params.filter.address != null) {\n                    params.filter.address = getLowerCase(params.filter.address);\n                }\n                return [\"eth_getLogs\", [params.filter]];\n            default:\n                break;\n        }\n        return null;\n    }\n    perform(method, params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Legacy networks do not like the type field being passed along (which\n            // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n            if (method === \"call\" || method === \"estimateGas\") {\n                const tx = params.transaction;\n                if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {\n                    // If there are no EIP-1559 properties, it might be non-EIP-a559\n                    if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                        const feeData = yield this.getFeeData();\n                        if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                            // Network doesn't know about EIP-1559 (and hence type)\n                            params = shallowCopy(params);\n                            params.transaction = shallowCopy(tx);\n                            delete params.transaction.type;\n                        }\n                    }\n                }\n            }\n            const args = this.prepareRequest(method, params);\n            if (args == null) {\n                logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n            }\n            try {\n                return yield this.send(args[0], args[1]);\n            }\n            catch (error) {\n                return checkError(method, error, params);\n            }\n        });\n    }\n    _startEvent(event) {\n        if (event.tag === \"pending\") {\n            this._startPending();\n        }\n        super._startEvent(event);\n    }\n    _startPending() {\n        if (this._pendingFilter != null) {\n            return;\n        }\n        const self = this;\n        const pendingFilter = this.send(\"eth_newPendingTransactionFilter\", []);\n        this._pendingFilter = pendingFilter;\n        pendingFilter.then(function (filterId) {\n            function poll() {\n                self.send(\"eth_getFilterChanges\", [filterId]).then(function (hashes) {\n                    if (self._pendingFilter != pendingFilter) {\n                        return null;\n                    }\n                    let seq = Promise.resolve();\n                    hashes.forEach(function (hash) {\n                        // @TODO: This should be garbage collected at some point... How? When?\n                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n                        seq = seq.then(function () {\n                            return self.getTransaction(hash).then(function (tx) {\n                                self.emit(\"pending\", tx);\n                                return null;\n                            });\n                        });\n                    });\n                    return seq.then(function () {\n                        return timer(1000);\n                    });\n                }).then(function () {\n                    if (self._pendingFilter != pendingFilter) {\n                        self.send(\"eth_uninstallFilter\", [filterId]);\n                        return;\n                    }\n                    setTimeout(function () { poll(); }, 0);\n                    return null;\n                }).catch((error) => { });\n            }\n            poll();\n            return filterId;\n        }).catch((error) => { });\n    }\n    _stopEvent(event) {\n        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n            this._pendingFilter = null;\n        }\n        super._stopEvent(event);\n    }\n    // Convert an ethers.js transaction into a JSON-RPC transaction\n    //  - gasLimit => gas\n    //  - All values hexlified\n    //  - All numeric values zero-striped\n    //  - All addresses are lowercased\n    // NOTE: This allows a TransactionRequest, but all values should be resolved\n    //       before this is called\n    // @TODO: This will likely be removed in future versions and prepareRequest\n    //        will be the preferred method for this.\n    static hexlifyTransaction(transaction, allowExtra) {\n        // Check only allowed properties are given\n        const allowed = shallowCopy(allowedTransactionKeys);\n        if (allowExtra) {\n            for (const key in allowExtra) {\n                if (allowExtra[key]) {\n                    allowed[key] = true;\n                }\n            }\n        }\n        checkProperties(transaction, allowed);\n        const result = {};\n        // Some nodes (INFURA ropsten; INFURA mainnet is fine) do not like leading zeros.\n        [\"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(function (key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            const value = hexValue(transaction[key]);\n            if (key === \"gasLimit\") {\n                key = \"gas\";\n            }\n            result[key] = value;\n        });\n        [\"from\", \"to\", \"data\"].forEach(function (key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            result[key] = hexlify(transaction[key]);\n        });\n        if (transaction.accessList) {\n            result[\"accessList\"] = accessListify(transaction.accessList);\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=json-rpc-provider.js.map","\"use strict\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nlet WS = null;\ntry {\n    WS = WebSocket;\n    if (WS == null) {\n        throw new Error(\"inject please\");\n    }\n}\ncatch (error) {\n    const logger = new Logger(version);\n    WS = function () {\n        logger.throwError(\"WebSockets not supported in this environment\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new WebSocket()\"\n        });\n    };\n}\n//export default WS;\n//module.exports = WS;\nexport { WS as WebSocket };\n//# sourceMappingURL=ws.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nimport { WebSocket } from \"./ws\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicates\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */\nlet NextId = 1;\n// For more info about the Real-time Event API see:\n//   https://geth.ethereum.org/docs/rpc/pubsub\nexport class WebSocketProvider extends JsonRpcProvider {\n    constructor(url, network) {\n        // This will be added in the future; please open an issue to expedite\n        if (network === \"any\") {\n            logger.throwError(\"WebSocketProvider does not support 'any' network yet\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"network:any\"\n            });\n        }\n        super(url, network);\n        this._pollingInterval = -1;\n        this._wsReady = false;\n        defineReadOnly(this, \"_websocket\", new WebSocket(this.connection.url));\n        defineReadOnly(this, \"_requests\", {});\n        defineReadOnly(this, \"_subs\", {});\n        defineReadOnly(this, \"_subIds\", {});\n        defineReadOnly(this, \"_detectNetwork\", super.detectNetwork());\n        // Stall sending requests until the socket is open...\n        this._websocket.onopen = () => {\n            this._wsReady = true;\n            Object.keys(this._requests).forEach((id) => {\n                this._websocket.send(this._requests[id].payload);\n            });\n        };\n        this._websocket.onmessage = (messageEvent) => {\n            const data = messageEvent.data;\n            const result = JSON.parse(data);\n            if (result.id != null) {\n                const id = String(result.id);\n                const request = this._requests[id];\n                delete this._requests[id];\n                if (result.result !== undefined) {\n                    request.callback(null, result.result);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: JSON.parse(request.payload),\n                        response: result.result,\n                        provider: this\n                    });\n                }\n                else {\n                    let error = null;\n                    if (result.error) {\n                        error = new Error(result.error.message || \"unknown error\");\n                        defineReadOnly(error, \"code\", result.error.code || null);\n                        defineReadOnly(error, \"response\", data);\n                    }\n                    else {\n                        error = new Error(\"unknown error\");\n                    }\n                    request.callback(error, undefined);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: JSON.parse(request.payload),\n                        provider: this\n                    });\n                }\n            }\n            else if (result.method === \"eth_subscription\") {\n                // Subscription...\n                const sub = this._subs[result.params.subscription];\n                if (sub) {\n                    //this.emit.apply(this,                  );\n                    sub.processFunc(result.params.result);\n                }\n            }\n            else {\n                console.warn(\"this should not happen\");\n            }\n        };\n        // This Provider does not actually poll, but we want to trigger\n        // poll events for things that depend on them (like stalling for\n        // block and transaction lookups)\n        const fauxPoll = setInterval(() => {\n            this.emit(\"poll\");\n        }, 1000);\n        if (fauxPoll.unref) {\n            fauxPoll.unref();\n        }\n    }\n    detectNetwork() {\n        return this._detectNetwork;\n    }\n    get pollingInterval() {\n        return 0;\n    }\n    resetEventsBlock(blockNumber) {\n        logger.throwError(\"cannot reset events block on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resetEventBlock\"\n        });\n    }\n    set pollingInterval(value) {\n        logger.throwError(\"cannot set polling interval on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPollingInterval\"\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return null;\n        });\n    }\n    set polling(value) {\n        if (!value) {\n            return;\n        }\n        logger.throwError(\"cannot set polling on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPolling\"\n        });\n    }\n    send(method, params) {\n        const rid = NextId++;\n        return new Promise((resolve, reject) => {\n            function callback(error, result) {\n                if (error) {\n                    return reject(error);\n                }\n                return resolve(result);\n            }\n            const payload = JSON.stringify({\n                method: method,\n                params: params,\n                id: rid,\n                jsonrpc: \"2.0\"\n            });\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: JSON.parse(payload),\n                provider: this\n            });\n            this._requests[String(rid)] = { callback, payload };\n            if (this._wsReady) {\n                this._websocket.send(payload);\n            }\n        });\n    }\n    static defaultUrl() {\n        return \"ws:/\\/localhost:8546\";\n    }\n    _subscribe(tag, param, processFunc) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let subIdPromise = this._subIds[tag];\n            if (subIdPromise == null) {\n                subIdPromise = Promise.all(param).then((param) => {\n                    return this.send(\"eth_subscribe\", param);\n                });\n                this._subIds[tag] = subIdPromise;\n            }\n            const subId = yield subIdPromise;\n            this._subs[subId] = { tag, processFunc };\n        });\n    }\n    _startEvent(event) {\n        switch (event.type) {\n            case \"block\":\n                this._subscribe(\"block\", [\"newHeads\"], (result) => {\n                    const blockNumber = BigNumber.from(result.number).toNumber();\n                    this._emitted.block = blockNumber;\n                    this.emit(\"block\", blockNumber);\n                });\n                break;\n            case \"pending\":\n                this._subscribe(\"pending\", [\"newPendingTransactions\"], (result) => {\n                    this.emit(\"pending\", result);\n                });\n                break;\n            case \"filter\":\n                this._subscribe(event.tag, [\"logs\", this._getFilter(event.filter)], (result) => {\n                    if (result.removed == null) {\n                        result.removed = false;\n                    }\n                    this.emit(event.filter, this.formatter.filterLog(result));\n                });\n                break;\n            case \"tx\": {\n                const emitReceipt = (event) => {\n                    const hash = event.hash;\n                    this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt) {\n                            return;\n                        }\n                        this.emit(hash, receipt);\n                    });\n                };\n                // In case it is already mined\n                emitReceipt(event);\n                // To keep things simple, we start up a single newHeads subscription\n                // to keep an eye out for transactions we are watching for.\n                // Starting a subscription for an event (i.e. \"tx\") that is already\n                // running is (basically) a nop.\n                this._subscribe(\"tx\", [\"newHeads\"], (result) => {\n                    this._events.filter((e) => (e.type === \"tx\")).forEach(emitReceipt);\n                });\n                break;\n            }\n            // Nothing is needed\n            case \"debug\":\n            case \"poll\":\n            case \"willPoll\":\n            case \"didPoll\":\n            case \"error\":\n                break;\n            default:\n                console.log(\"unhandled:\", event);\n                break;\n        }\n    }\n    _stopEvent(event) {\n        let tag = event.tag;\n        if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e) => (e.type === \"tx\")).length) {\n                return;\n            }\n            tag = \"tx\";\n        }\n        else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n        const subId = this._subIds[tag];\n        if (!subId) {\n            return;\n        }\n        delete this._subIds[tag];\n        subId.then((subId) => {\n            if (!this._subs[subId]) {\n                return;\n            }\n            delete this._subs[subId];\n            this.send(\"eth_unsubscribe\", [subId]);\n        });\n    }\n    destroy() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Wait until we have connected before trying to disconnect\n            if (this._websocket.readyState === WebSocket.CONNECTING) {\n                yield (new Promise((resolve) => {\n                    this._websocket.onopen = function () {\n                        resolve(true);\n                    };\n                    this._websocket.onerror = function () {\n                        resolve(false);\n                    };\n                }));\n            }\n            // Hangup\n            // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n            this._websocket.close(1000);\n        });\n    }\n}\n//# sourceMappingURL=websocket-provider.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { defineReadOnly, getStatic } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n// A StaticJsonRpcProvider is useful when you *know* for certain that\n// the backend will never change, as it never calls eth_chainId to\n// verify its backend. However, if the backend does change, the effects\n// are undefined and may include:\n// - inconsistent results\n// - locking up the UI\n// - block skew warnings\n// - wrong results\n// If the network is not explicit (i.e. auto-detection is expected), the\n// node MUST be running and available to respond to requests BEFORE this\n// is instantiated.\nexport class StaticJsonRpcProvider extends JsonRpcProvider {\n    detectNetwork() {\n        const _super = Object.create(null, {\n            detectNetwork: { get: () => super.detectNetwork }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            let network = this.network;\n            if (network == null) {\n                network = yield _super.detectNetwork.call(this);\n                if (!network) {\n                    logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, {});\n                }\n                // If still not set, set it\n                if (this._network == null) {\n                    // A static network does not support \"any\"\n                    defineReadOnly(this, \"_network\", network);\n                    this.emit(\"network\", network, null);\n                }\n            }\n            return network;\n        });\n    }\n}\nexport class UrlJsonRpcProvider extends StaticJsonRpcProvider {\n    constructor(network, apiKey) {\n        logger.checkAbstract(new.target, UrlJsonRpcProvider);\n        // Normalize the Network and API Key\n        network = getStatic(new.target, \"getNetwork\")(network);\n        apiKey = getStatic(new.target, \"getApiKey\")(apiKey);\n        const connection = getStatic(new.target, \"getUrl\")(network, apiKey);\n        super(connection, network);\n        if (typeof (apiKey) === \"string\") {\n            defineReadOnly(this, \"apiKey\", apiKey);\n        }\n        else if (apiKey != null) {\n            Object.keys(apiKey).forEach((key) => {\n                defineReadOnly(this, key, apiKey[key]);\n            });\n        }\n    }\n    _startPending() {\n        logger.warn(\"WARNING: API provider does not support pending filters\");\n    }\n    isCommunityResource() {\n        return false;\n    }\n    getSigner(address) {\n        return logger.throwError(\"API provider does not support signing\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"getSigner\" });\n    }\n    listAccounts() {\n        return Promise.resolve([]);\n    }\n    // Return a defaultApiKey if null, otherwise validate the API key\n    static getApiKey(apiKey) {\n        return apiKey;\n    }\n    // Returns the url or connection for the given network and API key. The\n    // API key will have been sanitized by the getApiKey first, so any validation\n    // or transformations can be done there.\n    static getUrl(network, apiKey) {\n        return logger.throwError(\"not implemented; sub-classes must override getUrl\", Logger.errors.NOT_IMPLEMENTED, {\n            operation: \"getUrl\"\n        });\n    }\n}\n//# sourceMappingURL=url-json-rpc-provider.js.map","\"use strict\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { showThrottleMessage } from \"./formatter\";\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n// This key was provided to ethers.js by Alchemy to be used by the\n// default provider, but it is recommended that for your own\n// production environments, that you acquire your own API key at:\n//   https://dashboard.alchemyapi.io\nconst defaultApiKey = \"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\";\nexport class AlchemyWebSocketProvider extends WebSocketProvider {\n    constructor(network, apiKey) {\n        const provider = new AlchemyProvider(network, apiKey);\n        const url = provider.connection.url.replace(/^http/i, \"ws\")\n            .replace(\".alchemyapi.\", \".ws.alchemyapi.\");\n        super(url, provider.network);\n        defineReadOnly(this, \"apiKey\", provider.apiKey);\n    }\n    isCommunityResource() {\n        return (this.apiKey === defaultApiKey);\n    }\n}\nexport class AlchemyProvider extends UrlJsonRpcProvider {\n    static getWebSocketProvider(network, apiKey) {\n        return new AlchemyWebSocketProvider(network, apiKey);\n    }\n    static getApiKey(apiKey) {\n        if (apiKey == null) {\n            return defaultApiKey;\n        }\n        if (apiKey && typeof (apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"eth-mainnet.alchemyapi.io/v2/\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.alchemyapi.io/v2/\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.alchemyapi.io/v2/\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.alchemyapi.io/v2/\";\n                break;\n            case \"kovan\":\n                host = \"eth-kovan.alchemyapi.io/v2/\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.g.alchemy.com/v2/\";\n                break;\n            default:\n                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n        return {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + apiKey),\n            throttleCallback: (attempt, url) => {\n                if (apiKey === defaultApiKey) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n    }\n    isCommunityResource() {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n//# sourceMappingURL=alchemy-provider.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport class CloudflareProvider extends UrlJsonRpcProvider {\n    static getApiKey(apiKey) {\n        if (apiKey != null) {\n            logger.throwArgumentError(\"apiKey not supported for cloudflare\", \"apiKey\", apiKey);\n        }\n        return null;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://cloudflare-eth.com/\";\n                break;\n            default:\n                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n        return host;\n    }\n    perform(method, params) {\n        const _super = Object.create(null, {\n            perform: { get: () => super.perform }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            // The Cloudflare provider does not support eth_blockNumber,\n            // so we get the latest block and pull it from that\n            if (method === \"getBlockNumber\") {\n                const block = yield _super.perform.call(this, \"getBlock\", { blockTag: \"latest\" });\n                return block.number;\n            }\n            return _super.perform.call(this, method, params);\n        });\n    }\n}\n//# sourceMappingURL=cloudflare-provider.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { hexlify, hexValue, isHexString } from \"@ethersproject/bytes\";\nimport { deepCopy, defineReadOnly } from \"@ethersproject/properties\";\nimport { accessListify } from \"@ethersproject/transactions\";\nimport { fetchJson } from \"@ethersproject/web\";\nimport { showThrottleMessage } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { BaseProvider } from \"./base-provider\";\n// The transaction has already been sanitized by the calls in Provider\nfunction getTransactionPostData(transaction) {\n    const result = {};\n    for (let key in transaction) {\n        if (transaction[key] == null) {\n            continue;\n        }\n        let value = transaction[key];\n        if (key === \"type\" && value === 0) {\n            continue;\n        }\n        // Quantity-types require no leading zero, unless 0\n        if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {\n            value = hexValue(hexlify(value));\n        }\n        else if (key === \"accessList\") {\n            value = \"[\" + accessListify(value).map((set) => {\n                return `{address:\"${set.address}\",storageKeys:[\"${set.storageKeys.join('\",\"')}\"]}`;\n            }).join(\",\") + \"]\";\n        }\n        else {\n            value = hexlify(value);\n        }\n        result[key] = value;\n    }\n    return result;\n}\nfunction getResult(result) {\n    // getLogs, getHistory have weird success responses\n    if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\n        return result.result;\n    }\n    if (result.status != 1 || result.message != \"OK\") {\n        const error = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        if ((result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n            error.throttleRetry = true;\n        }\n        throw error;\n    }\n    return result.result;\n}\nfunction getJsonResult(result) {\n    // This response indicates we are being throttled\n    if (result && result.status == 0 && result.message == \"NOTOK\" && (result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n        const error = new Error(\"throttled response\");\n        error.result = JSON.stringify(result);\n        error.throttleRetry = true;\n        throw error;\n    }\n    if (result.jsonrpc != \"2.0\") {\n        // @TODO: not any\n        const error = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        throw error;\n    }\n    if (result.error) {\n        // @TODO: not any\n        const error = new Error(result.error.message || \"unknown error\");\n        if (result.error.code) {\n            error.code = result.error.code;\n        }\n        if (result.error.data) {\n            error.data = result.error.data;\n        }\n        throw error;\n    }\n    return result.result;\n}\n// The blockTag was normalized as a string by the Provider pre-perform operations\nfunction checkLogTag(blockTag) {\n    if (blockTag === \"pending\") {\n        throw new Error(\"pending not supported\");\n    }\n    if (blockTag === \"latest\") {\n        return blockTag;\n    }\n    return parseInt(blockTag.substring(2), 16);\n}\nconst defaultApiKey = \"9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB\";\nfunction checkError(method, error, transaction) {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === Logger.errors.SERVER_ERROR) {\n        const e = error.error;\n        // Etherscan keeps changing their string\n        if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {\n            // Etherscan prefixes the data like \"Reverted 0x1234\"\n            let data = e.data;\n            if (data) {\n                data = \"0x\" + data.replace(/^.*0x/i, \"\");\n            }\n            if (isHexString(data)) {\n                return data;\n            }\n            logger.throwError(\"missing revert data in call exception\", Logger.errors.CALL_EXCEPTION, {\n                error, data: \"0x\"\n            });\n        }\n    }\n    // Get the message from any nested error structure\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR) {\n        if (error.error && typeof (error.error.message) === \"string\") {\n            message = error.error.message;\n        }\n        else if (typeof (error.body) === \"string\") {\n            message = error.body;\n        }\n        else if (typeof (error.responseText) === \"string\") {\n            message = error.responseText;\n        }\n    }\n    message = (message || \"\").toLowerCase();\n    // \"Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0\"\n    if (message.match(/insufficient funds/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n            error, method, transaction\n        });\n    }\n    // \"Transaction with the same hash was already imported.\"\n    if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n            error, method, transaction\n        });\n    }\n    // \"Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce.\"\n    if (message.match(/another transaction with same nonce/)) {\n        logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n        });\n    }\n    if (message.match(/execution failed due to an exception|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n    throw error;\n}\nexport class EtherscanProvider extends BaseProvider {\n    constructor(network, apiKey) {\n        logger.checkNew(new.target, EtherscanProvider);\n        super(network);\n        defineReadOnly(this, \"baseUrl\", this.getBaseUrl());\n        defineReadOnly(this, \"apiKey\", apiKey || defaultApiKey);\n    }\n    getBaseUrl() {\n        switch (this.network ? this.network.name : \"invalid\") {\n            case \"homestead\":\n                return \"https:/\\/api.etherscan.io\";\n            case \"ropsten\":\n                return \"https:/\\/api-ropsten.etherscan.io\";\n            case \"rinkeby\":\n                return \"https:/\\/api-rinkeby.etherscan.io\";\n            case \"kovan\":\n                return \"https:/\\/api-kovan.etherscan.io\";\n            case \"goerli\":\n                return \"https:/\\/api-goerli.etherscan.io\";\n            default:\n        }\n        return logger.throwArgumentError(\"unsupported network\", \"network\", name);\n    }\n    getUrl(module, params) {\n        const query = Object.keys(params).reduce((accum, key) => {\n            const value = params[key];\n            if (value != null) {\n                accum += `&${key}=${value}`;\n            }\n            return accum;\n        }, \"\");\n        const apiKey = ((this.apiKey) ? `&apikey=${this.apiKey}` : \"\");\n        return `${this.baseUrl}/api?module=${module}${query}${apiKey}`;\n    }\n    getPostUrl() {\n        return `${this.baseUrl}/api`;\n    }\n    getPostData(module, params) {\n        params.module = module;\n        params.apikey = this.apiKey;\n        return params;\n    }\n    fetch(module, params, post) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = (post ? this.getPostUrl() : this.getUrl(module, params));\n            const payload = (post ? this.getPostData(module, params) : null);\n            const procFunc = (module === \"proxy\") ? getJsonResult : getResult;\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: url,\n                provider: this\n            });\n            const connection = {\n                url: url,\n                throttleSlotInterval: 1000,\n                throttleCallback: (attempt, url) => {\n                    if (this.isCommunityResource()) {\n                        showThrottleMessage();\n                    }\n                    return Promise.resolve(true);\n                }\n            };\n            let payloadStr = null;\n            if (payload) {\n                connection.headers = { \"content-type\": \"application/x-www-form-urlencoded; charset=UTF-8\" };\n                payloadStr = Object.keys(payload).map((key) => {\n                    return `${key}=${payload[key]}`;\n                }).join(\"&\");\n            }\n            const result = yield fetchJson(connection, payloadStr, procFunc || getJsonResult);\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: url,\n                response: deepCopy(result),\n                provider: this\n            });\n            return result;\n        });\n    }\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.network;\n        });\n    }\n    perform(method, params) {\n        const _super = Object.create(null, {\n            perform: { get: () => super.perform }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            switch (method) {\n                case \"getBlockNumber\":\n                    return this.fetch(\"proxy\", { action: \"eth_blockNumber\" });\n                case \"getGasPrice\":\n                    return this.fetch(\"proxy\", { action: \"eth_gasPrice\" });\n                case \"getBalance\":\n                    // Returns base-10 result\n                    return this.fetch(\"account\", {\n                        action: \"balance\",\n                        address: params.address,\n                        tag: params.blockTag\n                    });\n                case \"getTransactionCount\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getTransactionCount\",\n                        address: params.address,\n                        tag: params.blockTag\n                    });\n                case \"getCode\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getCode\",\n                        address: params.address,\n                        tag: params.blockTag\n                    });\n                case \"getStorageAt\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getStorageAt\",\n                        address: params.address,\n                        position: params.position,\n                        tag: params.blockTag\n                    });\n                case \"sendTransaction\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_sendRawTransaction\",\n                        hex: params.signedTransaction\n                    }, true).catch((error) => {\n                        return checkError(\"sendTransaction\", error, params.signedTransaction);\n                    });\n                case \"getBlock\":\n                    if (params.blockTag) {\n                        return this.fetch(\"proxy\", {\n                            action: \"eth_getBlockByNumber\",\n                            tag: params.blockTag,\n                            boolean: (params.includeTransactions ? \"true\" : \"false\")\n                        });\n                    }\n                    throw new Error(\"getBlock by blockHash not implemented\");\n                case \"getTransaction\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getTransactionByHash\",\n                        txhash: params.transactionHash\n                    });\n                case \"getTransactionReceipt\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getTransactionReceipt\",\n                        txhash: params.transactionHash\n                    });\n                case \"call\": {\n                    if (params.blockTag !== \"latest\") {\n                        throw new Error(\"EtherscanProvider does not support blockTag for call\");\n                    }\n                    const postData = getTransactionPostData(params.transaction);\n                    postData.module = \"proxy\";\n                    postData.action = \"eth_call\";\n                    try {\n                        return yield this.fetch(\"proxy\", postData, true);\n                    }\n                    catch (error) {\n                        return checkError(\"call\", error, params.transaction);\n                    }\n                }\n                case \"estimateGas\": {\n                    const postData = getTransactionPostData(params.transaction);\n                    postData.module = \"proxy\";\n                    postData.action = \"eth_estimateGas\";\n                    try {\n                        return yield this.fetch(\"proxy\", postData, true);\n                    }\n                    catch (error) {\n                        return checkError(\"estimateGas\", error, params.transaction);\n                    }\n                }\n                case \"getLogs\": {\n                    const args = { action: \"getLogs\" };\n                    if (params.filter.fromBlock) {\n                        args.fromBlock = checkLogTag(params.filter.fromBlock);\n                    }\n                    if (params.filter.toBlock) {\n                        args.toBlock = checkLogTag(params.filter.toBlock);\n                    }\n                    if (params.filter.address) {\n                        args.address = params.filter.address;\n                    }\n                    // @TODO: We can handle slightly more complicated logs using the logs API\n                    if (params.filter.topics && params.filter.topics.length > 0) {\n                        if (params.filter.topics.length > 1) {\n                            logger.throwError(\"unsupported topic count\", Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\n                        }\n                        if (params.filter.topics.length === 1) {\n                            const topic0 = params.filter.topics[0];\n                            if (typeof (topic0) !== \"string\" || topic0.length !== 66) {\n                                logger.throwError(\"unsupported topic format\", Logger.errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\n                            }\n                            args.topic0 = topic0;\n                        }\n                    }\n                    const logs = yield this.fetch(\"logs\", args);\n                    // Cache txHash => blockHash\n                    let blocks = {};\n                    // Add any missing blockHash to the logs\n                    for (let i = 0; i < logs.length; i++) {\n                        const log = logs[i];\n                        if (log.blockHash != null) {\n                            continue;\n                        }\n                        if (blocks[log.blockNumber] == null) {\n                            const block = yield this.getBlock(log.blockNumber);\n                            if (block) {\n                                blocks[log.blockNumber] = block.hash;\n                            }\n                        }\n                        log.blockHash = blocks[log.blockNumber];\n                    }\n                    return logs;\n                }\n                case \"getEtherPrice\":\n                    if (this.network.name !== \"homestead\") {\n                        return 0.0;\n                    }\n                    return parseFloat((yield this.fetch(\"stats\", { action: \"ethprice\" })).ethusd);\n                default:\n                    break;\n            }\n            return _super.perform.call(this, method, params);\n        });\n    }\n    // Note: The `page` page parameter only allows pagination within the\n    //       10,000 window available without a page and offset parameter\n    //       Error: Result window is too large, PageNo x Offset size must\n    //              be less than or equal to 10000\n    getHistory(addressOrName, startBlock, endBlock) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const params = {\n                action: \"txlist\",\n                address: (yield this.resolveName(addressOrName)),\n                startblock: ((startBlock == null) ? 0 : startBlock),\n                endblock: ((endBlock == null) ? 99999999 : endBlock),\n                sort: \"asc\"\n            };\n            const result = yield this.fetch(\"account\", params);\n            return result.map((tx) => {\n                [\"contractAddress\", \"to\"].forEach(function (key) {\n                    if (tx[key] == \"\") {\n                        delete tx[key];\n                    }\n                });\n                if (tx.creates == null && tx.contractAddress != null) {\n                    tx.creates = tx.contractAddress;\n                }\n                const item = this.formatter.transactionResponse(tx);\n                if (tx.timeStamp) {\n                    item.timestamp = parseInt(tx.timeStamp);\n                }\n                return item;\n            });\n        });\n    }\n    isCommunityResource() {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n//# sourceMappingURL=etherscan-provider.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { shuffled } from \"@ethersproject/random\";\nimport { poll } from \"@ethersproject/web\";\nimport { BaseProvider } from \"./base-provider\";\nimport { isCommunityResource } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nfunction now() { return (new Date()).getTime(); }\n// Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\nfunction checkNetworks(networks) {\n    let result = null;\n    for (let i = 0; i < networks.length; i++) {\n        const network = networks[i];\n        // Null! We do not know our network; bail.\n        if (network == null) {\n            return null;\n        }\n        if (result) {\n            // Make sure the network matches the previous networks\n            if (!(result.name === network.name && result.chainId === network.chainId &&\n                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {\n                logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n            }\n        }\n        else {\n            result = network;\n        }\n    }\n    return result;\n}\nfunction median(values, maxDelta) {\n    values = values.slice().sort();\n    const middle = Math.floor(values.length / 2);\n    // Odd length; take the middle\n    if (values.length % 2) {\n        return values[middle];\n    }\n    // Even length; take the average of the two middle\n    const a = values[middle - 1], b = values[middle];\n    if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n        return null;\n    }\n    return (a + b) / 2;\n}\nfunction serialize(value) {\n    if (value === null) {\n        return \"null\";\n    }\n    else if (typeof (value) === \"number\" || typeof (value) === \"boolean\") {\n        return JSON.stringify(value);\n    }\n    else if (typeof (value) === \"string\") {\n        return value;\n    }\n    else if (BigNumber.isBigNumber(value)) {\n        return value.toString();\n    }\n    else if (Array.isArray(value)) {\n        return JSON.stringify(value.map((i) => serialize(i)));\n    }\n    else if (typeof (value) === \"object\") {\n        const keys = Object.keys(value);\n        keys.sort();\n        return \"{\" + keys.map((key) => {\n            let v = value[key];\n            if (typeof (v) === \"function\") {\n                v = \"[function]\";\n            }\n            else {\n                v = serialize(v);\n            }\n            return JSON.stringify(key) + \":\" + v;\n        }).join(\",\") + \"}\";\n    }\n    throw new Error(\"unknown value type: \" + typeof (value));\n}\n// Next request ID to use for emitting debug info\nlet nextRid = 1;\n;\nfunction stall(duration) {\n    let cancel = null;\n    let timer = null;\n    let promise = (new Promise((resolve) => {\n        cancel = function () {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            resolve();\n        };\n        timer = setTimeout(cancel, duration);\n    }));\n    const wait = (func) => {\n        promise = promise.then(func);\n        return promise;\n    };\n    function getPromise() {\n        return promise;\n    }\n    return { cancel, getPromise, wait };\n}\nconst ForwardErrors = [\n    Logger.errors.CALL_EXCEPTION,\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n    Logger.errors.UNPREDICTABLE_GAS_LIMIT\n];\nconst ForwardProperties = [\n    \"address\",\n    \"args\",\n    \"errorArgs\",\n    \"errorSignature\",\n    \"method\",\n    \"transaction\",\n];\n;\nfunction exposeDebugConfig(config, now) {\n    const result = {\n        weight: config.weight\n    };\n    Object.defineProperty(result, \"provider\", { get: () => config.provider });\n    if (config.start) {\n        result.start = config.start;\n    }\n    if (now) {\n        result.duration = (now - config.start);\n    }\n    if (config.done) {\n        if (config.error) {\n            result.error = config.error;\n        }\n        else {\n            result.result = config.result || null;\n        }\n    }\n    return result;\n}\nfunction normalizedTally(normalize, quorum) {\n    return function (configs) {\n        // Count the votes for each result\n        const tally = {};\n        configs.forEach((c) => {\n            const value = normalize(c.result);\n            if (!tally[value]) {\n                tally[value] = { count: 0, result: c.result };\n            }\n            tally[value].count++;\n        });\n        // Check for a quorum on any given result\n        const keys = Object.keys(tally);\n        for (let i = 0; i < keys.length; i++) {\n            const check = tally[keys[i]];\n            if (check.count >= quorum) {\n                return check.result;\n            }\n        }\n        // No quroum\n        return undefined;\n    };\n}\nfunction getProcessFunc(provider, method, params) {\n    let normalize = serialize;\n    switch (method) {\n        case \"getBlockNumber\":\n            // Return the median value, unless there is (median + 1) is also\n            // present, in which case that is probably true and the median\n            // is going to be stale soon. In the event of a malicious node,\n            // the lie will be true soon enough.\n            return function (configs) {\n                const values = configs.map((c) => c.result);\n                // Get the median block number\n                let blockNumber = median(configs.map((c) => c.result), 2);\n                if (blockNumber == null) {\n                    return undefined;\n                }\n                blockNumber = Math.ceil(blockNumber);\n                // If the next block height is present, its prolly safe to use\n                if (values.indexOf(blockNumber + 1) >= 0) {\n                    blockNumber++;\n                }\n                // Don't ever roll back the blockNumber\n                if (blockNumber >= provider._highestBlockNumber) {\n                    provider._highestBlockNumber = blockNumber;\n                }\n                return provider._highestBlockNumber;\n            };\n        case \"getGasPrice\":\n            // Return the middle (round index up) value, similar to median\n            // but do not average even entries and choose the higher.\n            // Malicious actors must compromise 50% of the nodes to lie.\n            return function (configs) {\n                const values = configs.map((c) => c.result);\n                values.sort();\n                return values[Math.floor(values.length / 2)];\n            };\n        case \"getEtherPrice\":\n            // Returns the median price. Malicious actors must compromise at\n            // least 50% of the nodes to lie (in a meaningful way).\n            return function (configs) {\n                return median(configs.map((c) => c.result));\n            };\n        // No additional normalizing required; serialize is enough\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n        case \"getStorageAt\":\n        case \"call\":\n        case \"estimateGas\":\n        case \"getLogs\":\n            break;\n        // We drop the confirmations from transactions as it is approximate\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            normalize = function (tx) {\n                if (tx == null) {\n                    return null;\n                }\n                tx = shallowCopy(tx);\n                tx.confirmations = -1;\n                return serialize(tx);\n            };\n            break;\n        // We drop the confirmations from transactions as it is approximate\n        case \"getBlock\":\n            // We drop the confirmations from transactions as it is approximate\n            if (params.includeTransactions) {\n                normalize = function (block) {\n                    if (block == null) {\n                        return null;\n                    }\n                    block = shallowCopy(block);\n                    block.transactions = block.transactions.map((tx) => {\n                        tx = shallowCopy(tx);\n                        tx.confirmations = -1;\n                        return tx;\n                    });\n                    return serialize(block);\n                };\n            }\n            else {\n                normalize = function (block) {\n                    if (block == null) {\n                        return null;\n                    }\n                    return serialize(block);\n                };\n            }\n            break;\n        default:\n            throw new Error(\"unknown method: \" + method);\n    }\n    // Return the result if and only if the expected quorum is\n    // satisfied and agreed upon for the final result.\n    return normalizedTally(normalize, provider.quorum);\n}\n// If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\nfunction waitForSync(config, blockNumber) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const provider = (config.provider);\n        if ((provider.blockNumber != null && provider.blockNumber >= blockNumber) || blockNumber === -1) {\n            return provider;\n        }\n        return poll(() => {\n            return new Promise((resolve, reject) => {\n                setTimeout(function () {\n                    // We are synced\n                    if (provider.blockNumber >= blockNumber) {\n                        return resolve(provider);\n                    }\n                    // We're done; just quit\n                    if (config.cancelled) {\n                        return resolve(null);\n                    }\n                    // Try again, next block\n                    return resolve(undefined);\n                }, 0);\n            });\n        }, { oncePoll: provider });\n    });\n}\nfunction getRunner(config, currentBlockNumber, method, params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let provider = config.provider;\n        switch (method) {\n            case \"getBlockNumber\":\n            case \"getGasPrice\":\n                return provider[method]();\n            case \"getEtherPrice\":\n                if (provider.getEtherPrice) {\n                    return provider.getEtherPrice();\n                }\n                break;\n            case \"getBalance\":\n            case \"getTransactionCount\":\n            case \"getCode\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider[method](params.address, params.blockTag || \"latest\");\n            case \"getStorageAt\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\");\n            case \"getBlock\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider[(params.includeTransactions ? \"getBlockWithTransactions\" : \"getBlock\")](params.blockTag || params.blockHash);\n            case \"call\":\n            case \"estimateGas\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider[method](params.transaction);\n            case \"getTransaction\":\n            case \"getTransactionReceipt\":\n                return provider[method](params.transactionHash);\n            case \"getLogs\": {\n                let filter = params.filter;\n                if ((filter.fromBlock && isHexString(filter.fromBlock)) || (filter.toBlock && isHexString(filter.toBlock))) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider.getLogs(filter);\n            }\n        }\n        return logger.throwError(\"unknown method error\", Logger.errors.UNKNOWN_ERROR, {\n            method: method,\n            params: params\n        });\n    });\n}\nexport class FallbackProvider extends BaseProvider {\n    constructor(providers, quorum) {\n        logger.checkNew(new.target, FallbackProvider);\n        if (providers.length === 0) {\n            logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n        }\n        const providerConfigs = providers.map((configOrProvider, index) => {\n            if (Provider.isProvider(configOrProvider)) {\n                const stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;\n                const priority = 1;\n                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });\n            }\n            const config = shallowCopy(configOrProvider);\n            if (config.priority == null) {\n                config.priority = 1;\n            }\n            if (config.stallTimeout == null) {\n                config.stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;\n            }\n            if (config.weight == null) {\n                config.weight = 1;\n            }\n            const weight = config.weight;\n            if (weight % 1 || weight > 512 || weight < 1) {\n                logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", `providers[${index}].weight`, weight);\n            }\n            return Object.freeze(config);\n        });\n        const total = providerConfigs.reduce((accum, c) => (accum + c.weight), 0);\n        if (quorum == null) {\n            quorum = total / 2;\n        }\n        else if (quorum > total) {\n            logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n        }\n        // Are all providers' networks are known\n        let networkOrReady = checkNetworks(providerConfigs.map((c) => (c.provider).network));\n        // Not all networks are known; we must stall\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then(resolve, reject);\n                }, 0);\n            });\n        }\n        super(networkOrReady);\n        // Preserve a copy, so we do not get mutated\n        defineReadOnly(this, \"providerConfigs\", Object.freeze(providerConfigs));\n        defineReadOnly(this, \"quorum\", quorum);\n        this._highestBlockNumber = -1;\n    }\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const networks = yield Promise.all(this.providerConfigs.map((c) => c.provider.getNetwork()));\n            return checkNetworks(networks);\n        });\n    }\n    perform(method, params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Sending transactions is special; always broadcast it to all backends\n            if (method === \"sendTransaction\") {\n                const results = yield Promise.all(this.providerConfigs.map((c) => {\n                    return c.provider.sendTransaction(params.signedTransaction).then((result) => {\n                        return result.hash;\n                    }, (error) => {\n                        return error;\n                    });\n                }));\n                // Any success is good enough (other errors are likely \"already seen\" errors\n                for (let i = 0; i < results.length; i++) {\n                    const result = results[i];\n                    if (typeof (result) === \"string\") {\n                        return result;\n                    }\n                }\n                // They were all an error; pick the first error\n                throw results[0];\n            }\n            // We need to make sure we are in sync with our backends, so we need\n            // to know this before we can make a lot of calls\n            if (this._highestBlockNumber === -1 && method !== \"getBlockNumber\") {\n                yield this.getBlockNumber();\n            }\n            const processFunc = getProcessFunc(this, method, params);\n            // Shuffle the providers and then sort them by their priority; we\n            // shallowCopy them since we will store the result in them too\n            const configs = shuffled(this.providerConfigs.map(shallowCopy));\n            configs.sort((a, b) => (a.priority - b.priority));\n            const currentBlockNumber = this._highestBlockNumber;\n            let i = 0;\n            let first = true;\n            while (true) {\n                const t0 = now();\n                // Compute the inflight weight (exclude anything past)\n                let inflightWeight = configs.filter((c) => (c.runner && ((t0 - c.start) < c.stallTimeout)))\n                    .reduce((accum, c) => (accum + c.weight), 0);\n                // Start running enough to meet quorum\n                while (inflightWeight < this.quorum && i < configs.length) {\n                    const config = configs[i++];\n                    const rid = nextRid++;\n                    config.start = now();\n                    config.staller = stall(config.stallTimeout);\n                    config.staller.wait(() => { config.staller = null; });\n                    config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {\n                        config.done = true;\n                        config.result = result;\n                        if (this.listenerCount(\"debug\")) {\n                            this.emit(\"debug\", {\n                                action: \"request\",\n                                rid: rid,\n                                backend: exposeDebugConfig(config, now()),\n                                request: { method: method, params: deepCopy(params) },\n                                provider: this\n                            });\n                        }\n                    }, (error) => {\n                        config.done = true;\n                        config.error = error;\n                        if (this.listenerCount(\"debug\")) {\n                            this.emit(\"debug\", {\n                                action: \"request\",\n                                rid: rid,\n                                backend: exposeDebugConfig(config, now()),\n                                request: { method: method, params: deepCopy(params) },\n                                provider: this\n                            });\n                        }\n                    });\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, null),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                    }\n                    inflightWeight += config.weight;\n                }\n                // Wait for anything meaningful to finish or stall out\n                const waiting = [];\n                configs.forEach((c) => {\n                    if (c.done || !c.runner) {\n                        return;\n                    }\n                    waiting.push(c.runner);\n                    if (c.staller) {\n                        waiting.push(c.staller.getPromise());\n                    }\n                });\n                if (waiting.length) {\n                    yield Promise.race(waiting);\n                }\n                // Check the quorum and process the results; the process function\n                // may additionally decide the quorum is not met\n                const results = configs.filter((c) => (c.done && c.error == null));\n                if (results.length >= this.quorum) {\n                    const result = processFunc(results);\n                    if (result !== undefined) {\n                        // Shut down any stallers\n                        configs.forEach(c => {\n                            if (c.staller) {\n                                c.staller.cancel();\n                            }\n                            c.cancelled = true;\n                        });\n                        return result;\n                    }\n                    if (!first) {\n                        yield stall(100).getPromise();\n                    }\n                    first = false;\n                }\n                // No result, check for errors that should be forwarded\n                const errors = configs.reduce((accum, c) => {\n                    if (!c.done || c.error == null) {\n                        return accum;\n                    }\n                    const code = (c.error).code;\n                    if (ForwardErrors.indexOf(code) >= 0) {\n                        if (!accum[code]) {\n                            accum[code] = { error: c.error, weight: 0 };\n                        }\n                        accum[code].weight += c.weight;\n                    }\n                    return accum;\n                }, ({}));\n                Object.keys(errors).forEach((errorCode) => {\n                    const tally = errors[errorCode];\n                    if (tally.weight < this.quorum) {\n                        return;\n                    }\n                    // Shut down any stallers\n                    configs.forEach(c => {\n                        if (c.staller) {\n                            c.staller.cancel();\n                        }\n                        c.cancelled = true;\n                    });\n                    const e = (tally.error);\n                    const props = {};\n                    ForwardProperties.forEach((name) => {\n                        if (e[name] == null) {\n                            return;\n                        }\n                        props[name] = e[name];\n                    });\n                    logger.throwError(e.reason || e.message, errorCode, props);\n                });\n                // All configs have run to completion; we will never get more data\n                if (configs.filter((c) => !c.done).length === 0) {\n                    break;\n                }\n            }\n            // Shut down any stallers; shouldn't be any\n            configs.forEach(c => {\n                if (c.staller) {\n                    c.staller.cancel();\n                }\n                c.cancelled = true;\n            });\n            return logger.throwError(\"failed to meet quorum\", Logger.errors.SERVER_ERROR, {\n                method: method,\n                params: params,\n                //results: configs.map((c) => c.result),\n                //errors: configs.map((c) => c.error),\n                results: configs.map((c) => exposeDebugConfig(c)),\n                provider: this\n            });\n        });\n    }\n}\n//# sourceMappingURL=fallback-provider.js.map","\"use strict\";\nconst IpcProvider = null;\nexport { IpcProvider };\n//# sourceMappingURL=ipc-provider.js.map","\"use strict\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { showThrottleMessage } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nconst defaultProjectId = \"84842078b09946638c03157f83405213\";\nexport class InfuraWebSocketProvider extends WebSocketProvider {\n    constructor(network, apiKey) {\n        const provider = new InfuraProvider(network, apiKey);\n        const connection = provider.connection;\n        if (connection.password) {\n            logger.throwError(\"INFURA WebSocket project secrets unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"InfuraProvider.getWebSocketProvider()\"\n            });\n        }\n        const url = connection.url.replace(/^http/i, \"ws\").replace(\"/v3/\", \"/ws/v3/\");\n        super(url, network);\n        defineReadOnly(this, \"apiKey\", provider.projectId);\n        defineReadOnly(this, \"projectId\", provider.projectId);\n        defineReadOnly(this, \"projectSecret\", provider.projectSecret);\n    }\n    isCommunityResource() {\n        return (this.projectId === defaultProjectId);\n    }\n}\nexport class InfuraProvider extends UrlJsonRpcProvider {\n    static getWebSocketProvider(network, apiKey) {\n        return new InfuraWebSocketProvider(network, apiKey);\n    }\n    static getApiKey(apiKey) {\n        const apiKeyObj = {\n            apiKey: defaultProjectId,\n            projectId: defaultProjectId,\n            projectSecret: null\n        };\n        if (apiKey == null) {\n            return apiKeyObj;\n        }\n        if (typeof (apiKey) === \"string\") {\n            apiKeyObj.projectId = apiKey;\n        }\n        else if (apiKey.projectSecret != null) {\n            logger.assertArgument((typeof (apiKey.projectId) === \"string\"), \"projectSecret requires a projectId\", \"projectId\", apiKey.projectId);\n            logger.assertArgument((typeof (apiKey.projectSecret) === \"string\"), \"invalid projectSecret\", \"projectSecret\", \"[REDACTED]\");\n            apiKeyObj.projectId = apiKey.projectId;\n            apiKeyObj.projectSecret = apiKey.projectSecret;\n        }\n        else if (apiKey.projectId) {\n            apiKeyObj.projectId = apiKey.projectId;\n        }\n        apiKeyObj.apiKey = apiKeyObj.projectId;\n        return apiKeyObj;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch (network ? network.name : \"unknown\") {\n            case \"homestead\":\n                host = \"mainnet.infura.io\";\n                break;\n            case \"ropsten\":\n                host = \"ropsten.infura.io\";\n                break;\n            case \"rinkeby\":\n                host = \"rinkeby.infura.io\";\n                break;\n            case \"kovan\":\n                host = \"kovan.infura.io\";\n                break;\n            case \"goerli\":\n                host = \"goerli.infura.io\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.infura.io\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.infura.io\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n        const connection = {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + \"/v3/\" + apiKey.projectId),\n            throttleCallback: (attempt, url) => {\n                if (apiKey.projectId === defaultProjectId) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret;\n        }\n        return connection;\n    }\n    isCommunityResource() {\n        return (this.projectId === defaultProjectId);\n    }\n}\n//# sourceMappingURL=infura-provider.js.map","import { deepCopy } from \"@ethersproject/properties\";\nimport { fetchJson } from \"@ethersproject/web\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n// Experimental\nexport class JsonRpcBatchProvider extends JsonRpcProvider {\n    send(method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n        if (this._pendingBatch == null) {\n            this._pendingBatch = [];\n        }\n        const inflightRequest = { request, resolve: null, reject: null };\n        const promise = new Promise((resolve, reject) => {\n            inflightRequest.resolve = resolve;\n            inflightRequest.reject = reject;\n        });\n        this._pendingBatch.push(inflightRequest);\n        if (!this._pendingBatchAggregator) {\n            // Schedule batch for next event loop + short duration\n            this._pendingBatchAggregator = setTimeout(() => {\n                // Get teh current batch and clear it, so new requests\n                // go into the next batch\n                const batch = this._pendingBatch;\n                this._pendingBatch = null;\n                this._pendingBatchAggregator = null;\n                // Get the request as an array of requests\n                const request = batch.map((inflight) => inflight.request);\n                this.emit(\"debug\", {\n                    action: \"requestBatch\",\n                    request: deepCopy(request),\n                    provider: this\n                });\n                return fetchJson(this.connection, JSON.stringify(request)).then((result) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: request,\n                        response: result,\n                        provider: this\n                    });\n                    // For each result, feed it to the correct Promise, depending\n                    // on whether it was a success or error\n                    batch.forEach((inflightRequest, index) => {\n                        const payload = result[index];\n                        if (payload.error) {\n                            const error = new Error(payload.error.message);\n                            error.code = payload.error.code;\n                            error.data = payload.error.data;\n                            inflightRequest.reject(error);\n                        }\n                        else {\n                            inflightRequest.resolve(payload.result);\n                        }\n                    });\n                }, (error) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: request,\n                        provider: this\n                    });\n                    batch.forEach((inflightRequest) => {\n                        inflightRequest.reject(error);\n                    });\n                });\n            }, 10);\n        }\n        return promise;\n    }\n}\n//# sourceMappingURL=json-rpc-batch-provider.js.map","/* istanbul ignore file */\n\"use strict\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n// Special API key provided by Nodesmith for ethers.js\nconst defaultApiKey = \"ETHERS_JS_SHARED\";\nexport class NodesmithProvider extends UrlJsonRpcProvider {\n    static getApiKey(apiKey) {\n        if (apiKey && typeof (apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey || defaultApiKey;\n    }\n    static getUrl(network, apiKey) {\n        logger.warn(\"NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.\");\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc\";\n                break;\n            case \"ropsten\":\n                host = \"https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc\";\n                break;\n            case \"rinkeby\":\n                host = \"https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc\";\n                break;\n            case \"goerli\":\n                host = \"https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc\";\n                break;\n            case \"kovan\":\n                host = \"https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc\";\n                break;\n            default:\n                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n        return (host + \"?apiKey=\" + apiKey);\n    }\n}\n//# sourceMappingURL=nodesmith-provider.js.map","\"use strict\";\nimport { getStatic } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n// These are load-balancer-based application IDs\nconst defaultApplicationIds = {\n    homestead: \"6004bcd10040261633ade990\",\n    ropsten: \"6004bd4d0040261633ade991\",\n    rinkeby: \"6004bda20040261633ade994\",\n    goerli: \"6004bd860040261633ade992\",\n};\nexport class PocketProvider extends UrlJsonRpcProvider {\n    constructor(network, apiKey) {\n        // We need a bit of creativity in the constructor because\n        // Pocket uses different default API keys based on the network\n        if (apiKey == null) {\n            const n = getStatic(new.target, \"getNetwork\")(network);\n            if (n) {\n                const applicationId = defaultApplicationIds[n.name];\n                if (applicationId) {\n                    apiKey = {\n                        applicationId: applicationId,\n                        loadBalancer: true\n                    };\n                }\n            }\n            // If there was any issue above, we don't know this network\n            if (apiKey == null) {\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n            }\n        }\n        super(network, apiKey);\n    }\n    static getApiKey(apiKey) {\n        // Most API Providers allow null to get the default configuration, but\n        // Pocket requires the network to decide the default provider, so we\n        // rely on hijacking the constructor to add a sensible default for us\n        if (apiKey == null) {\n            logger.throwArgumentError(\"PocketProvider.getApiKey does not support null apiKey\", \"apiKey\", apiKey);\n        }\n        const apiKeyObj = {\n            applicationId: null,\n            loadBalancer: false,\n            applicationSecretKey: null\n        };\n        // Parse applicationId and applicationSecretKey\n        if (typeof (apiKey) === \"string\") {\n            apiKeyObj.applicationId = apiKey;\n        }\n        else if (apiKey.applicationSecretKey != null) {\n            logger.assertArgument((typeof (apiKey.applicationId) === \"string\"), \"applicationSecretKey requires an applicationId\", \"applicationId\", apiKey.applicationId);\n            logger.assertArgument((typeof (apiKey.applicationSecretKey) === \"string\"), \"invalid applicationSecretKey\", \"applicationSecretKey\", \"[REDACTED]\");\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;\n            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;\n        }\n        else if (apiKey.applicationId) {\n            logger.assertArgument((typeof (apiKey.applicationId) === \"string\"), \"apiKey.applicationId must be a string\", \"apiKey.applicationId\", apiKey.applicationId);\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;\n        }\n        else {\n            logger.throwArgumentError(\"unsupported PocketProvider apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKeyObj;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch (network ? network.name : \"unknown\") {\n            case \"homestead\":\n                host = \"eth-mainnet.gateway.pokt.network\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.gateway.pokt.network\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.gateway.pokt.network\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.gateway.pokt.network\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n        let url = null;\n        if (apiKey.loadBalancer) {\n            url = `https:/\\/${host}/v1/lb/${apiKey.applicationId}`;\n        }\n        else {\n            url = `https:/\\/${host}/v1/${apiKey.applicationId}`;\n        }\n        const connection = { url };\n        // Initialize empty headers\n        connection.headers = {};\n        // Apply application secret key\n        if (apiKey.applicationSecretKey != null) {\n            connection.user = \"\";\n            connection.password = apiKey.applicationSecretKey;\n        }\n        return connection;\n    }\n    isCommunityResource() {\n        return (this.applicationId === defaultApplicationIds[this.network.name]);\n    }\n}\n//# sourceMappingURL=pocket-provider.js.map","\"use strict\";\nimport { deepCopy, defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nlet _nextId = 1;\nfunction buildWeb3LegacyFetcher(provider, sendFunc) {\n    const fetcher = \"Web3LegacyFetcher\";\n    return function (method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: (_nextId++),\n            jsonrpc: \"2.0\"\n        };\n        return new Promise((resolve, reject) => {\n            this.emit(\"debug\", {\n                action: \"request\",\n                fetcher,\n                request: deepCopy(request),\n                provider: this\n            });\n            sendFunc(request, (error, response) => {\n                if (error) {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        fetcher,\n                        error,\n                        request,\n                        provider: this\n                    });\n                    return reject(error);\n                }\n                this.emit(\"debug\", {\n                    action: \"response\",\n                    fetcher,\n                    request,\n                    response,\n                    provider: this\n                });\n                if (response.error) {\n                    const error = new Error(response.error.message);\n                    error.code = response.error.code;\n                    error.data = response.error.data;\n                    return reject(error);\n                }\n                resolve(response.result);\n            });\n        });\n    };\n}\nfunction buildEip1193Fetcher(provider) {\n    return function (method, params) {\n        if (params == null) {\n            params = [];\n        }\n        const request = { method, params };\n        this.emit(\"debug\", {\n            action: \"request\",\n            fetcher: \"Eip1193Fetcher\",\n            request: deepCopy(request),\n            provider: this\n        });\n        return provider.request(request).then((response) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                response,\n                provider: this\n            });\n            return response;\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                error,\n                provider: this\n            });\n            throw error;\n        });\n    };\n}\nexport class Web3Provider extends JsonRpcProvider {\n    constructor(provider, network) {\n        logger.checkNew(new.target, Web3Provider);\n        if (provider == null) {\n            logger.throwArgumentError(\"missing provider\", \"provider\", provider);\n        }\n        let path = null;\n        let jsonRpcFetchFunc = null;\n        let subprovider = null;\n        if (typeof (provider) === \"function\") {\n            path = \"unknown:\";\n            jsonRpcFetchFunc = provider;\n        }\n        else {\n            path = provider.host || provider.path || \"\";\n            if (!path && provider.isMetaMask) {\n                path = \"metamask\";\n            }\n            subprovider = provider;\n            if (provider.request) {\n                if (path === \"\") {\n                    path = \"eip-1193:\";\n                }\n                jsonRpcFetchFunc = buildEip1193Fetcher(provider);\n            }\n            else if (provider.sendAsync) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));\n            }\n            else if (provider.send) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));\n            }\n            else {\n                logger.throwArgumentError(\"unsupported provider\", \"provider\", provider);\n            }\n            if (!path) {\n                path = \"unknown:\";\n            }\n        }\n        super(path, network);\n        defineReadOnly(this, \"jsonRpcFetchFunc\", jsonRpcFetchFunc);\n        defineReadOnly(this, \"provider\", subprovider);\n    }\n    send(method, params) {\n        return this.jsonRpcFetchFunc(method, params);\n    }\n}\n//# sourceMappingURL=web3-provider.js.map","\"use strict\";\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { getNetwork } from \"@ethersproject/networks\";\nimport { BaseProvider, Resolver } from \"./base-provider\";\nimport { AlchemyProvider, AlchemyWebSocketProvider } from \"./alchemy-provider\";\nimport { CloudflareProvider } from \"./cloudflare-provider\";\nimport { EtherscanProvider } from \"./etherscan-provider\";\nimport { FallbackProvider } from \"./fallback-provider\";\nimport { IpcProvider } from \"./ipc-provider\";\nimport { InfuraProvider, InfuraWebSocketProvider } from \"./infura-provider\";\nimport { JsonRpcProvider, JsonRpcSigner } from \"./json-rpc-provider\";\nimport { JsonRpcBatchProvider } from \"./json-rpc-batch-provider\";\nimport { NodesmithProvider } from \"./nodesmith-provider\";\nimport { PocketProvider } from \"./pocket-provider\";\nimport { StaticJsonRpcProvider, UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Web3Provider } from \"./web3-provider\";\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { Formatter, isCommunityResourcable, isCommunityResource, showThrottleMessage } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n////////////////////////\n// Helper Functions\nfunction getDefaultProvider(network, options) {\n    if (network == null) {\n        network = \"homestead\";\n    }\n    // If passed a URL, figure out the right type of provider based on the scheme\n    if (typeof (network) === \"string\") {\n        // @TODO: Add support for IpcProvider; maybe if it ends in \".ipc\"?\n        // Handle http and ws (and their secure variants)\n        const match = network.match(/^(ws|http)s?:/i);\n        if (match) {\n            switch (match[1]) {\n                case \"http\":\n                    return new JsonRpcProvider(network);\n                case \"ws\":\n                    return new WebSocketProvider(network);\n                default:\n                    logger.throwArgumentError(\"unsupported URL scheme\", \"network\", network);\n            }\n        }\n    }\n    const n = getNetwork(network);\n    if (!n || !n._defaultProvider) {\n        logger.throwError(\"unsupported getDefaultProvider network\", Logger.errors.NETWORK_ERROR, {\n            operation: \"getDefaultProvider\",\n            network: network\n        });\n    }\n    return n._defaultProvider({\n        FallbackProvider,\n        AlchemyProvider,\n        CloudflareProvider,\n        EtherscanProvider,\n        InfuraProvider,\n        JsonRpcProvider,\n        NodesmithProvider,\n        PocketProvider,\n        Web3Provider,\n        IpcProvider,\n    }, options);\n}\n////////////////////////\n// Exports\nexport { \n// Abstract Providers (or Abstract-ish)\nProvider, BaseProvider, Resolver, UrlJsonRpcProvider, \n///////////////////////\n// Concrete Providers\nFallbackProvider, AlchemyProvider, AlchemyWebSocketProvider, CloudflareProvider, EtherscanProvider, InfuraProvider, InfuraWebSocketProvider, JsonRpcProvider, JsonRpcBatchProvider, NodesmithProvider, PocketProvider, StaticJsonRpcProvider, Web3Provider, WebSocketProvider, IpcProvider, \n///////////////////////\n// Signer\nJsonRpcSigner, \n///////////////////////\n// Functions\ngetDefaultProvider, getNetwork, isCommunityResource, isCommunityResourcable, showThrottleMessage, \n///////////////////////\n// Objects\nFormatter };\n//# sourceMappingURL=index.js.map"],"names":["version","logger","Logger","Formatter","constructor","checkNew","this","formats","getDefaultFormats","address","bind","bigNumber","blockTag","data","hash","hex","number","type","transaction","accessList","allowNull","blockHash","blockNumber","transactionIndex","confirmations","from","gasPrice","maxPriorityFeePerGas","maxFeePerGas","gasLimit","to","value","nonce","r","uint256","s","v","creates","raw","transactionRequest","receiptLog","transactionHash","topics","arrayOf","logIndex","receipt","contractAddress","root","gasUsed","logsBloom","logs","cumulativeGasUsed","effectiveGasPrice","status","block","parentHash","timestamp","difficulty","miner","extraData","transactions","baseFeePerGas","blockWithTransactions","shallowCopy","transactionResponse","filter","fromBlock","undefined","toBlock","filterLog","removed","boolean","allowFalsish","accessListify","toNumber","toLowerCase","Error","strict","substring","isHexString","throwArgumentError","result","length","getAddress","callAddress","hexDataSlice","getContractAddress","hexValue","hexDataLength","error","hexZeroPad","_block","format","author","_difficulty","check","gas","isZero","input","chainId","networkId","parseInt","replace","parse","byzantium","Array","isArray","map","static","object","key","checkKey","checkValue","nullValue","replaceValue","array","forEach","push","isCommunityResourcable","isCommunityResource","throttleMessage","showThrottleMessage","console","log","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","e","rejected","done","then","apply","checkTopic","topic","serializeTopics","slice","pop","unique","sorted","Object","keys","sort","join","getEventTag","eventName","indexOf","warn","getTime","Date","stall","duration","setTimeout","PollableEvents","Event","tag","listener","once","defineReadOnly","event","split","comps","pollable","coinInfos","symbol","p2pkh","p2sh","prefix","ilk","bytes32ify","toHexString","base58Encode","Base58","concat","sha2","matchers","RegExp","_parseString","_parseBytes","offset","Resolver","provider","name","resolvedAddress","formatter","_fetchBytes","selector","parameters","tx","hexConcat","namehash","call","code","_getAddress","coinType","hexBytes","coinInfo","String","throwError","operation","bytes","arrayify","match","words","unshift","getAvatar","linkage","avatar","getText","i","content","url","owner","_resolvedAddress","addr","tokenId","tokenOwner","balance","toString","metadataUrl","metadata","fetchJson","image","JSON","stringify","getContentHash","ipfs","swarm","keyBytes","hexlify","defaultFormatter","nextPollId","BaseProvider","network","super","_events","_emitted","getFormatter","anyNetwork","detectNetwork","_networkPromise","catch","_ready","knownNetwork","getStatic","emit","_maxInternalBlockNumber","_lastBlockNumber","_pollingInterval","_fastQueryDate","_network","ready","poll","_getInternalBlockNumber","maxAge","_internalBlockNumber","internalBlockNumber","respTime","reqTime","checkInternalBlockNumber","resolveProperties","perform","networkError","getNetwork","_setFastBlockNumber","pollId","runners","pollingInterval","Math","abs","makeError","previousBlockNumber","eventBlockNumber","runner","getTransactionReceipt","getLogs","all","resetEventsBlock","polling","currentNetwork","_fastBlockNumber","_fastBlockNumberPromise","detectedNetwork","_poller","setInterval","_bootstrapPoll","clearInterval","_getFastBlockNumber","now","getBlockNumber","waitForTransaction","timeout","_waitForTransaction","replaceable","cancelFuncs","alreadyDone","func","minedHandler","on","removeListener","lastBlockNumber","startBlock","scannedBlock","replaceHandler","getTransactionCount","mined","getTransaction","getBlockWithTransactions","ti","reason","eq","cancelled","replacement","_wrapTransaction","timer","unref","clearTimeout","getGasPrice","method","getBalance","addressOrName","params","_getBlockTag","getCode","getStorageAt","position","p","expectedHash","returnedHash","wait","confirms","sendTransaction","signedTransaction","hexTx","t","_getTransactionRequest","values","_getFilter","estimateGas","resolveName","_getBlock","blockHashOrBlockTag","includeTransactions","blockWithTxs","oncePoll","getBlock","getEtherPrice","getResolver","_getResolver","ensAddress","resolver","lookupAddress","reverseName","resolverAddress","nameOrAddress","_startEvent","_stopEvent","_addEventListener","args","stopped","eventTag","listenerCount","listeners","off","removeAllListeners","found","errorGas","checkError","message","body","responseText","getResult","payload","getLowerCase","_constructorGuard","JsonRpcSigner","Signer","constructorGuard","addressOrIndex","connect","connectUnchecked","UncheckedJsonRpcSigner","_address","_index","send","accounts","sendUncheckedTransaction","fromAddress","estimate","sender","hexlifyTransaction","signTransaction","signMessage","_legacySignMessage","_signTypedData","domain","types","populated","unlock","password","allowedTransactionKeys","JsonRpcProvider","networkOrReady","freeze","_nextId","_cache","_eventLoopCache","_uncachedDetectNetwork","serverError","getSigner","getUncheckedSigner","listAccounts","a","request","id","jsonrpc","action","deepCopy","cache","connection","response","prepareRequest","feeData","getFeeData","_startPending","_pendingFilter","self","pendingFilter","filterId","hashes","seq","allowExtra","allowed","checkProperties","WS","WebSocket","NextId","WebSocketProvider","_wsReady","_websocket","onopen","_requests","onmessage","messageEvent","callback","sub","_subs","subscription","processFunc","fauxPoll","_detectNetwork","rid","_subscribe","param","subIdPromise","_subIds","subId","emitReceipt","destroy","readyState","onerror","close","StaticJsonRpcProvider","_super","create","get","UrlJsonRpcProvider","apiKey","checkAbstract","defaultApiKey","AlchemyWebSocketProvider","AlchemyProvider","host","arguments","allowGzip","throttleCallback","attempt","CloudflareProvider","getTransactionPostData","maxFeePerGs","set","storageKeys","throttleRetry","getJsonResult","checkLogTag","EtherscanProvider","getBaseUrl","getUrl","module","query","reduce","accum","baseUrl","getPostUrl","getPostData","apikey","fetch","post","procFunc","throttleSlotInterval","payloadStr","headers","txhash","postData","topic0","blocks","parseFloat","ethusd","getHistory","endBlock","startblock","endblock","item","timeStamp","checkNetworks","networks","median","maxDelta","middle","floor","b","serialize","nextRid","cancel","promise","getPromise","ForwardErrors","ForwardProperties","exposeDebugConfig","config","weight","defineProperty","start","getProcessFunc","normalize","configs","c","ceil","_highestBlockNumber","quorum","tally","count","normalizedTally","waitForSync","getRunner","currentBlockNumber","FallbackProvider","providers","providerConfigs","configOrProvider","index","stallTimeout","priority","total","results","shuffle","first","t0","inflightWeight","staller","backend","waiting","race","errors","errorCode","props","IpcProvider","defaultProjectId","InfuraWebSocketProvider","InfuraProvider","projectId","projectSecret","apiKeyObj","assertArgument","argument","user","JsonRpcBatchProvider","_pendingBatch","inflightRequest","_pendingBatchAggregator","batch","inflight","NodesmithProvider","defaultApplicationIds","homestead","ropsten","rinkeby","goerli","PocketProvider","n","applicationId","loadBalancer","applicationSecretKey","buildWeb3LegacyFetcher","sendFunc","fetcher","Web3Provider","path","jsonRpcFetchFunc","subprovider","isMetaMask","buildEip1193Fetcher","sendAsync","getDefaultProvider","options","_defaultProvider"],"sourceRoot":""}