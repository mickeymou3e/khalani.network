{"version":3,"file":"static/chunks/8171.4cd8e74cf9d10b88.js","mappings":"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","sources":["webpack://_N_E/./node_modules/@ledgerhq/hw-transport/lib-es/Transport.js","webpack://_N_E/./node_modules/@ledgerhq/devices/lib-es/hid-framing.js","webpack://_N_E/./node_modules/@ledgerhq/devices/lib-es/index.js","webpack://_N_E/./node_modules/@ledgerhq/hw-transport-webusb/lib-es/webusb.js","webpack://_N_E/./node_modules/@ledgerhq/hw-transport-webusb/lib-es/TransportWebUSB.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport EventEmitter from \"events\";\nimport { TransportRaceCondition, TransportError, StatusCodes, getAltStatusMessage, TransportStatusError, } from \"@ledgerhq/errors\";\nexport { TransportError, TransportStatusError, StatusCodes, getAltStatusMessage };\n/**\n * The Transport class defines a generic interface for communicating with a Ledger hardware wallet.\n * There are different kind of transports based on the technology (channels like U2F, HID, Bluetooth, Webusb) and environment (Node, Web,...).\n * It is an abstract class that needs to be implemented.\n */\nexport default class Transport {\n    constructor() {\n        this.exchangeTimeout = 30000;\n        this.unresponsiveTimeout = 15000;\n        this.deviceModel = null;\n        this._events = new EventEmitter();\n        /**\n         * Send data to the device using the higher level API.\n         * @param {number} cla - The instruction class for the command.\n         * @param {number} ins - The instruction code for the command.\n         * @param {number} p1 - The first parameter for the instruction.\n         * @param {number} p2 - The second parameter for the instruction.\n         * @param {Buffer} data - The data to be sent. Defaults to an empty buffer.\n         * @param {Array<number>} statusList - A list of acceptable status codes for the response. Defaults to [StatusCodes.OK].\n         * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.\n         */\n        this.send = (cla, ins, p1, p2, data = Buffer.alloc(0), statusList = [StatusCodes.OK]) => __awaiter(this, void 0, void 0, function* () {\n            if (data.length >= 256) {\n                throw new TransportError(\"data.length exceed 256 bytes limit. Got: \" + data.length, \"DataLengthTooBig\");\n            }\n            const response = yield this.exchange(Buffer.concat([Buffer.from([cla, ins, p1, p2]), Buffer.from([data.length]), data]));\n            const sw = response.readUInt16BE(response.length - 2);\n            if (!statusList.some(s => s === sw)) {\n                throw new TransportStatusError(sw);\n            }\n            return response;\n        });\n        this.exchangeAtomicImpl = (f) => __awaiter(this, void 0, void 0, function* () {\n            if (this.exchangeBusyPromise) {\n                throw new TransportRaceCondition(\"An action was already pending on the Ledger device. Please deny or reconnect.\");\n            }\n            let resolveBusy;\n            const busyPromise = new Promise(r => {\n                resolveBusy = r;\n            });\n            this.exchangeBusyPromise = busyPromise;\n            let unresponsiveReached = false;\n            const timeout = setTimeout(() => {\n                unresponsiveReached = true;\n                this.emit(\"unresponsive\");\n            }, this.unresponsiveTimeout);\n            try {\n                const res = yield f();\n                if (unresponsiveReached) {\n                    this.emit(\"responsive\");\n                }\n                return res;\n            }\n            finally {\n                clearTimeout(timeout);\n                if (resolveBusy)\n                    resolveBusy();\n                this.exchangeBusyPromise = null;\n            }\n        });\n        this._appAPIlock = null;\n    }\n    /**\n     * Send data to the device using a low level API.\n     * It's recommended to use the \"send\" method for a higher level API.\n     * @param {Buffer} apdu - The data to send.\n     * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.\n     */\n    exchange(_apdu) {\n        throw new Error(\"exchange not implemented\");\n    }\n    /**\n     * Send apdus in batch to the device using a low level API.\n     * The default implementation is to call exchange for each apdu.\n     * @param {Array<Buffer>} apdus - array of apdus to send.\n     * @param {Observer<Buffer>} observer - an observer that will receive the response of each apdu.\n     * @returns {Subscription} A Subscription object on which you can call \".unsubscribe()\" to stop sending apdus.\n     */\n    exchangeBulk(apdus, observer) {\n        let unsubscribed = false;\n        const unsubscribe = () => {\n            unsubscribed = true;\n        };\n        const main = () => __awaiter(this, void 0, void 0, function* () {\n            if (unsubscribed)\n                return;\n            for (const apdu of apdus) {\n                const r = yield this.exchange(apdu);\n                if (unsubscribed)\n                    return;\n                const status = r.readUInt16BE(r.length - 2);\n                if (status !== StatusCodes.OK) {\n                    throw new TransportStatusError(status);\n                }\n                observer.next(r);\n            }\n        });\n        main().then(() => !unsubscribed && observer.complete(), e => !unsubscribed && observer.error(e));\n        return { unsubscribe };\n    }\n    /**\n     * Set the \"scramble key\" for the next data exchanges with the device.\n     * Each app can have a different scramble key and it is set internally during instantiation.\n     * @param {string} key - The scramble key to set.\n     * @deprecated This method is no longer needed for modern transports and should be migrated away from.\n     */\n    setScrambleKey(_key) { }\n    /**\n     * Close the connection with the device.\n     * @returns {Promise<void>} A promise that resolves when the transport is closed.\n     */\n    close() {\n        return Promise.resolve();\n    }\n    /**\n     * Listen for an event on the transport instance.\n     * Transport implementations may have specific events. Common events include:\n     * \"disconnect\" : triggered when the transport is disconnected.\n     * @param {string} eventName - The name of the event to listen for.\n     * @param {(...args: Array<any>) => any} cb - The callback function to be invoked when the event occurs.\n     */\n    on(eventName, cb) {\n        this._events.on(eventName, cb);\n    }\n    /**\n     * Stop listening to an event on an instance of transport.\n     */\n    off(eventName, cb) {\n        this._events.removeListener(eventName, cb);\n    }\n    emit(event, ...args) {\n        this._events.emit(event, ...args);\n    }\n    /**\n     * Enable or not logs of the binary exchange\n     */\n    setDebugMode() {\n        console.warn(\"setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.\");\n    }\n    /**\n     * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)\n     */\n    setExchangeTimeout(exchangeTimeout) {\n        this.exchangeTimeout = exchangeTimeout;\n    }\n    /**\n     * Define the delay before emitting \"unresponsive\" on an exchange that does not respond\n     */\n    setExchangeUnresponsiveTimeout(unresponsiveTimeout) {\n        this.unresponsiveTimeout = unresponsiveTimeout;\n    }\n    /**\n     * create() allows to open the first descriptor available or\n     * throw if there is none or if timeout is reached.\n     * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)\n     * @example\n    TransportFoo.create().then(transport => ...)\n     */\n    static create(openTimeout = 3000, listenTimeout) {\n        return new Promise((resolve, reject) => {\n            let found = false;\n            const sub = this.listen({\n                next: e => {\n                    found = true;\n                    if (sub)\n                        sub.unsubscribe();\n                    if (listenTimeoutId)\n                        clearTimeout(listenTimeoutId);\n                    this.open(e.descriptor, openTimeout).then(resolve, reject);\n                },\n                error: e => {\n                    if (listenTimeoutId)\n                        clearTimeout(listenTimeoutId);\n                    reject(e);\n                },\n                complete: () => {\n                    if (listenTimeoutId)\n                        clearTimeout(listenTimeoutId);\n                    if (!found) {\n                        reject(new TransportError(this.ErrorMessage_NoDeviceFound, \"NoDeviceFound\"));\n                    }\n                },\n            });\n            const listenTimeoutId = listenTimeout\n                ? setTimeout(() => {\n                    sub.unsubscribe();\n                    reject(new TransportError(this.ErrorMessage_ListenTimeout, \"ListenTimeout\"));\n                }, listenTimeout)\n                : null;\n        });\n    }\n    decorateAppAPIMethods(self, methods, scrambleKey) {\n        for (const methodName of methods) {\n            self[methodName] = this.decorateAppAPIMethod(methodName, self[methodName], self, scrambleKey);\n        }\n    }\n    decorateAppAPIMethod(methodName, f, ctx, scrambleKey) {\n        return (...args) => __awaiter(this, void 0, void 0, function* () {\n            const { _appAPIlock } = this;\n            if (_appAPIlock) {\n                return Promise.reject(new TransportError(\"Ledger Device is busy (lock \" + _appAPIlock + \")\", \"TransportLocked\"));\n            }\n            try {\n                this._appAPIlock = methodName;\n                this.setScrambleKey(scrambleKey);\n                return yield f.apply(ctx, args);\n            }\n            finally {\n                this._appAPIlock = null;\n            }\n        });\n    }\n}\nTransport.ErrorMessage_ListenTimeout = \"No Ledger device found (timeout)\";\nTransport.ErrorMessage_NoDeviceFound = \"No Ledger device found\";\n//# sourceMappingURL=Transport.js.map","import { TransportError } from \"@ledgerhq/errors\";\nconst Tag = 0x05;\nfunction asUInt16BE(value) {\n    const b = Buffer.alloc(2);\n    b.writeUInt16BE(value, 0);\n    return b;\n}\nconst initialAcc = {\n    data: Buffer.alloc(0),\n    dataLength: 0,\n    sequence: 0,\n};\n/**\n *\n */\nconst createHIDframing = (channel, packetSize) => {\n    return {\n        makeBlocks(apdu) {\n            let data = Buffer.concat([asUInt16BE(apdu.length), apdu]);\n            const blockSize = packetSize - 5;\n            const nbBlocks = Math.ceil(data.length / blockSize);\n            data = Buffer.concat([\n                data,\n                Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0),\n            ]);\n            const blocks = [];\n            for (let i = 0; i < nbBlocks; i++) {\n                const head = Buffer.alloc(5);\n                head.writeUInt16BE(channel, 0);\n                head.writeUInt8(Tag, 2);\n                head.writeUInt16BE(i, 3);\n                const chunk = data.slice(i * blockSize, (i + 1) * blockSize);\n                blocks.push(Buffer.concat([head, chunk]));\n            }\n            return blocks;\n        },\n        reduceResponse(acc, chunk) {\n            let { data, dataLength, sequence } = acc || initialAcc;\n            if (chunk.readUInt16BE(0) !== channel) {\n                throw new TransportError(\"Invalid channel\", \"InvalidChannel\");\n            }\n            if (chunk.readUInt8(2) !== Tag) {\n                throw new TransportError(\"Invalid tag\", \"InvalidTag\");\n            }\n            if (chunk.readUInt16BE(3) !== sequence) {\n                throw new TransportError(\"Invalid sequence\", \"InvalidSequence\");\n            }\n            if (!acc) {\n                dataLength = chunk.readUInt16BE(5);\n            }\n            sequence++;\n            const chunkData = chunk.slice(acc ? 5 : 7);\n            data = Buffer.concat([data, chunkData]);\n            if (data.length > dataLength) {\n                data = data.slice(0, dataLength);\n            }\n            return {\n                data,\n                dataLength,\n                sequence,\n            };\n        },\n        getReducedResult(acc) {\n            if (acc && acc.dataLength === acc.data.length) {\n                return acc.data;\n            }\n        },\n    };\n};\nexport default createHIDframing;\n//# sourceMappingURL=hid-framing.js.map","import semver from \"semver\";\n/**\n * The USB product IDs will be defined as MMII, encoding a model (MM) and an interface bitfield (II)\n *\n ** Model\n * Ledger Nano S : 0x10\n * Ledger Blue : 0x00\n * Ledger Nano X : 0x40\n *\n ** Interface support bitfield\n * Generic HID : 0x01\n * Keyboard HID : 0x02\n * U2F : 0x04\n * CCID : 0x08\n * WebUSB : 0x10\n */\nexport const IIGenericHID = 0x01;\nexport const IIKeyboardHID = 0x02;\nexport const IIU2F = 0x04;\nexport const IICCID = 0x08;\nexport const IIWebUSB = 0x10;\nexport var DeviceModelId;\n(function (DeviceModelId) {\n    DeviceModelId[\"blue\"] = \"blue\";\n    DeviceModelId[\"nanoS\"] = \"nanoS\";\n    DeviceModelId[\"nanoSP\"] = \"nanoSP\";\n    DeviceModelId[\"nanoX\"] = \"nanoX\";\n    DeviceModelId[\"stax\"] = \"stax\";\n})(DeviceModelId || (DeviceModelId = {}));\nconst devices = {\n    [DeviceModelId.blue]: {\n        id: DeviceModelId.blue,\n        productName: \"Ledger Blue\",\n        productIdMM: 0x00,\n        legacyUsbProductId: 0x0000,\n        usbOnly: true,\n        memorySize: 480 * 1024,\n        masks: [0x31000000, 0x31010000],\n        getBlockSize: (_firwareVersion) => 4 * 1024,\n    },\n    [DeviceModelId.nanoS]: {\n        id: DeviceModelId.nanoS,\n        productName: \"Ledger Nano S\",\n        productIdMM: 0x10,\n        legacyUsbProductId: 0x0001,\n        usbOnly: true,\n        memorySize: 320 * 1024,\n        masks: [0x31100000],\n        getBlockSize: (firmwareVersion) => { var _a; return semver.lt((_a = semver.coerce(firmwareVersion)) !== null && _a !== void 0 ? _a : \"\", \"2.0.0\") ? 4 * 1024 : 2 * 1024; },\n    },\n    [DeviceModelId.nanoSP]: {\n        id: DeviceModelId.nanoSP,\n        productName: \"Ledger Nano S Plus\",\n        productIdMM: 0x50,\n        legacyUsbProductId: 0x0005,\n        usbOnly: true,\n        memorySize: 1536 * 1024,\n        masks: [0x33100000],\n        getBlockSize: (_firmwareVersion) => 32,\n    },\n    [DeviceModelId.nanoX]: {\n        id: DeviceModelId.nanoX,\n        productName: \"Ledger Nano X\",\n        productIdMM: 0x40,\n        legacyUsbProductId: 0x0004,\n        usbOnly: false,\n        memorySize: 2 * 1024 * 1024,\n        masks: [0x33000000],\n        getBlockSize: (_firwareVersion) => 4 * 1024,\n        bluetoothSpec: [\n            {\n                serviceUuid: \"13d63400-2c97-0004-0000-4c6564676572\",\n                notifyUuid: \"13d63400-2c97-0004-0001-4c6564676572\",\n                writeUuid: \"13d63400-2c97-0004-0002-4c6564676572\",\n                writeCmdUuid: \"13d63400-2c97-0004-0003-4c6564676572\",\n            },\n        ],\n    },\n    [DeviceModelId.stax]: {\n        id: DeviceModelId.stax,\n        productName: \"Ledger Stax\",\n        productIdMM: 0x60,\n        legacyUsbProductId: 0x0006,\n        usbOnly: false,\n        memorySize: 1536 * 1024,\n        masks: [0x33200000],\n        getBlockSize: (_firmwareVersion) => 32,\n        bluetoothSpec: [\n            {\n                serviceUuid: \"13d63400-2c97-6004-0000-4c6564676572\",\n                notifyUuid: \"13d63400-2c97-6004-0001-4c6564676572\",\n                writeUuid: \"13d63400-2c97-6004-0002-4c6564676572\",\n                writeCmdUuid: \"13d63400-2c97-6004-0003-4c6564676572\",\n            },\n        ],\n    },\n};\nconst productMap = {\n    Blue: DeviceModelId.blue,\n    \"Nano S\": DeviceModelId.nanoS,\n    \"Nano S Plus\": DeviceModelId.nanoSP,\n    \"Nano X\": DeviceModelId.nanoX,\n    Stax: DeviceModelId.stax,\n};\nconst devicesList = Object.values(devices);\n/**\n *\n */\nexport const ledgerUSBVendorId = 0x2c97;\n/**\n *\n */\nexport const getDeviceModel = (id) => {\n    const info = devices[id];\n    if (!info)\n        throw new Error(\"device '\" + id + \"' does not exist\");\n    return info;\n};\n/**\n * Given a `targetId`, return the deviceModel associated to it,\n * based on the first two bytes.\n */\nexport const identifyTargetId = (targetId) => {\n    const deviceModel = devicesList.find(({ masks }) => masks.find(mask => (targetId & 0xffff0000) === mask));\n    return deviceModel;\n};\n/**\n *\n */\nexport const identifyUSBProductId = (usbProductId) => {\n    const legacy = devicesList.find(d => d.legacyUsbProductId === usbProductId);\n    if (legacy)\n        return legacy;\n    const mm = usbProductId >> 8;\n    const deviceModel = devicesList.find(d => d.productIdMM === mm);\n    return deviceModel;\n};\nexport const identifyProductName = (productName) => {\n    const deviceModel = devicesList.find(d => d.id === productMap[productName]);\n    return deviceModel;\n};\nconst bluetoothServices = [];\nconst serviceUuidToInfos = {};\nfor (const id in devices) {\n    const deviceModel = devices[id];\n    const { bluetoothSpec } = deviceModel;\n    if (bluetoothSpec) {\n        for (let i = 0; i < bluetoothSpec.length; i++) {\n            const spec = bluetoothSpec[i];\n            bluetoothServices.push(spec.serviceUuid);\n            serviceUuidToInfos[spec.serviceUuid] = serviceUuidToInfos[spec.serviceUuid.replace(/-/g, \"\")] = Object.assign({ deviceModel }, spec);\n        }\n    }\n}\n/**\n *\n */\nexport const getBluetoothServiceUuids = () => bluetoothServices;\n/**\n *\n */\nexport const getInfosForServiceUuid = (uuid) => serviceUuidToInfos[uuid.toLowerCase()];\n//# sourceMappingURL=index.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ledgerUSBVendorId } from \"@ledgerhq/devices\";\nconst ledgerDevices = [\n    {\n        vendorId: ledgerUSBVendorId,\n    },\n];\nexport function requestLedgerDevice() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const device = yield navigator.usb.requestDevice({\n            filters: ledgerDevices,\n        });\n        return device;\n    });\n}\nexport function getLedgerDevices() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const devices = yield navigator.usb.getDevices();\n        return devices.filter(d => d.vendorId === ledgerUSBVendorId);\n    });\n}\nexport function getFirstLedgerDevice() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const existingDevices = yield getLedgerDevices();\n        if (existingDevices.length > 0)\n            return existingDevices[0];\n        return requestLedgerDevice();\n    });\n}\nexport const isSupported = () => Promise.resolve(!!navigator && !!navigator.usb && typeof navigator.usb.getDevices === \"function\");\n//# sourceMappingURL=webusb.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport Transport from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/hid-framing\";\nimport { identifyUSBProductId } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportOpenUserCancelled, TransportInterfaceNotAvailable, TransportWebUSBGestureRequired, DisconnectedDeviceDuringOperation, DisconnectedDevice, } from \"@ledgerhq/errors\";\nimport { getLedgerDevices, getFirstLedgerDevice, requestLedgerDevice, isSupported } from \"./webusb\";\nconst configurationValue = 1;\nconst endpointNumber = 3;\n/**\n * WebUSB Transport implementation\n * @example\n * import TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\n * ...\n * TransportWebUSB.create().then(transport => ...)\n */\nexport default class TransportWebUSB extends Transport {\n    constructor(device, interfaceNumber) {\n        super();\n        this.channel = Math.floor(Math.random() * 0xffff);\n        this.packetSize = 64;\n        this._disconnectEmitted = false;\n        this._emitDisconnect = (e) => {\n            if (this._disconnectEmitted)\n                return;\n            this._disconnectEmitted = true;\n            this.emit(\"disconnect\", e);\n        };\n        this.device = device;\n        this.interfaceNumber = interfaceNumber;\n        this.deviceModel = identifyUSBProductId(device.productId);\n    }\n    /**\n     * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n     */\n    static request() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const device = yield requestLedgerDevice();\n            return TransportWebUSB.open(device);\n        });\n    }\n    /**\n     * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n     */\n    static openConnected() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const devices = yield getLedgerDevices();\n            if (devices.length === 0)\n                return null;\n            return TransportWebUSB.open(devices[0]);\n        });\n    }\n    /**\n     * Create a Ledger transport with a USBDevice\n     */\n    static open(device) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield device.open();\n            if (device.configuration === null) {\n                yield device.selectConfiguration(configurationValue);\n            }\n            yield gracefullyResetDevice(device);\n            const iface = device.configurations[0].interfaces.find(({ alternates }) => alternates.some(a => a.interfaceClass === 255));\n            if (!iface) {\n                throw new TransportInterfaceNotAvailable(\"No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.\");\n            }\n            const interfaceNumber = iface.interfaceNumber;\n            try {\n                yield device.claimInterface(interfaceNumber);\n            }\n            catch (e) {\n                yield device.close();\n                throw new TransportInterfaceNotAvailable(e.message);\n            }\n            const transport = new TransportWebUSB(device, interfaceNumber);\n            const onDisconnect = e => {\n                if (device === e.device) {\n                    // $FlowFixMe\n                    navigator.usb.removeEventListener(\"disconnect\", onDisconnect);\n                    transport._emitDisconnect(new DisconnectedDevice());\n                }\n            };\n            // $FlowFixMe\n            navigator.usb.addEventListener(\"disconnect\", onDisconnect);\n            return transport;\n        });\n    }\n    /**\n     * Release the transport device\n     */\n    close() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.exchangeBusyPromise;\n            yield this.device.releaseInterface(this.interfaceNumber);\n            yield gracefullyResetDevice(this.device);\n            yield this.device.close();\n        });\n    }\n    /**\n     * Exchange with the device using APDU protocol.\n     * @param apdu\n     * @returns a promise of apdu response\n     */\n    exchange(apdu) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const b = yield this.exchangeAtomicImpl(() => __awaiter(this, void 0, void 0, function* () {\n                const { channel, packetSize } = this;\n                log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n                const framing = hidFraming(channel, packetSize);\n                // Write...\n                const blocks = framing.makeBlocks(apdu);\n                for (let i = 0; i < blocks.length; i++) {\n                    yield this.device.transferOut(endpointNumber, blocks[i]);\n                }\n                // Read...\n                let result;\n                let acc;\n                while (!(result = framing.getReducedResult(acc))) {\n                    const r = yield this.device.transferIn(endpointNumber, packetSize);\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                    // @ts-ignore\n                    const buffer = Buffer.from(r.data.buffer);\n                    acc = framing.reduceResponse(acc, buffer);\n                }\n                log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n                return result;\n            })).catch(e => {\n                if (e && e.message && e.message.includes(\"disconnected\")) {\n                    this._emitDisconnect(e);\n                    throw new DisconnectedDeviceDuringOperation(e.message);\n                }\n                throw e;\n            });\n            return b;\n        });\n    }\n    setScrambleKey() { }\n}\n/**\n * Check if WebUSB transport is supported.\n */\nTransportWebUSB.isSupported = isSupported;\n/**\n * List the WebUSB devices that was previously authorized by the user.\n */\nTransportWebUSB.list = getLedgerDevices;\n/**\n * Actively listen to WebUSB devices and emit ONE device\n * that was either accepted before, if not it will trigger the native permission UI.\n *\n * Important: it must be called in the context of a UI click!\n */\nTransportWebUSB.listen = (observer) => {\n    let unsubscribed = false;\n    getFirstLedgerDevice().then(device => {\n        if (!unsubscribed) {\n            const deviceModel = identifyUSBProductId(device.productId);\n            observer.next({\n                type: \"add\",\n                descriptor: device,\n                deviceModel,\n            });\n            observer.complete();\n        }\n    }, error => {\n        if (window.DOMException && error instanceof window.DOMException && error.code === 18) {\n            observer.error(new TransportWebUSBGestureRequired(error.message));\n        }\n        else {\n            observer.error(new TransportOpenUserCancelled(error.message));\n        }\n    });\n    function unsubscribe() {\n        unsubscribed = true;\n    }\n    return {\n        unsubscribe,\n    };\n};\nfunction gracefullyResetDevice(device) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            yield device.reset();\n        }\n        catch (err) {\n            console.warn(err);\n        }\n    });\n}\n//# sourceMappingURL=TransportWebUSB.js.map"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","Transport","constructor","this","exchangeTimeout","unresponsiveTimeout","deviceModel","_events","send","cla","ins","p1","p2","data","Buffer","alloc","statusList","length","response","exchange","concat","from","sw","readUInt16BE","some","s","exchangeAtomicImpl","f","exchangeBusyPromise","resolveBusy","busyPromise","r","unresponsiveReached","timeout","setTimeout","emit","res","clearTimeout","_appAPIlock","_apdu","Error","exchangeBulk","apdus","observer","unsubscribed","apdu","status","main","complete","error","unsubscribe","setScrambleKey","_key","close","on","eventName","cb","off","removeListener","event","args","setDebugMode","console","warn","setExchangeTimeout","setExchangeUnresponsiveTimeout","static","openTimeout","listenTimeout","found","sub","listen","listenTimeoutId","open","descriptor","ErrorMessage_NoDeviceFound","ErrorMessage_ListenTimeout","decorateAppAPIMethods","self","methods","scrambleKey","methodName","decorateAppAPIMethod","ctx","asUInt16BE","b","writeUInt16BE","initialAcc","dataLength","sequence","channel","packetSize","makeBlocks","blockSize","nbBlocks","Math","ceil","fill","blocks","i","head","writeUInt8","chunk","slice","push","reduceResponse","acc","readUInt8","chunkData","getReducedResult","DeviceModelId","devices","blue","id","productName","productIdMM","legacyUsbProductId","usbOnly","memorySize","masks","getBlockSize","_firwareVersion","nanoS","firmwareVersion","_a","nanoSP","_firmwareVersion","nanoX","bluetoothSpec","serviceUuid","notifyUuid","writeUuid","writeCmdUuid","stax","devicesList","Object","values","identifyUSBProductId","usbProductId","legacy","find","d","mm","bluetoothServices","serviceUuidToInfos","spec","replace","assign","ledgerDevices","vendorId","requestLedgerDevice","navigator","usb","requestDevice","filters","getLedgerDevices","getDevices","filter","TransportWebUSB","device","interfaceNumber","super","floor","random","_disconnectEmitted","_emitDisconnect","productId","configuration","selectConfiguration","gracefullyResetDevice","iface","configurations","interfaces","alternates","a","interfaceClass","claimInterface","message","transport","onDisconnect","removeEventListener","addEventListener","releaseInterface","toString","framing","transferOut","transferIn","buffer","catch","includes","reset","err","isSupported","list","existingDevices","getFirstLedgerDevice","type","window","DOMException","code"],"sourceRoot":""}