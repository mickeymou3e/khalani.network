# config.py

import os
from urllib.parse import urljoin

# --- Project Paths ---
# Define the absolute path to your workspace.
# Option 1: Define it directly if it's fixed.
# WORKSPACE_BASE = "/path/to/your/astro_docs_pipeline_workspace" 
# Option 2: Or, derive it if this config file is in the workspace root.
WORKSPACE_BASE = os.path.dirname(os.path.abspath(__file__))

# --- DeepWiki Configuration ---
BASE_DEEPWIKI_URL = "https://deepwiki.com/tplr-ai/templar" # Confirmed from brief (ensure this is the correct one you want to use)
# The deepwiki_href of the page that should become the main index.mdx 
# (e.g., the content for '/' in your Astro site's documentation section)
# Example: If the "Overview" page at "/tplr-ai/templar/1-overview" is your main docs page.
ROOT_DEEPWIKI_PAGE_HREF = "/tplr-ai/templar/1-overview" 

# --- GitHub Repository Details (for resolving source links) ---
GITHUB_REPO_URL = "https://github.com/tplr-ai/templar" # e.g., "https://github.com/your-org/your-repo"
GITHUB_REF = "bb2fc2a9"  # Branch name, commit hash, or tag (e.g., "main", "develop", "v1.0.0", or a specific commit SHA like 'bb2fc2a9')

# GITHUB_BLOB_URL_PREFIX is constructed from the above to link to files at a specific ref
# e.g., "https://github.com/your-org/your-repo/blob/your-ref/"
if GITHUB_REPO_URL.endswith('/'):
    GITHUB_REPO_URL = GITHUB_REPO_URL[:-1]
GITHUB_BLOB_URL_PREFIX = f"{GITHUB_REPO_URL}/blob/{GITHUB_REF}/"
# For links that need line numbers, the pattern is typically GITHUB_BLOB_URL_PREFIX + filepath + #L<start_line>-L<end_line>

# --- Output Paths ---
# Where the structured JSON data from CDI will be saved
INGESTED_DATA_JSON_PATH = os.path.join(WORKSPACE_BASE, "ingested_deepwiki_data.json")

# The target directory where Starlight .mdx files will be generated by SPBCP
# This should be your Astro project's content directory, typically 'src/content/docs'
# For example: os.path.join(WORKSPACE_BASE, "my-astro-starlight-project", "src", "content", "docs")
TARGET_DOCS_DIR = " " 

# --- Selenium WebDriver Configuration ---
# Path to your ChromeDriver executable
# Example for macOS: "/Users/youruser/path/to/chromedriver-mac-arm64/chromedriver"
# Example for Linux: "/usr/local/bin/chromedriver"
# Example for Windows: "C:/path/to/chromedriver.exe"
CHROMEDRIVER_EXECUTABLE_PATH = " " # Please update this to your actual path

# Optional: Path to your Brave browser executable (if not using default Chrome/Chromium)
# Set to None or an empty string if you want Selenium to use the default Chrome/Chromium installation
BRAVE_EXECUTABLE_PATH = " " # Please update or set to None

# --- CDI Script Specific Configurations ---
# Minimum character length heuristic for a script payload to be considered a "full page"
MIN_PAGE_LEN_HEURISTIC = 500 # From your original script

# --- FILE_MAPPING_OVERRIDES (Optional - for exceptions to automated path/title generation) ---
# Allows specific overrides for page slugs, categories (parent paths), or titles.
# The automated logic will try to generate paths like /category/sub-category/page-slug
# Use this if the automated slug/path for a particular DeepWiki href isn't what you want.
#
# Format:
# FILE_MAPPING_OVERRIDES = {
#     "DEEPWIKI_HREF_PATH": {              # e.g., "/tplr-ai/templar/some-original-slug"
#         "target_astro_path": "/new/custom/path/for-this-page", # Overrides the auto-generated path
#         "title": "New Custom Title",                         # Overrides the title from navigation
#         "is_index": True                                   # Optionally mark if this should be an index.mdx for its path
#     },
#     "/tplr-ai/templar/old-name": { "target_astro_path": "/current/new-name" }
# }
# Since you mentioned you might not need this heavily, keeping it empty is fine.
# The script will primarily rely on automated path generation from navigation hierarchy.
FILE_MAPPING_OVERRIDES = {}

# --- SPBCP Script Specific Configurations ---
# Placeholder for any SPBCP specific configs if they arise.

# --- Utility Script Configurations ---
# Placeholder for any utility script specific configs.


# --- Helper function to ensure paths exist (optional, can be used by scripts) ---
def ensure_dir_exists(path_to_directory):
    if not os.path.exists(path_to_directory):
        os.makedirs(path_to_directory)
        print(f"Created directory: {path_to_directory}")
