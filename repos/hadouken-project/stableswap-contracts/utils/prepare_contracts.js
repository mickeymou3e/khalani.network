const fs = require('fs')
const path = require('path')
const glob = require('glob');

const CONTRACTS_DIR = '../contracts'
const INPUT_DIR = '../build/contracts'
const OUTPUT_DIR = '../prepared/contracts'

/**
 * To omit problem with incorrect gas calculation gas field,
 * generated by brownie is removed from abi's fields manually
 * 
 * @param {abi_field} description 
 * @returns abi_field
 */
function delete_gas(abi_field) {
  if (abi_field.type === "function" && abi_field.gas) {
    abi_field.gas = undefined;
  }

  return abi_field
}

/**
 * Vyper contract method's can operate only on static length array's and
 * have no inheritance what is different for Solidity contracts.
 * To have abi with dynamic length array's abi fields modified manually
 *  
 * @param {abi_field} description 
 * @returns abi_field
 */
function replace_static_array_type(abi_field) {
  if (["function", "event", "constructor"].includes(abi_field.type) && (abi_field.inputs || abi_field.outputs)) {
    let inputs = abi_field.inputs
    let outputs = abi_field.outputs

    if (abi_field.inputs) {
      inputs = abi_field.inputs.map(({ type, ...rest }) => ({
        type: type.replace(/\[[0-9]\]/g, '[]'),
        ...rest
      }))
    }
    if (abi_field.outputs) {
      outputs = abi_field.outputs.map(({ type, ...rest }) => ({
        type: type.replace(/\[[0-9]\]/g, '[]'),
        ...rest
      }))
    }

    return {
      ...abi_field,
      inputs,
      outputs
    }
  }

  return description
}


/**
 * Remove gas property from contract abi
 * @param {contractJSON} contractJSON 
 * @returns contractJSON
 */
function prepare_contract_json(contractJSON) {
  const contractMeta = JSON.parse(contractJSON);
  const { abi, ...rest } = contractMeta;

  const preparedAbi = prepare_contract_abi(abi)

  return JSON.stringify({ abi: preparedAbi, ...rest }, null, 2)
}

function prepare_contract_abi(abi) {

  const preparedAbi = abi.map(description => {
    description = delete_gas(description)

    return description
  })

  return preparedAbi
}

/**
 * Creates abi with dynamic length arrays inputs/outputs only
 * @param {contractJSON} contractJSON 
 * @returns abi
 */
function prepare_pool_template_json(contractJSON) {
  const contractMeta = JSON.parse(contractJSON);
  const { abi } = contractMeta;

  const preparedAbi = prepare_pool_template_abi(abi)

  return JSON.stringify(preparedAbi, null, 2)
}

/**
 * Creates abi with dynamic length arrays inputs/outputs only
 * @param {contractJSON} contractJSON 
 * @returns abi
 */
function prepare_pool_template_abi(abi) {
  const preparedAbi = abi.map(description => {
    description = delete_gas(description)
    description = replace_static_array_type(description)

    return description
  })

  return preparedAbi
}


function prepare_pool_template_n_abi(contractJSON) {
  const contractMeta = JSON.parse(contractJSON);
  const { abi, ...rest } = contractMeta;

  const preparedAbi = abi.map(description => {
    description = delete_gas(description)
    description = replace_static_array_type(description)

    return description
  })


  return JSON.stringify(preparedAbi, null, 2)
}


async function prepare_contracts() {
  /* brownie contracts dir containing vyper code */
  const contracts_dir = path.join(__dirname, CONTRACTS_DIR)

  /* compiled contracts dir containing abi's */
  const input_dir = path.join(__dirname, INPUT_DIR)

  /* temporary dir dedicated to abi's to include in client package  */
  const output_dir = path.join(__dirname, OUTPUT_DIR)

  const all_contract_filenames = fs.readdirSync(input_dir).filter(fn => fn.endsWith('.json'));

  if (!fs.existsSync(output_dir)) {
    fs.mkdirSync(output_dir, { recursive: true });
  }

  const contracts = fs.readdirSync(contracts_dir)

  /* 
     Pick abi's for all non-testing contracts and include them into the client package.
     Because brownie compile all contracts from contracts dirs is need to be filtered based on actual
     contract files.
     Pool's contract's are omitted in package interface to deployed contract's because interaction with
     Pool contract's is intended to be done through SwapTemplateBase interface
   */
  contracts.filter(dirname => !["pool-templates", "testing", "pools"].includes(dirname)).map(dirname => {
    glob(path.join(contracts_dir, dirname) + '/**/*.vy', {}, (err, files) => {
      const contracts_names = files.map(filename => filename.split('/').pop().split('.').shift())
      const contract_filenames = contracts_names.map(contract_name => {
        return all_contract_filenames.find(contract_filename => contract_filename.includes(contract_name))
      })

      contract_filenames.map(contract_filename => {
        const contract_abi = fs.readFileSync(path.join(input_dir, contract_filename))
        const prepared_contract_json = prepare_contract_json(contract_abi)
        fs.writeFileSync(path.join(output_dir, contract_filename), prepared_contract_json)
      })
    })
  })

  /* 
     Pick abi's for all non-testing contracts and include them into the client package.
     Because brownie compile all contracts from contracts dirs is need to be filtered based on actual
     contract files.
     Pool's contract's are omitted in package interface to deployed contract's because interaction with
     Pool contract's is intended to be done through SwapTemplateBase interface
   */
  contracts.filter(dirname => !["pool-templates", "testing", "pools"].includes(dirname)).map(dirname => {
    glob(path.join(contracts_dir, dirname) + '/**/*.sol', {}, (err, files) => {
      const contracts_names = files.map(filename => filename.split('/').pop().split('.').shift())
      const contract_filenames = contracts_names.map(contract_name => {
        return all_contract_filenames.find(contract_filename => {
          return contract_filename.toUpperCase().startsWith(contract_name.toUpperCase())
        })
      })
      contract_filenames.map(contract_filename => {
        const contract_json = fs.readFileSync(path.join(input_dir, contract_filename))
        fs.writeFileSync(path.join(output_dir, contract_filename), contract_json)
      })
    })
  })

  /*
    In pool-template contract's directory there are two type of contract's pool-template N-pool and pool interface.
    N-pool contract's are contract's which cover all possible token's count (like: 2pool, 3pool, 7pool) ,
    so compiled N-pool is interface to interact with real implementation of pool. So interaction with 3pool(DAI, USDT, USDC)
    and ex. BUSD pool (BUSD, USDT, USDC) is done through N-pool where N = 3
    Pool template is abstraction over  N-pool which instead of N count tokens in pool have dynamic length array 
  */
  contracts.filter(dirname => dirname === "pool-templates").map(dirname => {
    glob(path.join(contracts_dir, dirname) + '/**/*.vy', {}, (err, files) => {
      const contracts_names = files.map(filename => filename.split('/').pop().split('.').shift())

      const contract_filenames = contracts_names.map(contract_name => {
        return all_contract_filenames.find(contract_filename => contract_filename.toUpperCase().includes(contract_name.toUpperCase()))
      })

      contract_filenames.map(contract_filename => {
        const nPattern = '[2-8]'
        if (contract_filename.match(nPattern)) {
          const contract_json = (fs.readFileSync(path.join(input_dir, contract_filename))).toString()
          const prepared_contract_abi = prepare_contract_json(contract_json)
          fs.writeFileSync(path.join(output_dir, contract_filename), prepared_contract_abi)
        } else {
          const contract_json = (fs.readFileSync(path.join(input_dir, contract_filename))).toString()
          const prepared_contract_abi = prepare_pool_template_json(contract_json)
          fs.writeFileSync(path.join(output_dir, contract_filename), prepared_contract_abi)
        }
      })
    })
  })
}

module.exports = {
  prepare_contracts,
  prepare_contract_abi,
  prepare_contract_json
}