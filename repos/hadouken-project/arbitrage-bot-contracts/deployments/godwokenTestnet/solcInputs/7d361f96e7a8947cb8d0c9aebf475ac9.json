{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/ArbitrageSwap.sol": {
      "content": "pragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\nimport {IFlashLoanReceiver} from './interfaces/IFlashLoanReceiver.sol';\nimport {IYokaiRouter02} from './interfaces/IYokaiRouter02.sol';\nimport {ILendingPool} from './interfaces/ILendingPool.sol';\nimport {IVault} from './interfaces/IVault.sol';\nimport {IERC20} from './interfaces/IERC20.sol';\nimport {IAsset} from './interfaces/IAsset.sol';\nimport '@openzeppelin/contracts/utils/Strings.sol';\n\nimport {IWETH} from './interfaces/IWETH.sol';\n\ncontract ArbitrageSwap is IFlashLoanReceiver {\n  uint256 constant UINT256_MAX = type(uint256).max;\n  ILendingPool private lendingPool;\n  address private vaultAddress;\n  IWETH private WCKB;\n  IERC20 private pCKB;\n\n  enum SwapOrder {\n    HADOUKEN_FIRST,\n    YOKAI_FIRST\n  }\n\n  struct ArbitrageParams {\n    uint256 quoteAmount;\n    address baseTokenAddress;\n    address quoteTokenAddress;\n    SwapOrder order;\n    bytes batchSwapCalldata;\n    address yokaiPoolAddress;\n  }\n\n  constructor(\n    address _vaultAddress,\n    address lendingPoolAddress,\n    address pCKBAddress,\n    address WCKBAddress\n  ) public {\n    vaultAddress = _vaultAddress;\n    lendingPool = ILendingPool(lendingPoolAddress);\n    pCKB = IERC20(pCKBAddress);\n    WCKB = IWETH(WCKBAddress);\n  }\n\n  function arbitrage(ArbitrageParams memory arbitrageParams) external {\n    address[] memory tokens = new address[](1);\n    tokens[0] = arbitrageParams.quoteTokenAddress;\n\n    uint256[] memory amounts = new uint256[](1);\n    amounts[0] = arbitrageParams.quoteAmount;\n\n    uint256[] memory modes = new uint256[](1);\n    modes[0] = 0;\n\n    bytes memory params = abi.encode(msg.sender, arbitrageParams);\n\n    lendingPool.flashLoan(\n      address(this),\n      tokens,\n      amounts,\n      modes,\n      address(this),\n      params,\n      0\n    );\n  }\n\n  function swapYokai(\n    IERC20 buyToken,\n    IERC20 sellToken,\n    uint256 amount,\n    ArbitrageParams memory arbitrageParams\n  ) private {\n    address[] memory tokens = new address[](2);\n    tokens[0] = address(sellToken);\n    tokens[1] = address(buyToken);\n    sellToken.approve(arbitrageParams.yokaiPoolAddress, amount);\n    IYokaiRouter02 yokaiPool = IYokaiRouter02(arbitrageParams.yokaiPoolAddress);\n\n    if (address(buyToken) == address(pCKB)) {\n      tokens[1] = address(WCKB);\n      yokaiPool.swapExactTokensForETH(\n        amount,\n        0,\n        tokens,\n        address(this),\n        UINT256_MAX\n      );\n    } else if (address(sellToken) == address(pCKB)) {\n      tokens[0] = address(WCKB);\n      yokaiPool.swapExactETHForTokens{value: amount}(\n        0,\n        tokens,\n        address(this),\n        UINT256_MAX\n      );\n    } else {\n      yokaiPool.swapExactTokensForTokens(\n        amount,\n        0,\n        tokens,\n        address(this),\n        UINT256_MAX\n      );\n    }\n  }\n\n  function swapHadouken(\n    bytes memory batchSwapCalldata,\n    IERC20 sellToken\n  ) private {\n    sellToken.approve(vaultAddress, sellToken.balanceOf(address(this)));\n    (bool success, bytes memory result) = vaultAddress.call(batchSwapCalldata);\n    if (!success) {\n      assembly {\n        revert(add(result, 32), result)\n      }\n    }\n  }\n\n  function changeAmountInHadoukenCallData(\n    bytes memory batchSwapCalldata,\n    uint256 baseTokenBalance\n  ) public view returns (bytes memory) {\n    IVault.SwapKind kind;\n    IVault.BatchSwapStep[] memory swaps;\n    IAsset[] memory assets;\n    IVault.FundManagement memory funds;\n    int256[] memory limits;\n    uint256 deadline;\n    (kind, swaps, assets, funds, limits, deadline) = abi.decode(\n      batchSwapCalldata,\n      (\n        IVault.SwapKind,\n        IVault.BatchSwapStep[],\n        IAsset[],\n        IVault.FundManagement,\n        int256[],\n        uint256\n      )\n    );\n\n    uint256 totalIn = 0;\n    for (uint i = 0; i < swaps.length; i++) {\n      if (swaps[i].assetInIndex == 0) {\n        totalIn += swaps[i].amount;\n      }\n    }\n\n    if (totalIn > baseTokenBalance) {\n      swaps[0].amount -= totalIn - baseTokenBalance;\n    } else if (totalIn < baseTokenBalance) {\n      swaps[0].amount += baseTokenBalance - totalIn;\n    }\n\n    return abi.encode(kind, swaps, assets, funds, limits, deadline);\n  }\n\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external override returns (bool) {\n    address originalSender;\n    ArbitrageParams memory arbitrageParams;\n    (originalSender, arbitrageParams) = abi.decode(\n      params,\n      (address, ArbitrageParams)\n    );\n\n    IERC20 baseToken = IERC20(arbitrageParams.baseTokenAddress);\n    IERC20 quoteToken = IERC20(arbitrageParams.quoteTokenAddress);\n\n    if (arbitrageParams.order == SwapOrder.HADOUKEN_FIRST) {\n      uint256 baseTokenAmount = baseToken.balanceOf(address(this));\n      swapHadouken(arbitrageParams.batchSwapCalldata, quoteToken);\n      uint256 baseTokenDelta = baseToken.balanceOf(address(this)) -\n        baseTokenAmount;\n      swapYokai(quoteToken, baseToken, baseTokenDelta, arbitrageParams);\n    } else if (arbitrageParams.order == SwapOrder.YOKAI_FIRST) {\n      uint256 baseTokenAmount = baseToken.balanceOf(address(this));\n      swapYokai(baseToken, quoteToken, amounts[0], arbitrageParams);\n      uint256 baseTokenDelta = baseToken.balanceOf(address(this)) -\n        baseTokenAmount;\n      bytes memory batchSwapCallData = changeAmountInHadoukenCallData(\n        arbitrageParams.batchSwapCalldata,\n        baseTokenDelta\n      );\n      swapHadouken(batchSwapCallData, baseToken);\n    }\n\n    uint256 currentBalance = quoteToken.balanceOf(address(this));\n    uint256 returnValue = amounts[0] + premiums[0];\n\n    if (returnValue > currentBalance) {\n      revert(\n        string.concat(\n          'Negative profit! ',\n          Strings.toString(returnValue - currentBalance)\n        )\n      );\n    } else if (returnValue < currentBalance) {\n      quoteToken.transfer(originalSender, currentBalance - returnValue);\n    }\n\n    quoteToken.approve(address(lendingPool), returnValue);\n\n    return true;\n  }\n\n  receive() external payable {}\n}\n"
    },
    "contracts/interfaces/DataTypes.sol": {
      "content": "pragma solidity 0.8.12;\n\nlibrary DataTypes {\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    uint40 lastUpdateTimestamp;\n    //tokens addresses\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint8 id;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: Reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60-63: reserved\n    //bit 64-79: reserve factor\n    //bit 80-115: borrow cap\n    //bit 116-151: deposit cap\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    uint256 data;\n  }\n\n  enum InterestRateMode {\n    NONE,\n    STABLE,\n    VARIABLE\n  }\n}\n"
    },
    "contracts/interfaces/IAsset.sol": {
      "content": "pragma solidity 0.8.12;\n\n/**\n * @dev This is an empty interface used to represent either ERC20-conforming token contracts or ETH (using the zero\n * address sentinel value). We're just relying on the fact that `interface` can be used to declare new address-like\n * types.\n *\n * This concept is unrelated to a Pool's Asset Managers.\n */\ninterface IAsset {\n  // solhint-disable-previous-line no-empty-blocks\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "pragma solidity 0.8.12;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(\n    address owner,\n    address spender\n  ) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/IFlashLoanReceiver.sol": {
      "content": "pragma solidity 0.8.12;\n\n/**\n * @title IFlashLoanReceiver interface\n * @notice Interface for the Aave fee IFlashLoanReceiver.\n * @author Aave\n * @dev implement this interface to develop a flashloan-compatible flashLoanReceiver contract\n **/\ninterface IFlashLoanReceiver {\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/ILendingPool.sol": {
      "content": "pragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\nimport './DataTypes.sol';\n\ninterface ILendingPool {\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   **/\n  event FlashLoan(\n    address indexed target,\n    address indexed initiator,\n    address indexed asset,\n    uint256 amount,\n    uint256 premium,\n    uint16 referralCode\n  );\n\n  /**\n   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n   * For further details please visit https://developers.aave.com\n   * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts amounts being flash-borrowed\n   * @param modes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata modes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  function getReserveData(\n    address asset\n  ) external view returns (DataTypes.ReserveData memory);\n}\n"
    },
    "contracts/interfaces/IVault.sol": {
      "content": "pragma experimental ABIEncoderV2;\nimport './IERC20.sol';\nimport './IAsset.sol';\n\npragma solidity 0.8.12;\n\n/**\n * @dev Full external interface for the Vault core contract - no external or public methods exist in the contract that\n * don't override one of these declarations.\n */\ninterface IVault {\n  /**\n   * @dev Returns detailed information for a Pool's registered token.\n   *\n   * `cash` is the number of tokens the Vault currently holds for the Pool. `managed` is the number of tokens\n   * withdrawn and held outside the Vault by the Pool's token Asset Manager. The Pool's total balance for `token`\n   * equals the sum of `cash` and `managed`.\n   *\n   * Internally, `cash` and `managed` are stored using 112 bits. No action can ever cause a Pool's token `cash`,\n   * `managed` or `total` balance to be greater than 2^112 - 1.\n   *\n   * `lastChangeBlock` is the number of the block in which `token`'s total balance was last modified (via either a\n   * join, exit, swap, or Asset Manager update). This value is useful to avoid so-called 'sandwich attacks', for\n   * example when developing price oracles. A change of zero (e.g. caused by a swap with amount zero) is considered a\n   * change for this purpose, and will update `lastChangeBlock`.\n   *\n   * `assetManager` is the Pool's token Asset Manager.\n   */\n  function getPoolTokenInfo(\n    bytes32 poolId,\n    IERC20 token\n  )\n    external\n    view\n    returns (\n      uint256 cash,\n      uint256 managed,\n      uint256 lastChangeBlock,\n      address assetManager\n    );\n\n  /**\n   * @dev Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of\n   * the tokens' `balances` changed.\n   *\n   * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all\n   * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.\n   *\n   * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\n   * order as passed to `registerTokens`.\n   *\n   * Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are\n   * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`\n   * instead.\n   */\n  function getPoolTokens(\n    bytes32 poolId\n  )\n    external\n    view\n    returns (\n      IERC20[] memory tokens,\n      uint256[] memory balances,\n      uint256 lastChangeBlock\n    );\n\n  enum SwapKind {\n    GIVEN_IN,\n    GIVEN_OUT\n  }\n\n  /**\n   * @dev Performs a swap with a single Pool.\n   *\n   * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\n   * taken from the Pool, which must be greater than or equal to `limit`.\n   *\n   * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\n   * sent to the Pool, which must be less than or equal to `limit`.\n   *\n   * Internal Balance usage and the recipient are determined by the `funds` struct.\n   *\n   * Emits a `Swap` event.\n   */\n  function swap(\n    SingleSwap memory singleSwap,\n    FundManagement memory funds,\n    uint256 limit,\n    uint256 deadline\n  ) external payable returns (uint256);\n\n  /**\n   * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\n   * the `kind` value.\n   *\n   * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\n   * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\n   *\n   * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n   * used to extend swap behavior.\n   */\n  struct SingleSwap {\n    bytes32 poolId;\n    SwapKind kind;\n    IAsset assetIn;\n    IAsset assetOut;\n    uint256 amount;\n    bytes userData;\n  }\n\n  /**\n   * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\n   * the amount of tokens sent to or received from the Pool, depending on the `kind` value.\n   *\n   * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\n   * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\n   * the same index in the `assets` array.\n   *\n   * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\n   * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\n   * `amountOut` depending on the swap kind.\n   *\n   * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\n   * of the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal\n   * the previous swap's `tokenOut`. For a 'given out' swap, `tokenOut` must equal the previous swap's `tokenIn`.\n   *\n   * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\n   * or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and\n   * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to\n   * or unwrapped from WETH by the Vault.\n   *\n   * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\n   * the minimum or maximum amount of each token the vault is allowed to transfer.\n   *\n   * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\n   * equivalent `swap` call.\n   *\n   * Emits `Swap` events.\n   */\n  function batchSwap(\n    SwapKind kind,\n    BatchSwapStep[] memory swaps,\n    IAsset[] memory assets,\n    FundManagement memory funds,\n    int256[] memory limits,\n    uint256 deadline\n  ) external payable returns (int256[] memory);\n\n  /**\n   * @dev Data for each individual swap executed by `batchSwap`. The asset in and out fields are indexes into the\n   * `assets` array passed to that function, and ETH assets are converted to WETH.\n   *\n   * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\n   * from the previous swap, depending on the swap kind.\n   *\n   * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n   * used to extend swap behavior.\n   */\n  struct BatchSwapStep {\n    bytes32 poolId;\n    uint256 assetInIndex;\n    uint256 assetOutIndex;\n    uint256 amount;\n    bytes userData;\n  }\n\n  /**\n   * @dev Emitted for each individual swap performed by `swap` or `batchSwap`.\n   */\n  event Swap(\n    bytes32 indexed poolId,\n    IERC20 indexed tokenIn,\n    IERC20 indexed tokenOut,\n    uint256 amountIn,\n    uint256 amountOut\n  );\n\n  /**\n   * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\n   * `recipient` account.\n   *\n   * If the caller is not `sender`, it must be an authorized relayer for them.\n   *\n   * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\n   * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\n   * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\n   * `joinPool`.\n   *\n   * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\n   * transferred. This matches the behavior of `exitPool`.\n   *\n   * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\n   * revert.\n   */\n  struct FundManagement {\n    address sender;\n    bool fromInternalBalance;\n    address payable recipient;\n    bool toInternalBalance;\n  }\n\n  /**\n   * @dev Simulates a call to `batchSwap`, returning an array of Vault asset deltas. Calls to `swap` cannot be\n   * simulated directly, but an equivalent `batchSwap` call can and will yield the exact same result.\n   *\n   * Each element in the array corresponds to the asset at the same index, and indicates the number of tokens (or ETH)\n   * the Vault would take from the sender (if positive) or send to the recipient (if negative). The arguments it\n   * receives are the same that an equivalent `batchSwap` call would receive.\n   *\n   * Unlike `batchSwap`, this function performs no checks on the sender or recipient field in the `funds` struct.\n   * This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens,\n   * approve them for the Vault, or even know a user's address.\n   *\n   * Note that this function is not 'view' (due to implementation details): the client code must explicitly execute\n   * eth_call instead of eth_sendTransaction.\n   */\n  function queryBatchSwap(\n    SwapKind kind,\n    BatchSwapStep[] memory swaps,\n    IAsset[] memory assets,\n    FundManagement memory funds\n  ) external returns (int256[] memory assetDeltas);\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "pragma solidity 0.8.12;\nimport {IERC20} from './IERC20.sol';\n\ninterface IWETH is IERC20 {\n  function deposit() external payable;\n\n  function transfer(address to, uint value) external override returns (bool);\n\n  function withdraw(uint) external;\n}\n"
    },
    "contracts/interfaces/IYokaiRouter01.sol": {
      "content": "pragma solidity 0.8.12;\n\ninterface IYokaiRouter01 {\n  function factory() external pure returns (address);\n\n  function WETH() external pure returns (address);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n  ) external returns (uint amountA, uint amountB, uint liquidity);\n\n  function addLiquidityETH(\n    address token,\n    uint amountTokenDesired,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n  ) external returns (uint amountA, uint amountB);\n\n  function removeLiquidityETH(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  ) external returns (uint amountToken, uint amountETH);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint amountA, uint amountB);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint amountToken, uint amountETH);\n\n  function swapExactTokensForTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external returns (uint[] memory amounts);\n\n  function swapTokensForExactTokens(\n    uint amountOut,\n    uint amountInMax,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external returns (uint[] memory amounts);\n\n  function swapExactETHForTokens(\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external payable returns (uint[] memory amounts);\n\n  function swapTokensForExactETH(\n    uint amountOut,\n    uint amountInMax,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external returns (uint[] memory amounts);\n\n  function swapExactTokensForETH(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external returns (uint[] memory amounts);\n\n  function swapETHForExactTokens(\n    uint amountOut,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external payable returns (uint[] memory amounts);\n\n  function quote(\n    uint amountA,\n    uint reserveA,\n    uint reserveB\n  ) external pure returns (uint amountB);\n\n  function getAmountOut(\n    uint amountIn,\n    uint reserveIn,\n    uint reserveOut\n  ) external pure returns (uint amountOut);\n\n  function getAmountIn(\n    uint amountOut,\n    uint reserveIn,\n    uint reserveOut\n  ) external pure returns (uint amountIn);\n\n  function getAmountsOut(\n    uint amountIn,\n    address[] calldata path\n  ) external view returns (uint[] memory amounts);\n\n  function getAmountsIn(\n    uint amountOut,\n    address[] calldata path\n  ) external view returns (uint[] memory amounts);\n}\n"
    },
    "contracts/interfaces/IYokaiRouter02.sol": {
      "content": "pragma solidity 0.8.12;\n\nimport './IYokaiRouter01.sol';\n\ninterface IYokaiRouter02 is IYokaiRouter01 {\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  ) external returns (uint amountETH);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint amountETH);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external;\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external payable;\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}