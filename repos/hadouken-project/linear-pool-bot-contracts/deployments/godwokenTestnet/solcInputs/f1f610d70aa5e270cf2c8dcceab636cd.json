{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\n\nlibrary DataTypes {\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    uint40 lastUpdateTimestamp;\n    //tokens addresses\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint8 id;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: Reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60-63: reserved\n    //bit 64-79: reserve factor\n    //bit 80-115: borrow cap\n    //bit 116-151: deposit cap\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    uint256 data;\n  }\n\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\n}\n"
    },
    "contracts/interfaces/IAsset.sol": {
      "content": "pragma solidity 0.6.12;\n/**\n * @dev This is an empty interface used to represent either ERC20-conforming token contracts or ETH (using the zero\n * address sentinel value). We're just relying on the fact that `interface` can be used to declare new address-like\n * types.\n *\n * This concept is unrelated to a Pool's Asset Managers.\n */\ninterface IAsset {\n    // solhint-disable-previous-line no-empty-blocks\n}"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/IFlashLoanReceiver.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\n\n/**\n * @title IFlashLoanReceiver interface\n * @notice Interface for the Aave fee IFlashLoanReceiver.\n * @author Aave\n * @dev implement this interface to develop a flashloan-compatible flashLoanReceiver contract\n **/\ninterface IFlashLoanReceiver {\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport './DataTypes.sol';\n\ninterface ILendingPool {\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   **/\n  event FlashLoan(\n    address indexed target,\n    address indexed initiator,\n    address indexed asset,\n    uint256 amount,\n    uint256 premium,\n    uint16 referralCode\n  );\n\n  /**\n   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n   * For further details please visit https://developers.aave.com\n   * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts amounts being flash-borrowed\n   * @param modes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata modes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  function getReserveData(address asset)\n    external\n    view\n    returns (DataTypes.ReserveData memory);\n}\n"
    },
    "contracts/interfaces/IStaticATokenLM.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./IERC20.sol\";\n\n// solhint-disable-next-line max-line-length\n// Based on https://github.com/aave/protocol-v2/blob/ac58fea62bb8afee23f66197e8bce6d79ecda292/contracts/interfaces/IStaticATokenLM.sol\n\ninterface IStaticATokenLM is IERC20 {\n    struct SignatureParams {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    /**\n     * @notice Deposits `ASSET` in the Aave protocol and mints static aTokens to msg.sender\n     * @param recipient The address that will receive the static aTokens\n     * @param amount The amount of underlying `ASSET` to deposit (e.g. deposit of 100 USDC)\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @param fromUnderlying bool\n     * - `true` if the msg.sender comes with underlying tokens (e.g. USDC)\n     * - `false` if the msg.sender comes already with aTokens (e.g. aUSDC)\n     * @return uint256 The amount of StaticAToken minted, static balance\n     **/\n    function deposit(\n        address recipient,\n        uint256 amount,\n        uint16 referralCode,\n        bool fromUnderlying\n    ) external returns (uint256);\n\n    /**\n     * @notice Burns `amount` of static aToken, with recipient receiving the corresponding amount of `ASSET`\n     * @param recipient The address that will receive the amount of `ASSET` withdrawn from the Aave protocol\n     * @param amount The amount to withdraw, in static balance of StaticAToken\n     * @param toUnderlying bool\n     * - `true` for the recipient to get underlying tokens (e.g. USDC)\n     * - `false` for the recipient to get aTokens (e.g. aUSDC)\n     * @return amountToBurn: StaticATokens burnt, static balance\n     * @return amountToWithdraw: underlying/aToken send to `recipient`, dynamic balance\n     **/\n    function withdraw(\n        address recipient,\n        uint256 amount,\n        bool toUnderlying\n    ) external returns (uint256, uint256);\n\n    /**\n     * @notice Burns `amount` of static aToken, with recipient receiving the corresponding amount of `ASSET`\n     * @param recipient The address that will receive the amount of `ASSET` withdrawn from the Aave protocol\n     * @param amount The amount to withdraw, in dynamic balance of aToken/underlying asset\n     * @param toUnderlying bool\n     * - `true` for the recipient to get underlying tokens (e.g. USDC)\n     * - `false` for the recipient to get aTokens (e.g. aUSDC)\n     * @return amountToBurn: StaticATokens burnt, static balance\n     * @return amountToWithdraw: underlying/aToken send to `recipient`, dynamic balance\n     **/\n    function withdrawDynamicAmount(\n        address recipient,\n        uint256 amount,\n        bool toUnderlying\n    ) external returns (uint256, uint256);\n\n    /**\n     * @notice Implements the permit function as for\n     * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\n     * @param owner The owner of the funds\n     * @param spender The spender\n     * @param value The amount\n     * @param deadline The deadline timestamp, type(uint256).max for max deadline\n     * @param v Signature param\n     * @param s Signature param\n     * @param r Signature param\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @notice Allows to deposit on Aave via meta-transaction\n     * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\n     * @param depositor Address from which the funds to deposit are going to be pulled\n     * @param recipient Address that will receive the staticATokens, in the average case, same as the `depositor`\n     * @param value The amount to deposit\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @param fromUnderlying bool\n     * - `true` if the msg.sender comes with underlying tokens (e.g. USDC)\n     * - `false` if the msg.sender comes already with aTokens (e.g. aUSDC)\n     * @param deadline The deadline timestamp, type(uint256).max for max deadline\n     * @param sigParams Signature params: v,r,s\n     * @return uint256 The amount of StaticAToken minted, static balance\n     */\n    function metaDeposit(\n        address depositor,\n        address recipient,\n        uint256 value,\n        uint16 referralCode,\n        bool fromUnderlying,\n        uint256 deadline,\n        SignatureParams calldata sigParams\n    ) external returns (uint256);\n\n    /**\n     * @notice Allows to withdraw from Aave via meta-transaction\n     * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\n     * @param owner Address owning the staticATokens\n     * @param recipient Address that will receive the underlying withdrawn from Aave\n     * @param staticAmount The amount of staticAToken to withdraw. If > 0, `dynamicAmount` needs to be 0\n     * @param dynamicAmount The amount of underlying/aToken to withdraw. If > 0, `staticAmount` needs to be 0\n     * @param toUnderlying bool\n     * - `true` for the recipient to get underlying tokens (e.g. USDC)\n     * - `false` for the recipient to get aTokens (e.g. aUSDC)\n     * @param deadline The deadline timestamp, type(uint256).max for max deadline\n     * @param sigParams Signature params: v,r,s\n     * @return amountToBurn: StaticATokens burnt, static balance\n     * @return amountToWithdraw: underlying/aToken send to `recipient`, dynamic balance\n     */\n    function metaWithdraw(\n        address owner,\n        address recipient,\n        uint256 staticAmount,\n        uint256 dynamicAmount,\n        bool toUnderlying,\n        uint256 deadline,\n        SignatureParams calldata sigParams\n    ) external returns (uint256, uint256);\n\n    /**\n     * @notice Utility method to get the current aToken balance of an user, from his staticAToken balance\n     * @param account The address of the user\n     * @return uint256 The aToken balance\n     **/\n    function dynamicBalanceOf(address account) external view returns (uint256);\n\n    /**\n     * @notice Converts a static amount (scaled balance on aToken) to the aToken/underlying value,\n     * using the current liquidity index on Aave\n     * @param amount The amount to convert from\n     * @return uint256 The dynamic amount\n     **/\n    function staticToDynamicAmount(uint256 amount) external view returns (uint256);\n\n    /**\n     * @notice Converts an aToken or underlying amount to the what it is denominated on the aToken as\n     * scaled balance, function of the principal and the liquidity index\n     * @param amount The amount to convert from\n     * @return uint256 The static (scaled) amount\n     **/\n    function dynamicToStaticAmount(uint256 amount) external view returns (uint256);\n\n    /**\n     * @notice Returns the Aave liquidity index of the underlying aToken, denominated rate here\n     * as it can be considered as an ever-increasing exchange rate\n     * @return The liquidity index\n     **/\n    function rate() external view returns (uint256);\n\n    /**\n     * @notice Function to return a dynamic domain separator, in order to be compatible with forks changing chainId\n     * @return bytes32 The domain separator\n     **/\n    function getDomainSeparator() external view returns (bytes32);\n\n    /**\n     * @notice Claims rewards from `INCENTIVES_CONTROLLER` and updates internal accounting of rewards.\n     */\n    function collectAndUpdateRewards() external;\n\n    /**\n     * @notice Claim rewards on behalf of a user and send them to a receiver\n     * @dev Only callable by if sender is onBehalfOf or sender is approved claimer\n     * @param onBehalfOf The address to claim on behalf of\n     * @param receiver The address to receive the rewards\n     * @param forceUpdate Flag to retrieve latest rewards from `INCENTIVES_CONTROLLER`\n     */\n    function claimRewardsOnBehalf(\n        address onBehalfOf,\n        address receiver,\n        bool forceUpdate\n    ) external;\n\n    /**\n     * @notice Claim rewards and send them to a receiver\n     * @param receiver The address to receive the rewards\n     * @param forceUpdate Flag to retrieve latest rewards from `INCENTIVES_CONTROLLER`\n     */\n    function claimRewards(address receiver, bool forceUpdate) external;\n\n    /**\n     * @notice Claim rewards\n     * @param forceUpdate Flag to retrieve latest rewards from `INCENTIVES_CONTROLLER`\n     */\n    function claimRewardsToSelf(bool forceUpdate) external;\n\n    /**\n     * @notice Get the total claimable rewards of the contract.\n     * @return The current balance + pending rewards from the `_incentivesController`\n     */\n    function getTotalClaimableRewards() external view returns (uint256);\n\n    /**\n     * @notice Get the total claimable rewards for a user in WAD\n     * @param user The address of the user\n     * @return The claimable amount of rewards in WAD\n     */\n    function getClaimableRewards(address user) external view returns (uint256);\n\n    /**\n     * @notice The unclaimed rewards for a user in WAD\n     * @param user The address of the user\n     * @return The unclaimed amount of rewards in WAD\n     */\n    function getUnclaimedRewards(address user) external view returns (uint256);\n\n    function getAccRewardsPerToken() external view returns (uint256);\n\n    function getLifetimeRewardsClaimed() external view returns (uint256);\n\n    function getLifetimeRewards() external view returns (uint256);\n\n    function getLastRewardBlock() external view returns (uint256);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function LENDING_POOL() external returns (address);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function INCENTIVES_CONTROLLER() external returns (address);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function ATOKEN() external returns (IERC20);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function ASSET() external returns (IERC20);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function REWARD_TOKEN() external returns (IERC20);\n}\n"
    },
    "contracts/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma experimental ABIEncoderV2;\nimport './IERC20.sol';\nimport './IAsset.sol';\n\npragma solidity 0.6.12;\n\n/**\n * @dev Full external interface for the Vault core contract - no external or public methods exist in the contract that\n * don't override one of these declarations.\n */\ninterface IVault {\n\n    /**\n     * @dev Returns detailed information for a Pool's registered token.\n     *\n     * `cash` is the number of tokens the Vault currently holds for the Pool. `managed` is the number of tokens\n     * withdrawn and held outside the Vault by the Pool's token Asset Manager. The Pool's total balance for `token`\n     * equals the sum of `cash` and `managed`.\n     *\n     * Internally, `cash` and `managed` are stored using 112 bits. No action can ever cause a Pool's token `cash`,\n     * `managed` or `total` balance to be greater than 2^112 - 1.\n     *\n     * `lastChangeBlock` is the number of the block in which `token`'s total balance was last modified (via either a\n     * join, exit, swap, or Asset Manager update). This value is useful to avoid so-called 'sandwich attacks', for\n     * example when developing price oracles. A change of zero (e.g. caused by a swap with amount zero) is considered a\n     * change for this purpose, and will update `lastChangeBlock`.\n     *\n     * `assetManager` is the Pool's token Asset Manager.\n     */\n    function getPoolTokenInfo(bytes32 poolId, IERC20 token)\n        external\n        view\n        returns (\n            uint256 cash,\n            uint256 managed,\n            uint256 lastChangeBlock,\n            address assetManager\n        );\n\n    /**\n     * @dev Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of\n     * the tokens' `balances` changed.\n     *\n     * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all\n     * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.\n     *\n     * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\n     * order as passed to `registerTokens`.\n     *\n     * Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are\n     * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`\n     * instead.\n     */\n    function getPoolTokens(bytes32 poolId)\n        external\n        view\n        returns (\n            IERC20[] memory tokens,\n            uint256[] memory balances,\n            uint256 lastChangeBlock\n        );\n\n    enum SwapKind { GIVEN_IN, GIVEN_OUT }\n\n    /**\n     * @dev Performs a swap with a single Pool.\n     *\n     * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\n     * taken from the Pool, which must be greater than or equal to `limit`.\n     *\n     * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\n     * sent to the Pool, which must be less than or equal to `limit`.\n     *\n     * Internal Balance usage and the recipient are determined by the `funds` struct.\n     *\n     * Emits a `Swap` event.\n     */\n    function swap(\n        SingleSwap memory singleSwap,\n        FundManagement memory funds,\n        uint256 limit,\n        uint256 deadline\n    ) external payable returns (uint256);\n\n    /**\n     * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\n     * the `kind` value.\n     *\n     * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\n     * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n    struct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        IAsset assetIn;\n        IAsset assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n\n    /**\n     * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\n     * the amount of tokens sent to or received from the Pool, depending on the `kind` value.\n     *\n     * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\n     * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\n     * the same index in the `assets` array.\n     *\n     * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\n     * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\n     * `amountOut` depending on the swap kind.\n     *\n     * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\n     * of the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal\n     * the previous swap's `tokenOut`. For a 'given out' swap, `tokenOut` must equal the previous swap's `tokenIn`.\n     *\n     * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\n     * or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and\n     * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to\n     * or unwrapped from WETH by the Vault.\n     *\n     * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\n     * the minimum or maximum amount of each token the vault is allowed to transfer.\n     *\n     * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\n     * equivalent `swap` call.\n     *\n     * Emits `Swap` events.\n     */\n    function batchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds,\n        int256[] memory limits,\n        uint256 deadline\n    ) external payable returns (int256[] memory);\n\n    /**\n     * @dev Data for each individual swap executed by `batchSwap`. The asset in and out fields are indexes into the\n     * `assets` array passed to that function, and ETH assets are converted to WETH.\n     *\n     * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\n     * from the previous swap, depending on the swap kind.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n    struct BatchSwapStep {\n        bytes32 poolId;\n        uint256 assetInIndex;\n        uint256 assetOutIndex;\n        uint256 amount;\n        bytes userData;\n    }\n\n    /**\n     * @dev Emitted for each individual swap performed by `swap` or `batchSwap`.\n     */\n    event Swap(\n        bytes32 indexed poolId,\n        IERC20 indexed tokenIn,\n        IERC20 indexed tokenOut,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    /**\n     * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\n     * `recipient` account.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\n     * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\n     * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\n     * `joinPool`.\n     *\n     * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\n     * transferred. This matches the behavior of `exitPool`.\n     *\n     * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\n     * revert.\n     */\n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address payable recipient;\n        bool toInternalBalance;\n    }\n\n    /**\n     * @dev Simulates a call to `batchSwap`, returning an array of Vault asset deltas. Calls to `swap` cannot be\n     * simulated directly, but an equivalent `batchSwap` call can and will yield the exact same result.\n     *\n     * Each element in the array corresponds to the asset at the same index, and indicates the number of tokens (or ETH)\n     * the Vault would take from the sender (if positive) or send to the recipient (if negative). The arguments it\n     * receives are the same that an equivalent `batchSwap` call would receive.\n     *\n     * Unlike `batchSwap`, this function performs no checks on the sender or recipient field in the `funds` struct.\n     * This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens,\n     * approve them for the Vault, or even know a user's address.\n     *\n     * Note that this function is not 'view' (due to implementation details): the client code must explicitly execute\n     * eth_call instead of eth_sendTransaction.\n     */\n    function queryBatchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds\n    ) external returns (int256[] memory assetDeltas);\n}\n"
    },
    "contracts/LinearPoolSwap.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport { IERC20 } from './interfaces/IERC20.sol';\nimport { IVault } from './interfaces/IVault.sol';\nimport { IAsset } from './interfaces/IAsset.sol';\nimport { IStaticATokenLM } from './interfaces/IStaticATokenLM.sol';\nimport { ILendingPool } from './interfaces/ILendingPool.sol';\nimport { IFlashLoanReceiver } from './interfaces/IFlashLoanReceiver.sol';\nimport { DataTypes } from './interfaces/DataTypes.sol';\n\ncontract LinearPoolSwap is IFlashLoanReceiver {\n\n    IVault private vault;\n    IERC20 private token;\n    IStaticATokenLM private wrappedHToken;\n    bytes32 private poolId;\n    ILendingPool private lendingPool;\n    uint256 constant UINT256_MAX = type(uint256).max;\n    enum op { WIND, UNWIND }\n\n    constructor(address vaultAddress, address lendingPoolAddress, address tokenAddress, address wrappedHTokenAddress,  bytes32 _poolId) public {\n        vault = IVault(vaultAddress);\n        lendingPool = ILendingPool(lendingPoolAddress);\n        token = IERC20(tokenAddress);\n        wrappedHToken = IStaticATokenLM(wrappedHTokenAddress);\n        poolId = _poolId;\n    }\n\n    // Decrease USDC tokens in pool and increase wrapped hUSDC\n    function windXTimes(uint8 counter, uint256 amount) public {\n        token.transferFrom(msg.sender, address(this), amount);\n\n        for (uint8 i=0; i < counter; i++) {\n            wind();\n        }\n\n        token.transfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    function wind() public {\n\n        token.approve(address(wrappedHToken), UINT256_MAX);\n\n        wrappedHToken.deposit(address(this), token.balanceOf(address(this)), 0, true);\n        wrappedHToken.approve(address(vault), UINT256_MAX);\n\n        bytes memory userDataEncoded = \"\";\n\n        IVault.SingleSwap memory singleSwap = IVault.SingleSwap(\n            poolId,\n            IVault.SwapKind.GIVEN_IN,\n            IAsset(address(wrappedHToken)),\n            IAsset(address(token)),\n            wrappedHToken.balanceOf(address(this)),\n            userDataEncoded\n        );\n        IVault.FundManagement memory fundManagement = IVault.FundManagement(\n            address(this),\n            false,\n            payable(address(this)),\n            false\n        );\n\n        uint256 limit = wrappedHToken.balanceOf(address(this)) * 90 / 100;\n        vault.swap(singleSwap, fundManagement, limit, UINT256_MAX);\n\n\n\n        // USDC 52,268,702.48 hUSDC 48,764.24 wind 1 time 100 USDC\n        // USDC 52,268,602.47 hUSDC 48,864.06\n\n        // USDC 52,268,687.32 hUSDC 48,779.36 wind 10 times 100 USDC\n        // USDC 52,267,680.43 hUSDC 49,784.35\n\n        // USDC 52,267,680.43 hUSDC 49,784.35 wind 10 times 500 USDC\n        // USDC 52,262,645.99 hUSDC 54,809.32\n\n        // USDC 52,262,645.99 hUSDC 54,809.32 wind 10 times 500 USDC\n        // USDC 52,257,611.54 hUSDC 59,834.28\n    }\n\n    // Increase USDC tokens in pool and decrease wrapped hUSDC\n    function unwindXTimes(uint8 counter, uint256 amount) public {\n        token.transferFrom(msg.sender, address(this), amount);\n\n        for (uint8 i=0; i < counter; i++) {\n            unwind();\n        }\n\n        token.transfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    function unwind() public {\n        token.approve(address(vault), UINT256_MAX);\n\n        bytes memory userDataEncoded = \"\";\n\n        IVault.SingleSwap memory singleSwap = IVault.SingleSwap(\n            poolId,\n            IVault.SwapKind.GIVEN_IN,\n            IAsset(address(token)),\n            IAsset(address(wrappedHToken)),\n            token.balanceOf(address(this)),\n            userDataEncoded\n        );\n        IVault.FundManagement memory fundManagement = IVault.FundManagement(\n            address(this),\n            false,\n            payable(address(this)),\n            false\n        );\n\n        uint256 limit = token.balanceOf(address(this)) * 90 / 100;\n        vault.swap(singleSwap, fundManagement, limit, UINT256_MAX);\n\n        wrappedHToken.withdraw(address(this), wrappedHToken.balanceOf(address(this)), true);\n\n        // USDC 52,268,602.47 hUSDC 48,864.06 unwind 1 time 100 USDC\n        // USDC 52,268,702.33 hUSDC 48,764.39\n\n        // USDC 52,268,702.33 hUSDC 48,764.39 unwind 10 times 100 USDC\n        // USDC 52,269,694.21 hUSDC 47,774.37\n\n        // USDC 52,257,611.54 hUSDC 59,834.28 unwind 10 times 500 USDC\n        // USDC 52,262,570.98 hUSDC 54,884.18\n    }\n\n    function flashLoanWind(uint256 amount) public {\n        address[] memory tokens = new address[](1);\n        tokens[0] = address(token);\n\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = amount;\n\n        uint256[] memory modes = new uint256[](1);\n        modes[0] = 0;\n\n        bytes memory params = abi.encode(op.WIND, msg.sender);\n\n        lendingPool.flashLoan(address(this), tokens, amounts, modes, address(this), params, 0);\n\n        // USDC 52,262,570.98 hUSDC 54,884.18 flashloanWind 1000 USDC\n        // USDC 52,262,570.98 hUSDC 54,884.18 reentrancy error ???\n    }\n\n    function flashLoanUnwind(uint256 amount) public {\n        address[] memory tokens = new address[](1);\n        tokens[0] = address(token);\n\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = amount;\n\n        uint256[] memory modes = new uint256[](1);\n        modes[0] = 0;\n\n        bytes memory params = abi.encode(op.UNWIND, msg.sender);\n\n        lendingPool.flashLoan(address(this), tokens, amounts, modes, address(this), params, 0);\n\n        // USDC 52,262,569.88 hUSDC 55,882.32 flashloanWind 1000 USDC\n        // USDC 52,262,570.98 hUSDC 54,884.18 reentrancy error ???\n    }\n\n    function executeOperation(\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address initiator,\n        bytes calldata params\n    ) external override returns (bool) {\n        op decodedData;\n        address originalSender;\n        (decodedData, originalSender) = abi.decode(params,(op, address));\n        token.transfer(originalSender, 50_000_000);\n        // if (decodedData == op.WIND) {\n        //     wind();\n        // } else if (decodedData == op.UNWIND) {\n        //     unwind();\n        // }\n        uint256 currentBalance = token.balanceOf(address(this));  \n        uint256 returnValue = amounts[0] + premiums[0];\n       // token.transferFrom(originalSender, address(this), returnValue);\n\n        if (returnValue > currentBalance) {\n            token.transferFrom(originalSender, address(this), returnValue - currentBalance);\n        } else if (returnValue < currentBalance) {\n            token.transfer(originalSender, currentBalance - returnValue);\n        }\n        \n        token.approve(address(lendingPool), returnValue);\n        return true;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}