{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "contracts/interfaces/DataTypes.sol": {
      "content": "pragma solidity ^0.8.0;\n\nlibrary DataTypes {\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    uint40 lastUpdateTimestamp;\n    //tokens addresses\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint8 id;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: Reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60-63: reserved\n    //bit 64-79: reserve factor\n    //bit 80-115: borrow cap\n    //bit 116-151: deposit cap\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    uint256 data;\n  }\n\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\n}\n"
    },
    "contracts/interfaces/IAsset.sol": {
      "content": "pragma solidity ^0.8.0;\n/**\n * @dev This is an empty interface used to represent either ERC20-conforming token contracts or ETH (using the zero\n * address sentinel value). We're just relying on the fact that `interface` can be used to declare new address-like\n * types.\n *\n * This concept is unrelated to a Pool's Asset Managers.\n */\ninterface IAsset {\n    // solhint-disable-previous-line no-empty-blocks\n}"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "pragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    },
    "contracts/interfaces/IFlashLoanReceiver.sol": {
      "content": "pragma solidity ^0.8.0;\n\n/**\n * @title IFlashLoanReceiver interface\n * @notice Interface for the Aave fee IFlashLoanReceiver.\n * @author Aave\n * @dev implement this interface to develop a flashloan-compatible flashLoanReceiver contract\n **/\ninterface IFlashLoanReceiver {\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/ILendingPool.sol": {
      "content": "pragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\nimport './DataTypes.sol';\n\ninterface ILendingPool {\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   **/\n  event FlashLoan(\n    address indexed target,\n    address indexed initiator,\n    address indexed asset,\n    uint256 amount,\n    uint256 premium,\n    uint16 referralCode\n  );\n\n  /**\n   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n   * For further details please visit https://developers.aave.com\n   * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts amounts being flash-borrowed\n   * @param modes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata modes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  function getReserveData(address asset)\n    external\n    view\n    returns (DataTypes.ReserveData memory);\n}\n"
    },
    "contracts/interfaces/ILinearPool.sol": {
      "content": "pragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"./IERC20.sol\";\n\ninterface ILinearPool {\n    /**\n     * @dev Returns the Pool's main token.\n     */\n    function getMainToken() external view returns (IERC20);\n\n    /**\n     * @dev Returns the Pool's wrapped token.\n     */\n    function getWrappedToken() external view returns (IERC20);\n\n    /**\n     * @dev Returns the index of the Pool's BPT in the Pool tokens array (as returned by IVault.getPoolTokens).\n     */\n    function getBptIndex() external view returns (uint256);\n\n    /**\n     * @dev Returns the index of the Pool's main token in the Pool tokens array (as returned by IVault.getPoolTokens).\n     */\n    function getMainIndex() external view returns (uint256);\n\n    /**\n     * @dev Returns the index of the Pool's wrapped token in the Pool tokens array (as returned by\n     * IVault.getPoolTokens).\n     */\n    function getWrappedIndex() external view returns (uint256);\n\n    /**\n     * @dev Returns the Pool's targets for the main token balance. These values have had the main token's scaling\n     * factor applied to them.\n     */\n    function getTargets() external view returns (uint256 lowerTarget, uint256 upperTarget);\n}"
    },
    "contracts/interfaces/IStaticATokenLM.sol": {
      "content": "pragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"./IERC20.sol\";\n\n// solhint-disable-next-line max-line-length\n// Based on https://github.com/aave/protocol-v2/blob/ac58fea62bb8afee23f66197e8bce6d79ecda292/contracts/interfaces/IStaticATokenLM.sol\n\ninterface IStaticATokenLM is IERC20 {\n    struct SignatureParams {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    /**\n     * @notice Deposits `ASSET` in the Aave protocol and mints static aTokens to msg.sender\n     * @param recipient The address that will receive the static aTokens\n     * @param amount The amount of underlying `ASSET` to deposit (e.g. deposit of 100 USDC)\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @param fromUnderlying bool\n     * - `true` if the msg.sender comes with underlying tokens (e.g. USDC)\n     * - `false` if the msg.sender comes already with aTokens (e.g. aUSDC)\n     * @return uint256 The amount of StaticAToken minted, static balance\n     **/\n    function deposit(\n        address recipient,\n        uint256 amount,\n        uint16 referralCode,\n        bool fromUnderlying\n    ) external returns (uint256);\n\n    /**\n     * @notice Burns `amount` of static aToken, with recipient receiving the corresponding amount of `ASSET`\n     * @param recipient The address that will receive the amount of `ASSET` withdrawn from the Aave protocol\n     * @param amount The amount to withdraw, in static balance of StaticAToken\n     * @param toUnderlying bool\n     * - `true` for the recipient to get underlying tokens (e.g. USDC)\n     * - `false` for the recipient to get aTokens (e.g. aUSDC)\n     * @return amountToBurn: StaticATokens burnt, static balance\n     * @return amountToWithdraw: underlying/aToken send to `recipient`, dynamic balance\n     **/\n    function withdraw(\n        address recipient,\n        uint256 amount,\n        bool toUnderlying\n    ) external returns (uint256, uint256);\n\n    /**\n     * @notice Burns `amount` of static aToken, with recipient receiving the corresponding amount of `ASSET`\n     * @param recipient The address that will receive the amount of `ASSET` withdrawn from the Aave protocol\n     * @param amount The amount to withdraw, in dynamic balance of aToken/underlying asset\n     * @param toUnderlying bool\n     * - `true` for the recipient to get underlying tokens (e.g. USDC)\n     * - `false` for the recipient to get aTokens (e.g. aUSDC)\n     * @return amountToBurn: StaticATokens burnt, static balance\n     * @return amountToWithdraw: underlying/aToken send to `recipient`, dynamic balance\n     **/\n    function withdrawDynamicAmount(\n        address recipient,\n        uint256 amount,\n        bool toUnderlying\n    ) external returns (uint256, uint256);\n\n    /**\n     * @notice Implements the permit function as for\n     * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\n     * @param owner The owner of the funds\n     * @param spender The spender\n     * @param value The amount\n     * @param deadline The deadline timestamp, type(uint256).max for max deadline\n     * @param v Signature param\n     * @param s Signature param\n     * @param r Signature param\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @notice Allows to deposit on Aave via meta-transaction\n     * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\n     * @param depositor Address from which the funds to deposit are going to be pulled\n     * @param recipient Address that will receive the staticATokens, in the average case, same as the `depositor`\n     * @param value The amount to deposit\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @param fromUnderlying bool\n     * - `true` if the msg.sender comes with underlying tokens (e.g. USDC)\n     * - `false` if the msg.sender comes already with aTokens (e.g. aUSDC)\n     * @param deadline The deadline timestamp, type(uint256).max for max deadline\n     * @param sigParams Signature params: v,r,s\n     * @return uint256 The amount of StaticAToken minted, static balance\n     */\n    function metaDeposit(\n        address depositor,\n        address recipient,\n        uint256 value,\n        uint16 referralCode,\n        bool fromUnderlying,\n        uint256 deadline,\n        SignatureParams calldata sigParams\n    ) external returns (uint256);\n\n    /**\n     * @notice Allows to withdraw from Aave via meta-transaction\n     * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\n     * @param owner Address owning the staticATokens\n     * @param recipient Address that will receive the underlying withdrawn from Aave\n     * @param staticAmount The amount of staticAToken to withdraw. If > 0, `dynamicAmount` needs to be 0\n     * @param dynamicAmount The amount of underlying/aToken to withdraw. If > 0, `staticAmount` needs to be 0\n     * @param toUnderlying bool\n     * - `true` for the recipient to get underlying tokens (e.g. USDC)\n     * - `false` for the recipient to get aTokens (e.g. aUSDC)\n     * @param deadline The deadline timestamp, type(uint256).max for max deadline\n     * @param sigParams Signature params: v,r,s\n     * @return amountToBurn: StaticATokens burnt, static balance\n     * @return amountToWithdraw: underlying/aToken send to `recipient`, dynamic balance\n     */\n    function metaWithdraw(\n        address owner,\n        address recipient,\n        uint256 staticAmount,\n        uint256 dynamicAmount,\n        bool toUnderlying,\n        uint256 deadline,\n        SignatureParams calldata sigParams\n    ) external returns (uint256, uint256);\n\n    /**\n     * @notice Utility method to get the current aToken balance of an user, from his staticAToken balance\n     * @param account The address of the user\n     * @return uint256 The aToken balance\n     **/\n    function dynamicBalanceOf(address account) external view returns (uint256);\n\n    /**\n     * @notice Converts a static amount (scaled balance on aToken) to the aToken/underlying value,\n     * using the current liquidity index on Aave\n     * @param amount The amount to convert from\n     * @return uint256 The dynamic amount\n     **/\n    function staticToDynamicAmount(uint256 amount) external view returns (uint256);\n\n    /**\n     * @notice Converts an aToken or underlying amount to the what it is denominated on the aToken as\n     * scaled balance, function of the principal and the liquidity index\n     * @param amount The amount to convert from\n     * @return uint256 The static (scaled) amount\n     **/\n    function dynamicToStaticAmount(uint256 amount) external view returns (uint256);\n\n    /**\n     * @notice Returns the Aave liquidity index of the underlying aToken, denominated rate here\n     * as it can be considered as an ever-increasing exchange rate\n     * @return The liquidity index\n     **/\n    function rate() external view returns (uint256);\n\n    /**\n     * @notice Function to return a dynamic domain separator, in order to be compatible with forks changing chainId\n     * @return bytes32 The domain separator\n     **/\n    function getDomainSeparator() external view returns (bytes32);\n\n    /**\n     * @notice Claims rewards from `INCENTIVES_CONTROLLER` and updates internal accounting of rewards.\n     */\n    function collectAndUpdateRewards() external;\n\n    /**\n     * @notice Claim rewards on behalf of a user and send them to a receiver\n     * @dev Only callable by if sender is onBehalfOf or sender is approved claimer\n     * @param onBehalfOf The address to claim on behalf of\n     * @param receiver The address to receive the rewards\n     * @param forceUpdate Flag to retrieve latest rewards from `INCENTIVES_CONTROLLER`\n     */\n    function claimRewardsOnBehalf(\n        address onBehalfOf,\n        address receiver,\n        bool forceUpdate\n    ) external;\n\n    /**\n     * @notice Claim rewards and send them to a receiver\n     * @param receiver The address to receive the rewards\n     * @param forceUpdate Flag to retrieve latest rewards from `INCENTIVES_CONTROLLER`\n     */\n    function claimRewards(address receiver, bool forceUpdate) external;\n\n    /**\n     * @notice Claim rewards\n     * @param forceUpdate Flag to retrieve latest rewards from `INCENTIVES_CONTROLLER`\n     */\n    function claimRewardsToSelf(bool forceUpdate) external;\n\n    /**\n     * @notice Get the total claimable rewards of the contract.\n     * @return The current balance + pending rewards from the `_incentivesController`\n     */\n    function getTotalClaimableRewards() external view returns (uint256);\n\n    /**\n     * @notice Get the total claimable rewards for a user in WAD\n     * @param user The address of the user\n     * @return The claimable amount of rewards in WAD\n     */\n    function getClaimableRewards(address user) external view returns (uint256);\n\n    /**\n     * @notice The unclaimed rewards for a user in WAD\n     * @param user The address of the user\n     * @return The unclaimed amount of rewards in WAD\n     */\n    function getUnclaimedRewards(address user) external view returns (uint256);\n\n    function getAccRewardsPerToken() external view returns (uint256);\n\n    function getLifetimeRewardsClaimed() external view returns (uint256);\n\n    function getLifetimeRewards() external view returns (uint256);\n\n    function getLastRewardBlock() external view returns (uint256);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function LENDING_POOL() external returns (address);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function INCENTIVES_CONTROLLER() external returns (address);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function ATOKEN() external returns (IERC20);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function ASSET() external returns (IERC20);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function REWARD_TOKEN() external returns (IERC20);\n}\n"
    },
    "contracts/interfaces/IVault.sol": {
      "content": "pragma experimental ABIEncoderV2;\nimport './IERC20.sol';\nimport './IAsset.sol';\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Full external interface for the Vault core contract - no external or public methods exist in the contract that\n * don't override one of these declarations.\n */\ninterface IVault {\n\n    /**\n     * @dev Returns detailed information for a Pool's registered token.\n     *\n     * `cash` is the number of tokens the Vault currently holds for the Pool. `managed` is the number of tokens\n     * withdrawn and held outside the Vault by the Pool's token Asset Manager. The Pool's total balance for `token`\n     * equals the sum of `cash` and `managed`.\n     *\n     * Internally, `cash` and `managed` are stored using 112 bits. No action can ever cause a Pool's token `cash`,\n     * `managed` or `total` balance to be greater than 2^112 - 1.\n     *\n     * `lastChangeBlock` is the number of the block in which `token`'s total balance was last modified (via either a\n     * join, exit, swap, or Asset Manager update). This value is useful to avoid so-called 'sandwich attacks', for\n     * example when developing price oracles. A change of zero (e.g. caused by a swap with amount zero) is considered a\n     * change for this purpose, and will update `lastChangeBlock`.\n     *\n     * `assetManager` is the Pool's token Asset Manager.\n     */\n    function getPoolTokenInfo(bytes32 poolId, IERC20 token)\n        external\n        view\n        returns (\n            uint256 cash,\n            uint256 managed,\n            uint256 lastChangeBlock,\n            address assetManager\n        );\n\n    /**\n     * @dev Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of\n     * the tokens' `balances` changed.\n     *\n     * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all\n     * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.\n     *\n     * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\n     * order as passed to `registerTokens`.\n     *\n     * Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are\n     * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`\n     * instead.\n     */\n    function getPoolTokens(bytes32 poolId)\n        external\n        view\n        returns (\n            IERC20[] memory tokens,\n            uint256[] memory balances,\n            uint256 lastChangeBlock\n        );\n\n    enum SwapKind { GIVEN_IN, GIVEN_OUT }\n\n    /**\n     * @dev Performs a swap with a single Pool.\n     *\n     * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\n     * taken from the Pool, which must be greater than or equal to `limit`.\n     *\n     * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\n     * sent to the Pool, which must be less than or equal to `limit`.\n     *\n     * Internal Balance usage and the recipient are determined by the `funds` struct.\n     *\n     * Emits a `Swap` event.\n     */\n    function swap(\n        SingleSwap memory singleSwap,\n        FundManagement memory funds,\n        uint256 limit,\n        uint256 deadline\n    ) external payable returns (uint256);\n\n    /**\n     * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\n     * the `kind` value.\n     *\n     * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\n     * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n    struct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        IAsset assetIn;\n        IAsset assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n\n    /**\n     * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\n     * the amount of tokens sent to or received from the Pool, depending on the `kind` value.\n     *\n     * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\n     * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\n     * the same index in the `assets` array.\n     *\n     * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\n     * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\n     * `amountOut` depending on the swap kind.\n     *\n     * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\n     * of the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal\n     * the previous swap's `tokenOut`. For a 'given out' swap, `tokenOut` must equal the previous swap's `tokenIn`.\n     *\n     * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\n     * or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and\n     * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to\n     * or unwrapped from WETH by the Vault.\n     *\n     * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\n     * the minimum or maximum amount of each token the vault is allowed to transfer.\n     *\n     * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\n     * equivalent `swap` call.\n     *\n     * Emits `Swap` events.\n     */\n    function batchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds,\n        int256[] memory limits,\n        uint256 deadline\n    ) external payable returns (int256[] memory);\n\n    /**\n     * @dev Data for each individual swap executed by `batchSwap`. The asset in and out fields are indexes into the\n     * `assets` array passed to that function, and ETH assets are converted to WETH.\n     *\n     * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\n     * from the previous swap, depending on the swap kind.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n    struct BatchSwapStep {\n        bytes32 poolId;\n        uint256 assetInIndex;\n        uint256 assetOutIndex;\n        uint256 amount;\n        bytes userData;\n    }\n\n    /**\n     * @dev Emitted for each individual swap performed by `swap` or `batchSwap`.\n     */\n    event Swap(\n        bytes32 indexed poolId,\n        IERC20 indexed tokenIn,\n        IERC20 indexed tokenOut,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    /**\n     * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\n     * `recipient` account.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\n     * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\n     * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\n     * `joinPool`.\n     *\n     * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\n     * transferred. This matches the behavior of `exitPool`.\n     *\n     * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\n     * revert.\n     */\n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address payable recipient;\n        bool toInternalBalance;\n    }\n\n    /**\n     * @dev Simulates a call to `batchSwap`, returning an array of Vault asset deltas. Calls to `swap` cannot be\n     * simulated directly, but an equivalent `batchSwap` call can and will yield the exact same result.\n     *\n     * Each element in the array corresponds to the asset at the same index, and indicates the number of tokens (or ETH)\n     * the Vault would take from the sender (if positive) or send to the recipient (if negative). The arguments it\n     * receives are the same that an equivalent `batchSwap` call would receive.\n     *\n     * Unlike `batchSwap`, this function performs no checks on the sender or recipient field in the `funds` struct.\n     * This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens,\n     * approve them for the Vault, or even know a user's address.\n     *\n     * Note that this function is not 'view' (due to implementation details): the client code must explicitly execute\n     * eth_call instead of eth_sendTransaction.\n     */\n    function queryBatchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds\n    ) external returns (int256[] memory assetDeltas);\n}\n"
    },
    "contracts/LinearPoolSwap.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {IAsset} from \"./interfaces/IAsset.sol\";\nimport {IStaticATokenLM} from \"./interfaces/IStaticATokenLM.sol\";\nimport {ILendingPool} from \"./interfaces/ILendingPool.sol\";\nimport {IFlashLoanReceiver} from \"./interfaces/IFlashLoanReceiver.sol\";\nimport {DataTypes} from \"./interfaces/DataTypes.sol\";\nimport {ILinearPool} from \"./interfaces/ILinearPool.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\ncontract LinearPoolSwap is IFlashLoanReceiver {\n    IVault private vault;\n    IERC20 private token;\n    IStaticATokenLM private wrappedHToken;\n    bytes32 private poolId;\n    ILendingPool private lendingPool;\n    ILinearPool private linearPool;\n    uint256 constant UINT256_MAX = type(uint256).max;\n    enum op {\n        WIND,\n        UNWIND,\n        NOTHING\n    }\n\n    constructor(\n        address vaultAddress,\n        address lendingPoolAddress,\n        address tokenAddress,\n        address wrappedHTokenAddress,\n        address linearPoolAddress,\n        bytes32 _poolId\n    ) {\n        vault = IVault(vaultAddress);\n        lendingPool = ILendingPool(lendingPoolAddress);\n        token = IERC20(tokenAddress);\n        wrappedHToken = IStaticATokenLM(wrappedHTokenAddress);\n        linearPool = ILinearPool(linearPoolAddress);\n        poolId = _poolId;\n    }\n\n    function getBalancingOperation(\n        uint256 threshold\n    ) public view returns (op operation, uint256 amount) {\n        (uint256 _lowerTarget, uint256 _upperTarget) = linearPool.getTargets();\n        uint256 lowerTarget = (_lowerTarget / (10 ** (18 - token.decimals())));\n        uint256 upperTarget = (_upperTarget / (10 ** (18 - token.decimals())));\n        (uint256 balance, , , ) = vault.getPoolTokenInfo(poolId, token);\n        uint256 midTarget = (upperTarget + lowerTarget) / 2;\n        (uint256 avaibleToSwap, , , ) = vault.getPoolTokenInfo(\n            poolId,\n            wrappedHToken\n        );\n\n        if (balance < lowerTarget) {\n            operation = op.UNWIND;\n            amount = Math.min(\n                midTarget - balance,\n                (avaibleToSwap * 9500) / 10000\n            );\n            amount = amount > threshold ? amount : 0;\n        } else if (balance > upperTarget) {\n            operation = op.WIND;\n            amount = balance - midTarget;\n        } else {\n            operation = op.NOTHING;\n            amount = 0;\n        }\n    }\n\n    function checkIfPoolIsOutsideRange(\n        uint256 threshold\n    ) public view returns (bool) {\n        (op operation, uint256 amount) = getBalancingOperation(threshold);\n        return (operation != op.NOTHING);\n    }\n\n    function balancePool(uint256 threshold) public {\n        (op operation, uint256 amount) = getBalancingOperation(threshold);\n        IERC20 aToken = wrappedHToken.ATOKEN();\n        uint256 availableLiquidity = token.balanceOf(address(aToken));\n        uint256 counter = Math.min((amount / availableLiquidity) + 1, 10);\n\n        uint256 amountToBorrow = amount / counter;\n\n        address[] memory tokens = new address[](1);\n        tokens[0] = address(token);\n\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = amountToBorrow;\n\n        uint256[] memory modes = new uint256[](1);\n        modes[0] = 0;\n\n        bytes memory params = abi.encode(operation, msg.sender, counter);\n\n        lendingPool.flashLoan(\n            address(this),\n            tokens,\n            amounts,\n            modes,\n            address(this),\n            params,\n            0\n        );\n    }\n\n    function windXTimes(uint8 counter, uint256 amount) public {\n        token.transferFrom(msg.sender, address(this), amount);\n\n        for (uint8 i = 0; i < counter; i++) {\n            wind();\n        }\n\n        token.transfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    // Decrease main tokens in pool and increase wrapped tokens\n    function wind() private {\n        token.approve(address(wrappedHToken), UINT256_MAX);\n\n        wrappedHToken.deposit(\n            address(this),\n            token.balanceOf(address(this)),\n            0,\n            true\n        );\n        wrappedHToken.approve(address(vault), UINT256_MAX);\n\n        bytes memory userDataEncoded = \"\";\n\n        IVault.SingleSwap memory singleSwap = IVault.SingleSwap(\n            poolId,\n            IVault.SwapKind.GIVEN_IN,\n            IAsset(address(wrappedHToken)),\n            IAsset(address(token)),\n            wrappedHToken.balanceOf(address(this)),\n            userDataEncoded\n        );\n        IVault.FundManagement memory fundManagement = IVault.FundManagement(\n            address(this),\n            false,\n            payable(address(this)),\n            false\n        );\n\n        uint256 limit = (wrappedHToken.balanceOf(address(this)) * 90) / 100;\n        vault.swap(singleSwap, fundManagement, limit, UINT256_MAX);\n    }\n\n    function unwindXTimes(uint8 counter, uint256 amount) public {\n        token.transferFrom(msg.sender, address(this), amount);\n\n        for (uint8 i = 0; i < counter; i++) {\n            unwind();\n        }\n\n        token.transfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    // Increase tokens tokens in pool and decrease wrapped tokens\n    function unwind() private {\n        token.approve(address(vault), UINT256_MAX);\n\n        bytes memory userDataEncoded = \"\";\n\n        IVault.SingleSwap memory singleSwap = IVault.SingleSwap(\n            poolId,\n            IVault.SwapKind.GIVEN_IN,\n            IAsset(address(token)),\n            IAsset(address(wrappedHToken)),\n            token.balanceOf(address(this)),\n            userDataEncoded\n        );\n        IVault.FundManagement memory fundManagement = IVault.FundManagement(\n            address(this),\n            false,\n            payable(address(this)),\n            false\n        );\n\n        uint256 limit = (token.balanceOf(address(this)) * 90) / 100;\n        vault.swap(singleSwap, fundManagement, limit, UINT256_MAX);\n\n        wrappedHToken.withdraw(\n            address(this),\n            wrappedHToken.balanceOf(address(this)),\n            true\n        );\n    }\n\n    function flashLoanWind(uint8 counter, uint256 amount) public {\n        address[] memory tokens = new address[](1);\n        tokens[0] = address(token);\n\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = amount;\n\n        uint256[] memory modes = new uint256[](1);\n        modes[0] = 0;\n\n        bytes memory params = abi.encode(op.WIND, msg.sender, counter);\n\n        lendingPool.flashLoan(\n            address(this),\n            tokens,\n            amounts,\n            modes,\n            address(this),\n            params,\n            0\n        );\n    }\n\n    // counter should be up to 10 because of gas limit\n    function flashLoanUnwind(uint8 counter, uint256 amount) public {\n        address[] memory tokens = new address[](1);\n        tokens[0] = address(token);\n\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = amount;\n\n        uint256[] memory modes = new uint256[](1);\n        modes[0] = 0;\n\n        bytes memory params = abi.encode(op.UNWIND, msg.sender, counter);\n\n        lendingPool.flashLoan(\n            address(this),\n            tokens,\n            amounts,\n            modes,\n            address(this),\n            params,\n            0\n        );\n    }\n\n    function executeOperation(\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address initiator,\n        bytes calldata params\n    ) external override returns (bool) {\n        op decodedData;\n        address originalSender;\n        uint8 counter;\n        (decodedData, originalSender, counter) = abi.decode(\n            params,\n            (op, address, uint8)\n        );\n\n        revert(\"test B\");\n        if (decodedData == op.WIND) {\n            for (uint8 i = 0; i < counter; i++) {\n                wind();\n            }\n        } else if (decodedData == op.UNWIND) {\n            for (uint8 i = 0; i < counter; i++) {\n                unwind();\n            }\n        }\n\n        uint256 currentBalance = token.balanceOf(address(this));\n        uint256 returnValue = amounts[0] + premiums[0];\n\n        if (returnValue > currentBalance) {\n            revert(\"Negative profit!\");\n        } else if (returnValue < currentBalance) {\n            token.transfer(originalSender, currentBalance - returnValue);\n        }\n\n        token.approve(address(lendingPool), returnValue);\n        return true;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}